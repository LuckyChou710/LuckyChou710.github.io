<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>随笔-工具篇</title>
    <url>/Essay/Tools/</url>
    <content><![CDATA[<h2 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h2><p>fn + win 可以禁用win键</p>
<h2 id="抠图"><a href="#抠图" class="headerlink" title="抠图"></a>抠图</h2><p><a href="https://www.remove.bg/">https://www.remove.bg/</a></p>
<h2 id="浏览器控制台"><a href="#浏览器控制台" class="headerlink" title="浏览器控制台"></a>浏览器控制台</h2><p>shift + enter 可以多行输入</p>
<a id="more"></a>

<h2 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h2><p><a href="https://github.com/meng-chuan/Unlock-netease-cloud-music?utm_source=gold_browser_extension">网易云灰度歌曲解锁</a></p>
<h2 id="vuepress"><a href="#vuepress" class="headerlink" title="vuepress"></a>vuepress</h2><p>文章无法正常渲染 页面空白</p>
<p>vuepress会解析md文件中的htnl标签  注意内容是否包含错误的标签</p>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>git push 进度条卡住</p>
<p><code>git config --global http.postBuffer 524288000</code></p>
<h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><p>查看全局安装的npm包</p>
<p>npm list -g –depth 0</p>
<h2 id="Chrome-DevTools"><a href="#Chrome-DevTools" class="headerlink" title="Chrome DevTools"></a>Chrome DevTools</h2><p><a href="https://juejin.im/post/5ec338436fb9a0432d76e0c4">Chrome DevTools中的这些骚操作，你都知道吗？</a></p>
<h2 id="ssh配置"><a href="#ssh配置" class="headerlink" title="ssh配置"></a>ssh配置</h2><p><a href="https://blog.csdn.net/lizhiqiang1217/article/details/88801158">GitLab配置SSH密钥</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-策略模式</title>
    <url>/Design-Pattern/strategy/</url>
    <content><![CDATA[<blockquote>
<p>转载自<a href="https://www.wekic.com/article/30">Vincent</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>策略模式是定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。将不变的部分和变化的部分隔开是每个设计模式的主题。策略模式的目的就是使算法的使用与算法分离开来。封装的算法具有一定的独立性，不会随客户端的变化而变化。</p>
<p>一个策略模式的程序至少有两部分组成。第一部分是策略类，策略类封装了具体的算法，负责具体的计算过程。 第二部分是环境类<code>Context</code>，它接受了客户的要求，随后吧请求委托给某一具体的策略类。要做到这点,<code>Context</code>中要维持对摸个策略对象的引用。</p>
<a id="more"></a>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这个 demo 是一个计算的代码段</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">type, number1, number2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;add&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> number1 + number2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;subtract&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> number1 - number2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;multiply&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> number1 * number2;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> number1 / number2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if else</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count1</span>(<span class="params">type, number1, number2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;add&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> number1 + number2;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;subtract&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> number1 - number2;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;multiply&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> number1 * number2;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number1 / number2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者这中间的<code>switch</code>用<code>if...else...</code>来实现，但<code>switch</code>比<code>if...else...</code>更加一目了然。这段计算方法本身没有问题，但是有更加便于维护和扩展的实现方式。下面来进行改进</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = &#123;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">number1, number2</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number1 + number2;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">subtract</span>(<span class="params">number1, number2</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number1 - number2;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">multiply</span>(<span class="params">number1, number2</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number1 * number2;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">divide</span>(<span class="params">number1, number2</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number1 / number2;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">count.add(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">count.subtract(<span class="number">10</span>, <span class="number">3</span>); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">count.multiply(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">count.divide(<span class="number">6</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>经过改造后，可以看成是一个策略模式，接下来看个复杂的例子。商场的会员分普通会员、银卡会员、金卡会员、钻石会员、至尊会员等级别，在商场消费享不同的折扣和积分。会员在同一商品的折扣分别是 98、95、9、8.8、8.5 折优惠。积分比例分别是 1、1.2、1.5、1.6、1.8。购买商品对应的会员折扣和积分获取用策略模式来实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> priceStrategy = &#123;</span><br><span class="line">  <span class="function"><span class="title">level1</span>(<span class="params">price</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> price * (<span class="number">98</span> / <span class="number">100</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">level2</span>(<span class="params">price</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> price * (<span class="number">95</span> / <span class="number">100</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">level3</span>(<span class="params">price</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> price * (<span class="number">90</span> / <span class="number">100</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">level4</span>(<span class="params">price</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> price * (<span class="number">88</span> / <span class="number">100</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">level5</span>(<span class="params">price</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> price * (<span class="number">85</span> / <span class="number">100</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cumulativeScoreStrategy = &#123;</span><br><span class="line">  <span class="function"><span class="title">level1</span>(<span class="params">price</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(price);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">level2</span>(<span class="params">price</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(price * <span class="number">1.1</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">level3</span>(<span class="params">price</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(price * <span class="number">1.2</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">level4</span>(<span class="params">price</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(price * <span class="number">1.3</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">level5</span>(<span class="params">price</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(price * <span class="number">1.4</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculatePrice</span>(<span class="params">level, price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> priceStrategy[level] ? priceStrategy[level](price) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateScore</span>(<span class="params">level, price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> actually = calculatePrice(level, price);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    cumulativeScoreStrategy[level] &amp;&amp; cumulativeScoreStrategy[level](actually)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  一台的彩电的价格是 8888，钻石会员的折后价</span></span><br><span class="line">calculatePrice(<span class="string">&#x27;level4&#x27;</span>, <span class="number">8888</span>); <span class="comment">// 7554.8</span></span><br><span class="line"><span class="comment">// 获得的积分</span></span><br><span class="line">calculateScore(<span class="string">&#x27;level4&#x27;</span>, <span class="number">8888</span>); <span class="comment">// 10567</span></span><br></pre></td></tr></table></figure>

<p>表单验证的策略模式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> strategies = &#123;</span><br><span class="line">  <span class="function"><span class="title">isCorrectPassword</span>(<span class="params">value, errorMsg</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/^(?:(?=.*[A-Z])(?=.*[0-9])).\\S&#123;7,19&#125;$/</span>.test(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">isNotEmpty</span>(<span class="params">value, errorMsg</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="string">&#x27;&#x27;</span> || value === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">minLength</span>(<span class="params">value, length, errorMsg</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.length &lt; length) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">maxLength</span>(<span class="params">value, length, errorMsg</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.length &gt; length) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">isMobile</span>(<span class="params">value, errorMsg</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/(^1[3|5|8][0-9]&#123;9&#125;$)/</span>.test(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">isNotAllEmpty</span>(<span class="params">value = [], errorMsg</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!value.some(<span class="function">(<span class="params">i</span>) =&gt;</span> !!i)) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cache = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">value, rules</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, rule; (rule = rules[i++]); ) &#123;</span><br><span class="line">      <span class="keyword">const</span> strategyArray = rule.strategy.split(<span class="string">&#x27;:&#x27;</span>) || [];</span><br><span class="line">      <span class="keyword">const</span> &#123; errorMsg &#125; = rule;</span><br><span class="line">      <span class="built_in">this</span>.cache.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> strategy = strategyArray.shift();</span><br><span class="line">        strategyArray.unshift(value);</span><br><span class="line">        strategyArray.push(errorMsg);</span><br><span class="line">        <span class="keyword">return</span> strategies[strategy].apply(value, strategyArray);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, validatorFunc; (validatorFunc = <span class="built_in">this</span>.cache[i++]); ) &#123;</span><br><span class="line">      <span class="keyword">const</span> msg = validatorFunc();</span><br><span class="line">      <span class="keyword">if</span> (msg) &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> validator = <span class="keyword">new</span> Validator();</span><br><span class="line">validator.add(registerForm.userName, [</span><br><span class="line">  &#123;</span><br><span class="line">    strategy: <span class="string">&#x27;isNonEmpty&#x27;</span>,</span><br><span class="line">    errorMsg: <span class="string">&#x27;userName not empty!&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    strategy: <span class="string">&#x27;minLength:6&#x27;</span>,</span><br><span class="line">    errorMsg: <span class="string">&#x27;userName length should more than 6&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br><span class="line">validator.add(registerForm.password, [</span><br><span class="line">  &#123;</span><br><span class="line">    strategy: <span class="string">&#x27;minLength:6&#x27;</span>,</span><br><span class="line">    errorMsg: <span class="string">&#x27;password length should more than 6&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> errorMsg = validator.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (errorMsg) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(errorMsg);</span><br><span class="line">  <span class="keyword">return</span> errorMsg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>策略模式属于对象行为型模式，主要针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响 到客户端的情况下发生变化。通常，策略模式适用于当一个应用程序需要实现一种特定的服务或者功能，而且该程序有多种实现方式时使用。</p>
</blockquote>
<h2 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a>策略模式的优缺点</h2><p>策略模式是一种常用且有效的得设计模式，</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>· 减少重复代码 策略模式利用组合、委托和多态等技术和思想，减少很多模板代码。</p>
<p>· 扩展性 策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的策略类里面，使它们易于切换，易于理解，易于扩展。</p>
<p>· 在策略模式中的算法利用组合和委托让<code>Context</code>拥有执行算法的能力，这也是继承的一种更轻便的替换方案。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>· 使用策略模式会的程序增加了许多策略类或者策略对象，但实际上这比把他们负责的逻辑堆砌在<code>Context</code>中要更好。</p>
<p>· 要使用策略模式，必须了解所有的策略，必须了解各个策略之间的不同点，因为各种算法之间相互独立，对于复杂的算法处理相同的逻辑无法实现共享。</p>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Hi ～～～</title>
    <url>/Essay/Life/</url>
    <content><![CDATA[<p>👋 Hi, I’m @LuckyChou</p>
<p>👀 I’m interested in FE</p>
<p>🌱 I’m currently learning Typescript &amp;&amp; React &amp;&amp; Node</p>
<p>👻 Welcome to my Home –&gt; <a href="https://luckychou.gitee.io/">https://luckychou.gitee.io/</a></p>
<p>📝 Mail me –&gt; <a href="mailto:&#x39;&#52;&#52;&#x32;&#54;&#56;&#54;&#x31;&#x38;&#64;&#x71;&#x71;&#46;&#99;&#111;&#109;">&#x39;&#52;&#52;&#x32;&#54;&#56;&#54;&#x31;&#x38;&#64;&#x71;&#x71;&#46;&#99;&#111;&#109;</a></p>
<p>🍉 Star me –&gt; <a href="https://github.com/LuckyChou710">https://github.com/LuckyChou710</a></p>
<p>😜 React 小册 –&gt; <a href="https://www.yuque.com/u12206867/react">https://www.yuque.com/u12206867/react</a></p>
<img src="https://gitee.com/LuckyChou/blog-images/raw/master/bg-images/CHOU16.jpg" />

<p>在选择要系统地学习一个新的 框架/库 之前，首先至少得学会先去思考以下两点：</p>
<p>• 它是什么？</p>
<p>• 它解决了什么问题？</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-单例模式</title>
    <url>/Design-Pattern/singleton/</url>
    <content><![CDATA[<p>单例模式的定义是： 保证一个类有且仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>思路： 用闭包返回一个实例 对这个实例做条件判断 有就返回 没有就初始化 这样我们在每次 new 的时候就只能得到一个实例</p>
<p>例如 全局的蒙层 全局的变量都适合用单例模式来创建 因为我们谁也不希望存在两个蒙层</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Singleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 你的业务逻辑</span></span><br><span class="line">    <span class="comment">// 例如</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;LuckyChou&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (instance = <span class="built_in">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// &#123; name: &#x27;chou&#x27;, age: 18 &#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome 跨域设置</title>
    <url>/Others/chrome/</url>
    <content><![CDATA[<h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">open -n -a <span class="string">&#x27;/Applications/Google Chrome.app&#x27;</span> --args --user-data-dir=<span class="string">&quot;/tmp/chrome_dev_test&quot;</span> --disable-web-security</span><br></pre></td></tr></table></figure>

<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">- 在电脑上新建一个目录，例如：C:\MyChromeDevUserData</span><br><span class="line"></span><br><span class="line">- 在属性页面中的目标输入框里加上 --disable-web-security --user-data-dir=C:\MyChromeDevUserData，--user-data-dir 的值就是刚才新建的目录</span><br><span class="line"></span><br><span class="line">- 点击应用和确定后关闭属性页面，并打开 chrome 浏览器</span><br></pre></td></tr></table></figure>

<h3 id="2021-4-更新"><a href="#2021-4-更新" class="headerlink" title="2021.4 更新"></a>2021.4 更新</h3><p>浏览器发送请求 但是无法带上 cookie 导致 页面一直重定向</p>
<p>1、在谷歌浏览器中搜索 chrome://flags/<br>2、在出现的页面搜索框中搜索 SameSite<br>3、把第一个改为 disable<br>4、然后重启浏览器</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>oh-my-zsh 美化iterm2 / vs code</title>
    <url>/Others/oh-my-zsh/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/9c3439cc3bdb">配置iterm2</a></p>
<p><a href="https://blog.csdn.net/qwe641259875/article/details/107201760/">国内安装oh-my-zsh<a></p>
<blockquote>
<p>在VSCode的settings.json文件，加入 : “terminal.integrated.fontFamily”: “Meslo LG M for Powerline”,</p>
</blockquote>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>vim常用命令</title>
    <url>/Others/vim/</url>
    <content><![CDATA[<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>默认进入命令模式 在其他模式下按 esc 进入命令模式<br>x 删除光标所在字符<br>dd 删除光标所在行<br>u 复原到上一个动作<br>ctrl + r 重做上一个动作<br>G 跳到文本末<br>gg 跳到文本第一个字符<br>^ 跳到当前行到第一个字符</p>
<h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><p>在命令模式 输入 i / a / o 进入输入模式</p>
<h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><p>在命令模式输入 英文输入法下的 : 进入<br>q 退出<br>w 保存</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>Git / Github / Gitee</title>
    <url>/Others/git/</url>
    <content><![CDATA[<p>本文主要罗列一些</p>
<ul>
<li><p>我在使用 git 时候的问题</p>
</li>
<li><p>git 的常见命令</p>
</li>
</ul>
<p>一方面做个排坑的梳理 一方面也方便自己以后查询这些命令</p>
<h2 id="排坑"><a href="#排坑" class="headerlink" title="排坑"></a>排坑</h2><h3 id="git-pull-push-卡住"><a href="#git-pull-push-卡住" class="headerlink" title="git pull / push 卡住"></a>git pull / push 卡住</h3><p><code>git pull / push</code>卡住的可能性有很多</p>
<p>自己亲测发生这种问题的时候 往往是 github 也几乎进不去 <code>ping github.com</code> 丢包也很严重</p>
<p>这里可以登录 ipaddress.com 查看 github.com 的 ip 然后修改 host 可以借助 switchHosts 快速修改 hosts</p>
<h3 id="gitee-图床"><a href="#gitee-图床" class="headerlink" title="gitee 图床"></a>gitee 图床</h3><p>因为 gitee 国内速度比 github 快 所以博主使用 gitee 作为自己的图床</p>
<p>但是某一次在使用的时候 却发现了跨域问题？？？？？难道是 gitee 设置了防盗链</p>
<p>排查之后发现 是因为图片大于 1M gitee 就需要登录校验身份 所以图片需要小于 1M</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th>快速切换到上一个分支</th>
<th>git checkout -</th>
</tr>
</thead>
<tbody><tr>
<td>撤销当前分支的所有修改</td>
<td>git checkout .</td>
</tr>
<tr>
<td>拉取远程分支</td>
<td>git checkout -b [localbranch]/[remote] [branch]</td>
</tr>
<tr>
<td>强制删除分支</td>
<td>git branch -D [branch]</td>
</tr>
<tr>
<td>将 dev 分支和当前分支合并</td>
<td>git merge dev</td>
</tr>
<tr>
<td>查看暂存区的文件</td>
<td>git ls-files</td>
</tr>
<tr>
<td>删除暂存区里的文件</td>
<td>git rm –cached [file]</td>
</tr>
<tr>
<td>本地分支关联远程分支</td>
<td>git branch –set-upstream-to [remote]/[branch] [localbranch]</td>
</tr>
<tr>
<td>回退版本</td>
<td>git reset –hard [id]</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="git-commit-规范"><a href="#git-commit-规范" class="headerlink" title="git commit 规范"></a>git commit 规范</h2><p>良好的 git commit 不仅有良好的可读性 而且有利于生成 change logs 做一些自动化的事情</p>
<p>例如 angular.js 的 官网 <a href="https://github.com/angular/angular">https://github.com/angular/angular</a></p>
<p>在这里 git commit 就非常清晰 不同的 commit 分成了不同的类型 让人一眼就知道这次 commit 对应干了什么</p>
<p>commit 的规范 网上有很多介绍 这里只说一点</p>
<p>Commit message 都包括三个部分：header，body 和 footer</p>
<ul>
<li><p>Header</p>
<ul>
<li><p>type （必需） commit 的类别</p>
</li>
<li><p>scope 影响的范围</p>
</li>
<li><p>subject（必需） 简短的说明</p>
</li>
</ul>
</li>
<li><p>Body 详细的说明</p>
</li>
<li><p>Footer</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>type 的类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>feat</td>
<td>新增功能</td>
</tr>
<tr>
<td>fix</td>
<td>bug 的修复</td>
</tr>
<tr>
<td>perf</td>
<td>性能优化</td>
</tr>
<tr>
<td>refactor</td>
<td>重构代码(既没有新增功能，也没有修复 bug)</td>
</tr>
<tr>
<td>build</td>
<td>主要目的是修改项目构建系统(例如 glup，webpack，rollup 的配置等)的提交</td>
</tr>
<tr>
<td>ci</td>
<td>主要目的是修改项目继续集成流程(例如 Travis，Jenkins，GitLab CI，Circle 等)的提交</td>
</tr>
<tr>
<td>docs</td>
<td>文档更新</td>
</tr>
<tr>
<td>style</td>
<td>不影响程序逻辑的代码修改(修改空白字符，补全缺失的分号等)</td>
</tr>
<tr>
<td>revert</td>
<td>回滚某个更早之前的提交</td>
</tr>
<tr>
<td>chore</td>
<td>变更构建流程和辅助工具</td>
</tr>
<tr>
<td>test</td>
<td>新增测试用例或是更新现有测试</td>
</tr>
</tbody></table>
<p>这里主要的话 还是推荐一款插件去帮助我们规范自己的 commit 就是 husky</p>
<p><strong>1、Git Commit 检测工具链</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D husky @commitlint/config-conventional @commitlint/cli</span><br></pre></td></tr></table></figure>

<p>配置 husky 插件（在 package.json 中新增一个 husky 相关配置）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;husky&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;pre-commit&quot;</span>: <span class="string">&quot;npm run lint&quot;</span>, <span class="comment">// 不需要在Commit时lint，不配置此项</span></span><br><span class="line">    <span class="string">&quot;commit-msg&quot;</span>: <span class="string">&quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span> <span class="comment">// 提交信息检测</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在项目的根目录下新建一个 commitlint.config.js 文件</p>
<p><strong>Husky 配置</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="keyword">extends</span>: [<span class="string">&#x27;@commitlint/config-conventional&#x27;</span>], <span class="comment">// 使用@commitlint/config-conventional规范</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上配置完毕后，如果不按照规范提交是无法提交的。</p>
<p>husky 工具会直接从 Git 命令层面打断你的提交。</p>
<p>请按照规范进行提交</p>
<p><strong>2、辅助 Git Commit 提交格式化的的工具</strong></p>
<p><strong>辅助提交工具</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D commitizen // 本地安装</span><br><span class="line"></span><br><span class="line">npm install -g commitizen // 全局安装，全局安装后可以使用 git cz 命令，运行git cz 会帮助我们打开交互式的提交</span><br></pre></td></tr></table></figure>

<p>本地项目 commitizen 配置（在 package.json 中）</p>
<p><strong>cz 命令配置</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;cz&quot;</span>: <span class="string">&quot;git-cz&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;config&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;commitizen&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;path&quot;</span>: <span class="string">&quot;./node_modules/cz-conventional-changelog&quot;</span> <span class="comment">// 这个文件是commitizen的内部依赖，里面定义了符合Angular提交规范的相关信息，也会方便我们后续生成changelog.md的日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置完毕后，就可以使用 git cz(全局) 或者 npm run cz/yarn cz 帮助我们进行提交了</p>
<p><strong>3、日志生成与版本号自动控制工具（项目管理者使用，成员了解即可）</strong></p>
<p><strong>changelog</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">yarn add -D standard-version</span><br><span class="line"></span><br><span class="line">在package.json 中的配置</span><br><span class="line"></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;major&quot;: &quot;standard-version -r major&quot;, // 一个最大的版本升级, 会生成相关的changelog,修改版本号 1.0.0 -&gt; 2.0.0，生成一个Tag</span><br><span class="line">    &quot;minor&quot;: &quot;standard-version -r minor&quot;, // 中等的版本升级 会生成相关的changelog,修改版本号 1.0.0 -&gt; 1.1.0, 生成一个Tag</span><br><span class="line">    &quot;patch&quot;: &quot;standard-version -r patch --skip.tag&quot;,// 最小的版本升级 会生成相关的changelog,修改版本号 1.0.0 -&gt; 1.0.1, 跳过生成Tag.</span><br><span class="line">    &quot;init&quot;: &quot;standard-version  --first-release --skip.tag&quot; // 首次生成相关的changelog, 不修改版本号, 跳过生成Tag. // 也可以不配置进脚本，用npx standard-version  --first-release --skip.tag 执行</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-队列</title>
    <url>/Data-Structure/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li><p>初始化</p>
</li>
<li><p>入队</p>
</li>
<li><p>出队</p>
</li>
<li><p>判断队空 队满</p>
</li>
<li><p>应用</p>
</li>
</ul>
<a id="more"></a>

<h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>头指针 front 指向队头元素</p>
<p>尾指针 rear 指向下一个插入元素的位置</p>
<p>初始化时 将队头指针和队尾指针指向 0</p>
<p>则 判断队空 条件 头指针 = 尾指针</p>
<p>出队入队后 下一个头指针 尾指针的指向 （front++）% MaxSize</p>
<p>判断队满条件 则为 下一个尾指针 = 头指针</p>
<p>ps 因为此思路 头指针 = 尾指针 为队空条件 所以需要牺牲最后一个 存储空间</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> front, rear;</span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.rear = <span class="number">0</span>;</span><br><span class="line">    Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MaxSize == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Q.data[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Q.front; i &lt; Q.rear; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>,Q.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    EnQueue(Q,<span class="number">1</span>);</span><br><span class="line">    EnQueue(Q,<span class="number">2</span>);</span><br><span class="line">    EnQueue(Q,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">-1</span>;</span><br><span class="line">    DeQueue(Q,i);</span><br><span class="line">    PrintQueue(Q);</span><br><span class="line">    <span class="comment">//Test......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>再定义一个 size 记录 队列长度 通过 size 来判断 队列 为空和满 这样就不用浪费最后一个存储空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> front, rear;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>

<h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>功能受限的单链表 表尾插入 表头删除</p>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><h3 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h3><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><h5 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h5><h5 id="前缀表达式（波兰表达式）"><a href="#前缀表达式（波兰表达式）" class="headerlink" title="前缀表达式（波兰表达式）"></a>前缀表达式（波兰表达式）</h5><h5 id="后缀表达式（逆波兰表达式）"><a href="#后缀表达式（逆波兰表达式）" class="headerlink" title="后缀表达式（逆波兰表达式）"></a>后缀表达式（逆波兰表达式）</h5><p>运算符在两个操作数后面</p>
<p>ab+cd*-</p>
<ol>
<li><p>a+b</p>
</li>
<li><p>c*d</p>
</li>
<li><p>a+b - c*d</p>
</li>
</ol>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>最后被调用的函数最先结束</p>
]]></content>
      <categories>
        <category>Date Structure</category>
      </categories>
      <tags>
        <tag>Date Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-栈</title>
    <url>/Data-Structure/%E6%A0%88/</url>
    <content><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li><p>初始化</p>
</li>
<li><p>销毁</p>
</li>
<li><p>进栈</p>
</li>
<li><p>出栈</p>
</li>
<li><p>读取栈顶元素</p>
</li>
<li><p>判断栈空</p>
</li>
<li><p>判断栈满</p>
</li>
</ul>
<a id="more"></a>

<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p>栈顶指针指向-1</p>
<p>判断栈满 栈顶指针 = 栈的 MaxSize - 1</p>
<p>判断栈空 栈顶指针 = -1</p>
<p>同理 栈顶指针还可以指向 0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.data[++S.top] = e;<span class="comment">//指针先加1 新元素再进栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = S.data[S.top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack &amp;S, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="comment">//test......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><p>思路：先进后出</p>
<p>使用操作受限的链表</p>
<p>进栈 头插法</p>
<p>出栈 删除第一个结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkNode, *LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitLinkStack</span><span class="params">(LinkStack &amp;S)</span> </span>&#123;</span><br><span class="line">    S = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span> (S == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈    相当于链表的头插法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(LinkStack &amp;S, ElemType e)</span> </span>&#123;</span><br><span class="line">    LinkNode *l = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    l-&gt;next = S-&gt;next;</span><br><span class="line">    S-&gt;next = l;</span><br><span class="line">    l-&gt;data = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈    每次删除第一个结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(LinkStack &amp;S, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;next == <span class="literal">NULL</span>)<span class="comment">//判断栈是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S-&gt;next = S-&gt;next-&gt;next;</span><br><span class="line">    e = S-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印链栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintStack</span><span class="params">(LinkStack &amp;S)</span> </span>&#123;</span><br><span class="line">    LinkNode *p = S;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, p-&gt;next-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkStack S;</span><br><span class="line">    InitLinkStack(S);</span><br><span class="line">	<span class="comment">//Test......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Date Structure</category>
      </categories>
      <tags>
        <tag>Date Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-链表</title>
    <url>/Data-Structure/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li><p>单链表</p>
</li>
<li><p>双链表</p>
</li>
<li><p>循环链表</p>
</li>
<li><p>静态链表</p>
</li>
</ul>
<a id="more"></a>

<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//数据项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针项</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在位序i处插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;<span class="comment">//初始化一个指向头结点的指针p</span></span><br><span class="line">    <span class="comment">//找到i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在p结点之后插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode *p, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在p结点之前插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    s-&gt;data = p-&gt;data;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = s;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList &amp;L, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q = p-&gt;next;<span class="comment">//被删除的结点</span></span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除指定结点p</span></span><br><span class="line"><span class="comment">//单链表找不到前继结点 将被删除结点的后继结点赋值给删除节点 然后删除后继结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q = p-&gt;next;</span><br><span class="line">    p-&gt;data = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位查找第i个元素</span></span><br><span class="line"><span class="function">LNode *<span class="title">GetElem</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找</span></span><br><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList &amp;L, ElemType e)</span> </span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;<span class="comment">//从第一个结点开始查找</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求表长</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, p-&gt;next-&gt;data);<span class="comment">//p指向头结点 头结点不含数据项</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    initList(L);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        ListInsert(L, i, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>思路</p>
<p>在单链表的基础上 多了前项指针 指向前一个节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125; DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (DNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;next != <span class="literal">NULL</span>)<span class="comment">//如果q结点不是最后一个结点</span></span><br><span class="line">        q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//Test......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>思路</p>
<p>在单链表的基础上 尾指针指回头结点</p>
<p>初始化时 头结点的 next 指针指向自己</p>
<p>则 判断表空条件则为头指针是否指向自己</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = L;<span class="comment">//!!!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Date Structure</category>
      </categories>
      <tags>
        <tag>Date Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器工作原理</title>
    <url>/FE/Browser/broswer/</url>
    <content><![CDATA[<h2 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h2><img src="http://img.smyhvae.com/20180124_1700.png" style="zoom: 80%;" />

<a id="more"></a>

<p>1、User Interface  用户界面，我们所看到的浏览器</p>
<p>2、Browser engine  浏览器引擎，用来查询和操作渲染引擎</p>
<p>3、Rendering engine 用来显示请求的内容，负责解析HTML、CSS</p>
<p>4、Networking   网络，负责发送网络请求</p>
<p>5、JavaScript Interpreter(解析者)   JavaScript解析器，负责执行JavaScript的代码</p>
<p>6、UI Backend   UI后端，用来绘制类似组合框和弹出窗口</p>
<p>7、Data Persistence(持久化)  数据持久化，数据存储  cookie、HTML5中的sessionStorage</p>
]]></content>
      <categories>
        <category>Browser</category>
      </categories>
      <tags>
        <tag>Browser</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie / session</title>
    <url>/FE/Browser/cookie-session/</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://blog.csdn.net/weixin_34332905/article/details/91362567?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">CSDN</a></p>
</blockquote>
<h3 id="第一层楼"><a href="#第一层楼" class="headerlink" title="第一层楼"></a>第一层楼</h3><p>什么是 Cookie</p>
<p>HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是<strong>服务器发送到用户浏览器</strong>并保存在本地的一小块数据，</p>
<p>它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</p>
<p>通常，它用于告知服务端两个请求是否来自同一浏览器，如<strong>保持用户的登录状态</strong>。</p>
<p>Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
<p>Cookie 主要用于以下三个方面：</p>
<ul>
<li><p>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</p>
</li>
<li><p>个性化设置（如用户自定义设置、主题等）</p>
</li>
<li><p>浏览器行为跟踪（如跟踪分析用户行为等）</p>
</li>
</ul>
<p>什么是 Session</p>
<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。</p>
<p>这样，</p>
<p><strong>当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，</strong></p>
<p><strong>而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束</strong>。</p>
<a id="more"></a>

<h3 id="第二层楼"><a href="#第二层楼" class="headerlink" title="第二层楼"></a>第二层楼</h3><p>Cookie 和 Session 有什么不同？</p>
<p>作用范围不同，<strong>Cookie 保存在客户端（浏览器），Session 保存在服务器端</strong>。</p>
<p>存取方式的不同，<strong>Cookie 只能保存 ASCII，Session 可以存任意数据类型</strong>，</p>
<p>一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</p>
<p>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，</p>
<p>Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</p>
<p>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，</p>
<p>早期有人将用户的登录名和密码存储在 Cookie中导致信息被窃取；</p>
<p>Session 存储在服务端，安全性相对 Cookie 要好一些。</p>
<p>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</p>
<h3 id="第三层楼"><a href="#第三层楼" class="headerlink" title="第三层楼"></a>第三层楼</h3><p>为什么需要 Cookie 和 Session，他们有什么关联？</p>
<p>说起来为什么需要 Cookie ，这就需要从浏览器开始说起，我们都知道浏览器是没有状态的(HTTP 协议无状态)，</p>
<p>这意味着浏览器并不知道是张三还是李四在和服务端打交道。</p>
<p>这个时候就需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作，</p>
<p>那这套机制的实现就需要 Cookie 和 Session 的配合。</p>
<p>那么 Cookie 和 Session 是如何配合的呢？</p>
<p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session ，</p>
<p>请求返回时将此Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，</p>
<p>会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>
<p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，</p>
<p>如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，</p>
<p>再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，</p>
<p>如果找到 Session 证明用户已经登录可执行后面操作。</p>
<p>根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p>
<h3 id="第四层楼"><a href="#第四层楼" class="headerlink" title="第四层楼"></a>第四层楼</h3><p>既然服务端是根据 Cookie 中的信息判断用户是否登录，</p>
<p>那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转。</p>
<p>第一种方案，每次请求中都携带一个 SessionID 的参数，</p>
<p>也可以 Post 的方式提交，也可以在请求的地址后面拼接xxx?SessionID=123456…。</p>
<p>第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。</p>
<p>Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。</p>
<p>Token 机制和 Cookie 和 Session 的使用机制比较类似。</p>
<p>当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，</p>
<p>以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。</p>
<h3 id="第五层楼"><a href="#第五层楼" class="headerlink" title="第五层楼"></a>第五层楼</h3><p>如何考虑分布式 Session 问题？</p>
<p>在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，</p>
<p>那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。</p>
<p>分布式 Session 一般会有以下几种解决方案：</p>
<ul>
<li><p>Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，</p>
<p>这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</p>
</li>
<li><p>Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</p>
</li>
<li><p>共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。</p>
</li>
</ul>
<p>建议采用第三种方案。</p>
<h3 id="第六层楼"><a href="#第六层楼" class="headerlink" title="第六层楼"></a>第六层楼</h3><p>如何解决跨域请求？Jsonp 跨域的原理是什么？</p>
<p>说起跨域请求，必须要了解浏览器的同源策略，同源策略/SOP（Same origin policy）是一种约定，</p>
<p>由 Netscape 公司 1995年引入浏览器，它是浏览器最核心也最基本的安全功能，</p>
<p>如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。</p>
<p>所谓同源是指”<strong>协议+域名+端口</strong>“三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。</p>
<p>解决跨域请求的常用方法是：</p>
<p>通过代理来避免，比如使用 Nginx 在后端转发请求，避免了前端出现跨域的问题。</p>
<p>通过 Jsonp 跨域</p>
<p>其它跨域解决方案</p>
<p>重点谈一下 Jsonp 跨域原理。浏览器的同源策略把跨域请求都禁止了，</p>
<p>但是页面中的 <code>&lt;script&gt;</code> <code>&lt;img&gt;</code> <code>&lt;iframe&gt;</code>标签是例外，不受同源策略限制。</p>
<p>Jsonp 就是利用 <code>&lt;script&gt;</code> 标签跨域特性进行跨域数据访问。</p>
<p>JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，</p>
<p>在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。</p>
<p>当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了。</p>
<p>JSONP 的缺点是：它只支持 GET 请求，而不支持 POST 请求等其他类型的 HTTP 请求。</p>
]]></content>
      <categories>
        <category>Browser</category>
      </categories>
      <tags>
        <tag>Browser</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器缓存</title>
    <url>/FE/Browser/cache/</url>
    <content><![CDATA[<blockquote>
<p>转载自<a href="https://www.yuque.com/suihangadam/liulanqi/gcmgi4">https://www.yuque.com/suihangadam/liulanqi/gcmgi4</a></p>
</blockquote>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>浏览器缓存（Browser Caching）是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。</p>
<h2 id="简单释义"><a href="#简单释义" class="headerlink" title="简单释义"></a>简单释义</h2><p>浏览器缓存其实就是浏览器保存通过 HTTP 获取的所有资源,是浏览器将网络资源存储在本地的一种行为。浏览器的缓存机制是根据 HTTP 报文的缓存标识进行的。</p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>通常浏览器缓存策略分为两种：强缓存（<strong>Expires</strong>，<strong>cache-control</strong>）和协商缓存（<strong>last-modified</strong> ，<strong>Etag</strong>），并且缓存策略都是通过设置 HTTP Header 来实现的。</p>
<h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>response header 里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强制缓存。</p>
<h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>当值设为 max-age=300 时，则代表在这个请求正确返回时间（浏览器也会记录下来）的 5 分钟内再次加载资源，就会命中强缓存。</p>
<p><img src="https://gitee.com/LuckyChou/blog-images/raw/master/browser/browser1.png" alt="image"></p>
<a id="more"></a>

<h4 id="Expires-和-Cache-Control-的区别"><a href="#Expires-和-Cache-Control-的区别" class="headerlink" title="Expires 和 Cache-Control 的区别"></a>Expires 和 Cache-Control 的区别</h4><ol>
<li>Expires 是 http1.0 的产物，Cache-Control 是 http1.1 的产物</li>
<li>两者同时存在的话，Cache-Control 优先级高于 Expires；</li>
<li>在某些不支持 HTTP1.1 的环境下，Expires 就会发挥用处。所以 Expires 其实是过时的产物，现阶段它的存在只是一种兼容性的写法</li>
<li>Expires 是一个具体的服务器时间，这就导致一个问题，如果客户端时间和服务器时间相差较大，缓存命中与否就不是开发者所期望的。Cache-Control 是一个时间段，控制就比较容易</li>
</ol>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a><strong>协商缓存</strong></h3><h4 id="ETag-和-If-None-Match"><a href="#ETag-和-If-None-Match" class="headerlink" title="ETag 和 If-None-Match"></a>ETag 和 If-None-Match</h4><p>这两个要一起说。Etag 是上一次加载资源时，服务器返回的 response header，是对该资源的一种唯一标识，只要资源有变化，Etag 就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 Etag 值放到 request header 里的 If-None-Match 里，服务器接受到 If-None-Match 的值后，会拿来跟该资源文件的 Etag 值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存。<img src="https://gitee.com/LuckyChou/blog-images/raw/master/browser/browser2.png" alt="image"></p>
<h4 id="Last-Modified-和-If-Modified-Since"><a href="#Last-Modified-和-If-Modified-Since" class="headerlink" title="Last-Modified 和 If-Modified-Since"></a>Last-Modified 和 If-Modified-Since</h4><p>这两个也要一起说。Last-Modified 是该资源文件最后一次更改时间，服务器会在 response header 里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到 request header 里的 If-Modified-Since 里，服务器在接收到后也会做比对，如果相同则命中协商缓存。</p>
<p><img src="https://gitee.com/LuckyChou/blog-images/raw/master/browser/browser3.png" alt="image"></p>
<h4 id="ETag-和-Last-Modified-区别"><a href="#ETag-和-Last-Modified-区别" class="headerlink" title="ETag 和 Last-Modified 区别"></a>ETag 和 Last-Modified 区别</h4><ol>
<li>在方式上，Etag 是对资源的一种唯一标识，而 Last-Modified 是该资源文件最后一次更改时间</li>
<li>在精确度上，Etag 要优于 Last-Modified。Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的 Last-Modified 也有可能不一致。</li>
<li>在性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值。</li>
<li>在优先级上，服务器校验优先考虑 Etag。</li>
</ol>
<h2 id="浏览器缓存过程"><a href="#浏览器缓存过程" class="headerlink" title="浏览器缓存过程"></a>浏览器缓存过程</h2><ol>
<li>浏览器第一次加载资源，服务器返回 200，浏览器将资源文件从服务器上请求下载下来，并把 response header 及该请求的返回时间一并缓存；</li>
<li>下一次加载资源时，先比较当前时间和上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持 HTTP1.1，则用 expires 判断是否过期）；如果时间过期，则向服务器发送 header 带有 If-None-Match 和 If-Modified-Since 的请求；</li>
<li>服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；</li>
<li>如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；</li>
</ol>
<p><img src="https://gitee.com/LuckyChou/blog-images/raw/master/browser/browser4.png" alt="image.png"></p>
<h2 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h2><p>从存储位置来看，浏览器缓存一共分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。</p>
<ul>
<li>Service Worker</li>
<li>Memory Cache</li>
<li>Disk Cache</li>
<li>Push Cache</li>
</ul>
<h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。<strong>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</strong></p>
<p>Service Worker 实现缓存功能一般分为三个步骤：</p>
<ol>
<li>首先需要先注册 Service Worker</li>
<li>然后监听到 install 事件以后就可以缓存需要的文件</li>
<li>那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</li>
</ol>
<p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p>
<h3 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h3><p>Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 <strong>一旦我们关闭 Tab 页面，内存中的缓存也就被释放了</strong>。</p>
<p>⚠️：<strong>内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control 是什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验</strong>。</p>
<h3 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h3><p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，<strong>比之 Memory Cache 胜在容量和存储时效性上。</strong>它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache。</p>
<h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。<strong>它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右</strong>，同时它也并非严格执行 HTTP 头中的缓存指令。他有如下的一些特性：</p>
<ul>
<li><p>所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差。</p>
</li>
<li><p>Push Cache 中的缓存只能被使用一次</p>
</li>
<li><p>可以给其他域名推送资源</p>
</li>
<li><p>浏览器可以拒绝接受已经存在的资源推送</p>
</li>
<li><p>一旦连接被关闭，Push Cache 就被释放</p>
</li>
<li><p>可以推送 no-cache 和 no-store 的资源</p>
</li>
<li><p>多个页面可以使用同一个 HTTP/2 的连接，也就可以使用同一个 Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的 tab 标签使用同一个 HTTP 连接。</p>
</li>
</ul>
<h2 id="用户行为对浏览器缓存的控制"><a href="#用户行为对浏览器缓存的控制" class="headerlink" title="用户行为对浏览器缓存的控制"></a>用户行为对浏览器缓存的控制</h2><ol>
<li>地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制；</li>
<li>F5 刷新，浏览器会设置 max-age=0，跳过强缓存判断，会进行协商缓存判断；</li>
<li>ctrl+F5 刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。</li>
</ol>
<h2 id="三级缓存原理-访问缓存优先级"><a href="#三级缓存原理-访问缓存优先级" class="headerlink" title="三级缓存原理 (访问缓存优先级)"></a>三级缓存原理 (访问缓存优先级)</h2><ol>
<li>先在内存中查找,如果有,直接加载。</li>
<li>如果内存中不存在,则在硬盘中查找,如果有直接加载。</li>
<li>如果硬盘中也没有,那么就进行网络请求。</li>
<li>请求获取的资源缓存到硬盘和内存。</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="内存缓存和硬盘缓存有什么区别？"><a href="#内存缓存和硬盘缓存有什么区别？" class="headerlink" title="内存缓存和硬盘缓存有什么区别？"></a>内存缓存和硬盘缓存有什么区别？</h3><blockquote>
<p>口诀：存速时空（存的速食都被我吃空了）</p>
</blockquote>
<table>
<thead>
<tr>
<th>区别</th>
<th>内存缓存</th>
<th>硬盘缓存</th>
</tr>
</thead>
<tbody><tr>
<td>存储内容</td>
<td>JS，字体，图片等</td>
<td>CSS 等</td>
</tr>
<tr>
<td>读取速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>时效性</td>
<td>进程关闭则清空</td>
<td>可以缓存较长时间</td>
</tr>
<tr>
<td>空间</td>
<td>空间小</td>
<td>空间大</td>
</tr>
</tbody></table>
<p>1.**内存缓存(from memory cache)**：内存缓存主要的两个特点，分别是快速读取和时效性：</p>
<ul>
<li><p>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。一般 JS,字体，图片等会放在内存缓存中</p>
</li>
<li><p>时效性：一旦该进程关闭，则该进程的内存则会清空。</p>
<p>2.**硬盘缓存(from disk cache)**：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行 I/O 操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。退出进程不会清空。一般 JS,字体，图片等会放在内存中，而 CSS 则会放在硬盘缓存中</p>
</li>
</ul>
<h3 id="浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？"><a href="#浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？" class="headerlink" title="浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？"></a>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</h3><p>判断是否命中强制缓存：当命中强制缓存时，状态码为 200, 请求对应的 Size 值则代表该缓存存放的位置，分别为 from memory cache 和 from disk cache。from memory cache 代表使用内存中的缓存，from disk cache 则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为 memory &gt; disk。</p>
<h3 id="为什么-CSS-会放在硬盘缓存中？"><a href="#为什么-CSS-会放在硬盘缓存中？" class="headerlink" title="为什么 CSS 会放在硬盘缓存中？"></a>为什么 CSS 会放在硬盘缓存中？</h3><p>因为 CSS 文件加载一次就可渲染出来,我们不会频繁读取它,所以它不适合缓存到内存中,但是 js 之类的脚本却随时可能会执行,如果脚本在磁盘当中,我们在执行脚本的时候需要从磁盘取到内存中来,这样 IO 开销就很大了,有可能导致浏览器失去响应。</p>
<h3 id="那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？"><a href="#那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？" class="headerlink" title="那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？"></a>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？</h3><p>这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。</p>
]]></content>
      <categories>
        <category>Browser</category>
      </categories>
      <tags>
        <tag>Browser</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG</title>
    <url>/FE/Bug/bug/</url>
    <content><![CDATA[<h3 id="清除-IOS-下-input-表单的阴影"><a href="#清除-IOS-下-input-表单的阴影" class="headerlink" title="清除 IOS 下 input 表单的阴影"></a>清除 IOS 下 input 表单的阴影</h3><p>在 IOS 下，input 表单默认会有个内阴影，一定程度上影响视觉一致，可通过设置下面代码去掉：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="清除-IOS-下-input-placeholder-没有垂直显示"><a href="#清除-IOS-下-input-placeholder-没有垂直显示" class="headerlink" title="清除 IOS 下 input placeholder 没有垂直显示"></a>清除 IOS 下 input placeholder 没有垂直显示</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HTTPS-Mixed-Content"><a href="#HTTPS-Mixed-Content" class="headerlink" title="HTTPS Mixed Content"></a>HTTPS Mixed Content</h3><p>问题：</p>
<blockquote>
<p>Mixed Content: The page at ‘<a href="https://www.xxx.com/denglu.html&#39;">https://www.xxx.com/denglu.html&#39;</a> was loaded over HTTPS, but requested an insecure script ‘<a href="http://qzonestyle.gtimg.cn/qzone/openapi/qc-1.0.1.js&#39;">http://qzonestyle.gtimg.cn/qzone/openapi/qc-1.0.1.js&#39;</a>. This request has been blocked; the content must be served over HTTPS.</p>
<p>问题原因：HTTPS 页面里动态的引入 HTTP 资源，比如引入一个 js 文件，会被直接 block 掉的.在 HTTPS 页面里通过 AJAX 的方式请求 HTTP 资源，也会被直接 block 掉的。</p>
</blockquote>
<p>解决方案：</p>
<p>给对应的网页添加上</p>
<p><code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt;</code></p>
<h3 id="图片之间有空隙"><a href="#图片之间有空隙" class="headerlink" title="图片之间有空隙"></a>图片之间有空隙</h3><p>给图片设置 <code>display:block</code> 即可</p>
<h3 id="图片下边框-3px（同上个问题）"><a href="#图片下边框-3px（同上个问题）" class="headerlink" title="图片下边框 3px（同上个问题）"></a>图片下边框 3px（同上个问题）</h3><p>给图片设置 <code>vertical-align: top</code></p>
<p>这样不会破坏原来的结构</p>
<h3 id="Chrome-谷歌浏览器下不支持-css-字体小于-12px"><a href="#Chrome-谷歌浏览器下不支持-css-字体小于-12px" class="headerlink" title="Chrome 谷歌浏览器下不支持 css 字体小于 12px"></a>Chrome 谷歌浏览器下不支持 css 字体小于 12px</h3><p>Chrome 浏览器最小字体支持 12px 若小于 12px 也会显示 12px</p>
<p>解决方案：transform:scale()</p>
<h3 id="display-flex-amp-amp-position-absolute-fixed"><a href="#display-flex-amp-amp-position-absolute-fixed" class="headerlink" title="display: flex &amp;&amp; position: absolute | fixed"></a>display: flex &amp;&amp; position: absolute | fixed</h3><p>被绝对定位与固定定位的盒子不参与 flex 布局</p>
<p>会导致原来的弹性布局失去效果</p>
<p>常见用法： 导航栏滑动后需要吸附在顶部</p>
<p>解决方案：在原来弹性布局容器的外面再包裹一层容器 给外面的容器添加定位属性</p>
<p>注意：外容器一定要添加 width： 100% 属性</p>
<h3 id="lt-video-gt-视频自动播放"><a href="#lt-video-gt-视频自动播放" class="headerlink" title="&lt;video&gt;视频自动播放"></a><code>&lt;video&gt;</code>视频自动播放</h3><p>autoplay 不生效 需要 muted 标签设置静音</p>
<h3 id="background-attachment移动端场景下失效"><a href="#background-attachment移动端场景下失效" class="headerlink" title="background-attachment移动端场景下失效"></a><code>background-attachment</code>移动端场景下失效</h3><p>用伪元素来解决</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;https://ae01.alicdn.com/kf/H18a4b998752a4ae68b8e85d432a5aef0l.png&#x27;</span>),</span><br><span class="line">    <span class="built_in">linear-gradient</span>(</span><br><span class="line">      <span class="number">60deg</span>,</span><br><span class="line">      rgba(<span class="number">255</span>, <span class="number">165</span>, <span class="number">150</span>, <span class="number">0.5</span>) <span class="number">5%</span>,</span><br><span class="line">      <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">228</span>, <span class="number">255</span>, <span class="number">0.35</span>)</span><br><span class="line">    ),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&#x27;https://ae01.alicdn.com/kf/H21b5f6b8496141a1979a33666e1074d9x.jpg&#x27;</span>)</span><br><span class="line">      no-repeat cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="node-sass-版本问题"><a href="#node-sass-版本问题" class="headerlink" title="node-sass 版本问题"></a>node-sass 版本问题</h3><blockquote>
<p>Node Sass version 5.0.0 is incompatible with^4.0.0</p>
</blockquote>
<p>node-sass 的不同版本对 node 的版本依赖也有不同</p>
<p>可以使用 nvm node 版本工具来切换 node 的版本 这样就不用回退版本 卸载重装了</p>
<p>遇到的问题 使用 nvm install 时 无法安装</p>
<p>可以在环境变量下找到 NVM_HOME 文件所在目录下的 setting.txt</p>
<p>加入两行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">node_mirror:npm.taobao.org/mirrors/node/</span><br><span class="line">npm_mirror:npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure>

<h3 id="使用-overflow：hidden-之后使的同行元素不对齐"><a href="#使用-overflow：hidden-之后使的同行元素不对齐" class="headerlink" title="使用 overflow：hidden 之后使的同行元素不对齐"></a>使用 overflow：hidden 之后使的同行元素不对齐</h3><p>一个父元素（块级元素）中有几个在同一水平线上的几个元素（行内块元素），设置其中某个元素的 oveflow:hidden 之后，会导致这几个行内元素不再是同一水平线上对齐</p>
<p>原因是：</p>
<p>1）行内元素的默认 vertical-align:baseline（基线对齐），设置 overflow 不为 visible 之后会改变他的基线为下边距边缘</p>
<p>2）其他行内元素为了对齐，就会发生向下偏移的现象</p>
<p>解决方案：</p>
<p>方案一）显示设置行内元素对齐方式,em: vertical-align:top</p>
<p>方案二）设置其他元素都为 overflow:hidden</p>
<p>方案三）设置元素 float</p>
]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-FLex</title>
    <url>/FE/CSS/Flex/</url>
    <content><![CDATA[<h1 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h1><p>弹性布局</p>
<a id="more"></a>

<p>父元素设置flex布局后    子元素的浮动会失效</p>
<h2 id="父项属性"><a href="#父项属性" class="headerlink" title="父项属性"></a>父项属性</h2><ul>
<li><h3 id="flex-direction：设置主轴方向"><a href="#flex-direction：设置主轴方向" class="headerlink" title="flex-direction：设置主轴方向"></a>flex-direction：设置主轴方向</h3><ul>
<li><p>row（默认）</p>
</li>
<li><p>column</p>
</li>
<li><p>row-reverse</p>
</li>
<li><p>column-reverse</p>
</li>
</ul>
</li>
<li><h3 id="justify-content：-设置-！主轴上！-子元素的排列方式"><a href="#justify-content：-设置-！主轴上！-子元素的排列方式" class="headerlink" title="justify-content： 设置    ！主轴上！  子元素的排列方式"></a>justify-content： 设置    ！主轴上！  子元素的排列方式</h3><ul>
<li><p>flex-start（默认）贴着左边对齐</p>
</li>
<li><p>flex-end</p>
</li>
<li><p>center</p>
</li>
<li><p>space-around  平均分配剩余空间</p>
</li>
<li><p>space-between   两边贴边 再剩余分配剩余空间</p>
</li>
</ul>
</li>
<li><h3 id="flex-wrap：设置子元素是否换行"><a href="#flex-wrap：设置子元素是否换行" class="headerlink" title="flex-wrap：设置子元素是否换行"></a>flex-wrap：设置子元素是否换行</h3><ul>
<li><p>nowrap （默认） 不换行 放不下会缩子元素</p>
</li>
<li><p>wrap</p>
</li>
</ul>
</li>
<li><h3 id="align-items：设置-！侧轴上-！-子元素的排列方式（单行）"><a href="#align-items：设置-！侧轴上-！-子元素的排列方式（单行）" class="headerlink" title="align-items：设置 ！侧轴上 ！ 子元素的排列方式（单行）"></a>align-items：设置 ！侧轴上 ！ 子元素的排列方式（单行）</h3><ul>
<li><p>center</p>
</li>
<li><p>flex-start</p>
</li>
<li><p>flex-end</p>
</li>
</ul>
</li>
<li><h3 id="align-content：多行（子项出现换行）"><a href="#align-content：多行（子项出现换行）" class="headerlink" title="align-content：多行（子项出现换行）"></a>align-content：多行（子项出现换行）</h3><ul>
<li><p>center</p>
</li>
<li><p>flex-start</p>
</li>
<li><p>flex-end</p>
</li>
<li><p>space-around  平均分配剩余空间</p>
</li>
<li><p>space-between   两边贴边 再剩余分配剩余空间</p>
</li>
</ul>
</li>
<li><h3 id="flex-flow：简写"><a href="#flex-flow：简写" class="headerlink" title="flex-flow：简写"></a>flex-flow：简写</h3><ul>
<li>flex-flow：row wrap</li>
</ul>
</li>
</ul>
<h2 id="子项属性"><a href="#子项属性" class="headerlink" title="子项属性"></a>子项属性</h2><p>flex：<num>   子元素占的份数</p>
<p>align-self：控制子元素自己在<strong>侧轴</strong>上的排列方式</p>
<p>order：<num>  控制盒子的位置 默认都是0 越小越靠前</p>
<h2 id="flex计算"><a href="#flex计算" class="headerlink" title="flex计算"></a>flex计算</h2><p>TODO</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS Accumulation</title>
    <url>/FE/CSS/Accumulation/</url>
    <content><![CDATA[<h2 id="锚点链接平滑滚动"><a href="#锚点链接平滑滚动" class="headerlink" title="锚点链接平滑滚动"></a>锚点链接平滑滚动</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">&#x27;a&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//根据a标签的href转换为id选择器，获取id元素所处的位置，并高度减50px（这里根据需要自由设置）</span></span><br><span class="line">    $(<span class="string">&#x27;html,body&#x27;</span>).animate(</span><br><span class="line">      &#123; <span class="attr">scrollTop</span>: $($(<span class="built_in">this</span>).attr(<span class="string">&#x27;href&#x27;</span>)).offset().top - <span class="number">50</span> &#125;,</span><br><span class="line">      <span class="number">1000</span></span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="顶部导航栏吸附"><a href="#顶部导航栏吸附" class="headerlink" title="顶部导航栏吸附"></a>顶部导航栏吸附</h2><p>可以用position：sticky</p>
<p>必须给一个top值 确定最终吸附的位置</p>
<p>可以配合背景颜色 或 z-index置顶 来达到效果</p>
<h2 id="美化导航栏样式"><a href="#美化导航栏样式" class="headerlink" title="美化导航栏样式"></a>美化导航栏样式</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">::-webkit-scrollbar</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-track</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f6f6f6</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-thumb</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#aaa</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-thumb</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#747474</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-corner</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f6f6f6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="收藏夹和标题-favicon-ico-制作"><a href="#收藏夹和标题-favicon-ico-制作" class="headerlink" title="收藏夹和标题 favicon.ico 制作"></a>收藏夹和标题 favicon.ico 制作</h2><p><a href=https://tool.lu/favicon>ico 在线制作</a></p>
<p>在 html 中插入语句</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;img/favicon.ico&quot;</span> <span class="attr">type</span>=<span class="string">&quot;imagex-icon&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;img/favicon.ico&quot;</span><span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="链接（文本复制）"><a href="#链接（文本复制）" class="headerlink" title="链接（文本复制）"></a>链接（文本复制）</h2><p>如果是输入框，可以通过 select() 方法，选中输入框的文本，然后调用copy 命令，将文本复制到剪切板</p>
<p>但是 select() 方法只对 <code>&lt;input&gt;</code> 和 <code>&lt;textarea&gt;</code> 有效</p>
<p>所以采用采用其他元素时，可以借助这两个元素，然后将其“隐藏”，隐藏的意思是不可以对浏览器不可见，</p>
<p>如设置为<code>visibility：hidden</code>或<code>display:none</code>等都会失效，可以使用定位将其“隐藏”</p>
<p>原理：</p>
<p><code>[input].select()</code></p>
<p><code>document.execCommand(&quot;copy&quot;)</code></p>
<h2 id="无限滚动的列表"><a href="#无限滚动的列表" class="headerlink" title="无限滚动的列表"></a>无限滚动的列表</h2><p>基本思路</p>
<p>需要两个一模一样的容器 然后用 animation 动画 在第一个容器结束时 第二个容器开始时 的 瞬间</p>
<p>重叠到 动画结束 闪动的瞬间 即可</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> picmove &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">1126px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.menu_box_con</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: picmove <span class="number">18s</span> linear infinite forwards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Node Express &amp;&amp; Koa</title>
    <url>/FE/Node/express-koa/</url>
    <content><![CDATA[<h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>通过 express 我们可以轻松的构建一个 web 服务器 例如以下代码就在 3000 端口创建了一个 web 服务器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>在我的理解中 express 就是一个对一系列中间件调用的函数</p>
<p>比如常见的处理 get 和 post 请求的方法都是中间件的调用</p>
<p>当我们 require express 的时候 本质上是导入了一个函数</p>
<p>可以查看源码 以下是入口文件 express.js 的截取代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span> = <span class="built_in">module</span>.exports = createApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an express application.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Function&#125;</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api <span class="variable">public</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> app = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    app.handle(req, res, next);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  mixin(app, EventEmitter.prototype, <span class="literal">false</span>);</span><br><span class="line">  mixin(app, proto, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// expose the prototype that will get set on requests</span></span><br><span class="line">  app.request = <span class="built_in">Object</span>.create(req, &#123;</span><br><span class="line">    app: &#123; <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">value</span>: app &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// expose the prototype that will get set on responses</span></span><br><span class="line">  app.response = <span class="built_in">Object</span>.create(res, &#123;</span><br><span class="line">    app: &#123; <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">value</span>: app &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  app.init();</span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>express.js 导出了一个函数 createApplication 也就是我们 require 导入的函数</p>
<p>在这个函数中初始化了一个 app 的函数 拥有 req / res / next 等参数 并通过 minin 这个函数混入了很多属性到 app 中</p>
<p>具体的 API 可查阅 <a href="http://expressjs.com/en/4x/api.html">http://expressjs.com/en/4x/api.html</a></p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>传递给 express 的一个回调函数 中间件位于请求和响应之间 所以它可以</p>
<p>• 执行任何代码</p>
<p>• 更改请求和响应对象</p>
<p>• 结束请求响应周期 res.end</p>
<p>• 调用下一个中间件</p>
<p>我们可以使用 app.use 的方法在全局注册中间件 这样所有的路由都会匹配到这个中间件</p>
<p>也可以在具体的路由中使用中间件 例如如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middlewareA = (<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">do</span> something...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(middlewareA)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, middlewareA ,<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">do</span> something...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="托管静态文件"><a href="#托管静态文件" class="headerlink" title="托管静态文件"></a>托管静态文件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过/static 来访问public文件夹</span></span><br><span class="line">app.use(<span class="string">&quot;/static&quot;</span>, express.static(path.join(__dirname, <span class="string">&quot;public&quot;</span>)));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;静态资源服务器部署成功&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>get 请求的参数都在 url 中 我们可以通过 query 和 params 这两种形式来获取</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/query&quot;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.json(req.query);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/param/:id&quot;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.json(req.params);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><p>post 请求的参数在 body 但是如果我们直接打印 body 是看不到任何结果的</p>
<p>这是需要引入 body-parser 这个库</p>
<p>这个库和不同版本的 express 集成情况如下</p>
<ul>
<li><p>3.x 内置</p>
</li>
<li><p>4.x 分离</p>
</li>
<li><p>4.16 内置函数</p>
</li>
</ul>
<p>所以如果是 4.x 4.16 以前的版本 我们需要手动安装这个第三方库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老版本写法 不推荐</span></span><br><span class="line"><span class="comment">// var bodyParser = require(&quot;body-parser&quot;);</span></span><br><span class="line"><span class="comment">// app.use(bodyParser.urlencoded(&#123; extended: false &#125;));</span></span><br><span class="line"><span class="comment">// app.use(bodyParser.json());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.16以后的写法 推荐</span></span><br><span class="line"><span class="comment">// extended false 表示使用node的内置模块querystring来解析</span></span><br><span class="line"><span class="comment">// true 则表示使用第三方模块qs来解析</span></span><br><span class="line">app.use(express.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">app.use(express.json());</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">&quot;/login&quot;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.body);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>如果使用原生的方法实现文件上传 后台处理起来会非常麻烦 因为二进制流中不仅有文件的信息 还有 header 的一些相关信息 我们可以打印一些相关的数据来看一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">&quot;/upload&quot;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.headers);</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  req.on(<span class="string">&quot;data&quot;</span>, <span class="function">(<span class="params">buffer</span>) =&gt;</span> &#123;</span><br><span class="line">    data += buffer;</span><br><span class="line">  &#125;);</span><br><span class="line">  req.on(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;start~~~&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后我们访问 localhost:8080/upload 并上传一个文件 就可以看到打印台输出了一段乱码的二进制流和请求头的 headers</p>
<p>headers 信息如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;user-agent&quot;</span>: <span class="string">&quot;PostmanRuntime/7.13.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;accept&quot;</span>: <span class="string">&quot;*/*&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;cache-control&quot;</span>: <span class="string">&quot;no-cache&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;postman-token&quot;</span>: <span class="string">&quot;e48f538d-2988-4e39-8d50-80fdede0ed02&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;localhost:8080&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;accept-encoding&quot;</span>: <span class="string">&quot;gzip, deflate&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;content-type&quot;</span>: <span class="string">&quot;multipart/form-data; boundary=--------------------------372446874075094600561084&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;content-length&quot;</span>: <span class="string">&quot;376074&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;connection&quot;</span>: <span class="string">&quot;keep-alive&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果仔细对比 你就会发现二进制流中包含了 header 中的 content-type 中的 boundary 还有文件的 mime 类型等 如果不加处理的直接使用 fs 模块将这个二进制流写入到文件中 那么最终文件肯定无法被正确解析</p>
<p>如果引入 multer 模块 那么文件上传功能就会变得很简单了</p>
<p>例如 我们需要用户上传头像 代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> multer = <span class="built_in">require</span>(<span class="string">&quot;multer&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage = multer.diskStorage(&#123;</span><br><span class="line">  destination: <span class="function"><span class="keyword">function</span> (<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  第一个参数为err的相关信息 node的回调函数都是错误优先的回调</span></span><br><span class="line">    <span class="comment">//  第二个参数为文件上传的目的地</span></span><br><span class="line">    cb(<span class="literal">null</span>, <span class="string">&quot;uploads&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  filename: <span class="function"><span class="keyword">function</span> (<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 同样的 第一个参数为错误信息 第二个参数为文件名</span></span><br><span class="line">    cb(</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      file.fieldname + <span class="string">&quot;-&quot;</span> + <span class="built_in">Date</span>.now() + path.extname(file.originalname)</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> upload = multer(&#123; <span class="attr">storage</span>: storage &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">&quot;/upload&quot;</span>, upload.single(<span class="string">&quot;avatar&quot;</span>), <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.file);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;start~~~&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述方法演示的是单文件上传 req.file 中存储了文件的相关信息 如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;fieldname&quot;</span>: <span class="string">&quot;avatar&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;originalname&quot;</span>: <span class="string">&quot;CHOU16.jpg&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;encoding&quot;</span>: <span class="string">&quot;7bit&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;mimetype&quot;</span>: <span class="string">&quot;image/jpeg&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;destination&quot;</span>: <span class="string">&quot;uploads&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;avatar-1616384964609.jpg&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;uploads\\avatar-1616384964609.jpg&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">375864</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要支持多文件上传 例如还需要上传用户背景图 代码可改写成如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.post(</span><br><span class="line">  <span class="string">&quot;/fields&quot;</span>,</span><br><span class="line">  upload.fields([</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;avatar&quot;</span>, <span class="attr">macCount</span>: <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;bg&quot;</span>, <span class="attr">maxCount</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  ]),</span><br><span class="line">  (req, res, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.files);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   avatar: [</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//       fieldname: &#x27;avatar&#x27;,</span></span><br><span class="line"><span class="comment">//       originalname: &#x27;CHOU1.jpg&#x27;,</span></span><br><span class="line"><span class="comment">//       encoding: &#x27;7bit&#x27;,</span></span><br><span class="line"><span class="comment">//       mimetype: &#x27;image/jpeg&#x27;,</span></span><br><span class="line"><span class="comment">//       destination: &#x27;uploads&#x27;,</span></span><br><span class="line"><span class="comment">//       filename: &#x27;CHOU1.jpg&#x27;,</span></span><br><span class="line"><span class="comment">//       path: &#x27;uploads/CHOU1.jpg&#x27;,</span></span><br><span class="line"><span class="comment">//       size: 646567</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   ],</span></span><br><span class="line"><span class="comment">//   bg: [</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//       fieldname: &#x27;bg&#x27;,</span></span><br><span class="line"><span class="comment">//       originalname: &#x27;CHOU2.jpg&#x27;,</span></span><br><span class="line"><span class="comment">//       encoding: &#x27;7bit&#x27;,</span></span><br><span class="line"><span class="comment">//       mimetype: &#x27;image/jpeg&#x27;,</span></span><br><span class="line"><span class="comment">//       destination: &#x27;uploads&#x27;,</span></span><br><span class="line"><span class="comment">//       filename: &#x27;CHOU2.jpg&#x27;,</span></span><br><span class="line"><span class="comment">//       path: &#x27;uploads/CHOU2.jpg&#x27;,</span></span><br><span class="line"><span class="comment">//       size: 398519</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   ]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果是需要多张背景图上传 同一个 field 则可以用 array 的写法 第二个参数为最大可上传的数量</p>
<p>如果超过了最大数量 multer 会返回 MulterError: Unexpected field</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.post(<span class="string">&quot;/array&quot;</span>, upload.array(<span class="string">&quot;bg&quot;</span>, <span class="number">3</span>), <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.files);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//     fieldname: &#x27;bg&#x27;,</span></span><br><span class="line"><span class="comment">//     originalname: &#x27;CHOU1.jpg&#x27;,</span></span><br><span class="line"><span class="comment">//     encoding: &#x27;7bit&#x27;,</span></span><br><span class="line"><span class="comment">//     mimetype: &#x27;image/jpeg&#x27;,</span></span><br><span class="line"><span class="comment">//     destination: &#x27;uploads&#x27;,</span></span><br><span class="line"><span class="comment">//     filename: &#x27;CHOU1.jpg&#x27;,</span></span><br><span class="line"><span class="comment">//     path: &#x27;uploads/CHOU1.jpg&#x27;,</span></span><br><span class="line"><span class="comment">//     size: 646567</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//     fieldname: &#x27;bg&#x27;,</span></span><br><span class="line"><span class="comment">//     originalname: &#x27;CHOU2.jpg&#x27;,</span></span><br><span class="line"><span class="comment">//     encoding: &#x27;7bit&#x27;,</span></span><br><span class="line"><span class="comment">//     mimetype: &#x27;image/jpeg&#x27;,</span></span><br><span class="line"><span class="comment">//     destination: &#x27;uploads&#x27;,</span></span><br><span class="line"><span class="comment">//     filename: &#x27;CHOU2.jpg&#x27;,</span></span><br><span class="line"><span class="comment">//     path: &#x27;uploads/CHOU2.jpg&#x27;,</span></span><br><span class="line"><span class="comment">//     size: 398519</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<h3 id="router"><a href="#router" class="headerlink" title="router"></a>router</h3><p>如果将所有的请求处理都放在 index.js 中处理 那么 index.js 的代码就会变的很臃肿 这个时候我们可以使用路由来拆分我们的代码</p>
<p>例如项目中有一个用户模块 实现增删改查的功能</p>
<p>我们就可以新建一个 user.js 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&quot;/add&quot;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.end(<span class="string">&quot;added&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&quot;/delete&quot;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.end(<span class="string">&quot;deleted&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&quot;/update&quot;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.end(<span class="string">&quot;updated&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&quot;/select&quot;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.end(<span class="string">&quot;selected&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure>

<p>然后在 index.js 中导入这个路由</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&quot;./user&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&quot;/user&quot;</span>, userRouter);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><p>express 中的中间件都是同步代码 即一个中间件执行完毕才会去执行另一个中间件中的代码</p>
<p>例如我们有如下功能要实现 在 ABC 三个中间件中 分别追加给 message 追加内容 然后在 A 中间件中输出结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middlewareA = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  req.message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  req.message += <span class="string">&quot;A&quot;</span>;</span><br><span class="line">  next();</span><br><span class="line">  res.end(req.message);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middlewareB = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  req.message += <span class="string">&quot;B&quot;</span>;</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middlewareC = <span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">  req.message += <span class="string">&quot;C&quot;</span>;</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(middlewareA);</span><br><span class="line">app.use(middlewareB);</span><br><span class="line">app.use(middlewareC);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">8000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>next 函数会在中间件栈中找到下一个中间件并执行 所以 middlewareA 中的 res.end 会在所有中间件都执行完毕后才执行 输入 ABC</p>
<p>那么 如果我们在第三个中间件中用定时器来模拟异步操作 最终的结果会怎么样呢</p>
<p>将 middlewareC 改造成如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middlewareC = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    req.message += <span class="string">&quot;C&quot;</span>;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过访问 8000 端口 我们可以看到这次最终的输出变成了 AB 由此可见</p>
<p><strong>中间件中的代码都是同步调用的</strong></p>
<p>而这 也是 express 面对异步场景下的一种无力 而 koa 则不一样</p>
<h2 id="Koa"><a href="#Koa" class="headerlink" title="Koa"></a>Koa</h2><p>koa 支持 async 和 await 的用法 这就意味着在 koa 中可以抛去 express 中回调函数的写法 用一种更优雅的方式来解决异步场景</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>与 express 不同的是 koa 导出的不是函数 而是一个名为 Application 的对象</p>
<p>所以在使用上我们只需要 new 一个实例即可 其他用法和 Express 基本相似</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Koa&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>这里我们借助第三方模块 koa-router 因为 koa 本身很纯净 基本所有功能都要通过第三方插件来实现</p>
<p>新建一个 user.js 的路由模块 Koa 将 express 中的 request 和 response 都合成到了上下文对象 context 中 简写为 ctx</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&quot;koa-router&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="keyword">new</span> Router(&#123; <span class="attr">prefix</span>: <span class="string">&quot;/user&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">userRouter.get(<span class="string">&quot;/home&quot;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.body = <span class="string">&quot;welcome~~&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">userRouter.post(<span class="string">&quot;/login&quot;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.body = <span class="string">&quot;login&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = userRouter;</span><br></pre></td></tr></table></figure>

<p>然后在 index 中引入 user.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&quot;./router&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(userRouter.routes());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Koa&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h3><p>koa 中需要引入 koa-bodyparser 来解析 json 和 urlencoded</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&quot;koa-router&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&quot;koa-bodyparser&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">app.use(bodyParser());</span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析query</span></span><br><span class="line">router.get(<span class="string">&quot;/query&quot;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ctx.request.query);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析params</span></span><br><span class="line">router.get(<span class="string">&quot;/params/:id&quot;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ctx.request.params);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析urlencoded</span></span><br><span class="line">router.post(<span class="string">&quot;/urlencoded&quot;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ctx.request.body);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析json</span></span><br><span class="line">router.post(<span class="string">&quot;/json&quot;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ctx.request.body);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意 koa-bodyparser 中间件需要最先被使用</p>
<h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>重新回到 express 中的 demo 如果想在 koa 中处理异步操作就变的非常简单了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&quot;axios&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middlewareA = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  ctx.msg += <span class="string">&quot;A&quot;</span>;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  ctx.body = ctx.msg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middlewareB = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.msg += <span class="string">&quot;B&quot;</span>;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middlewareC = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> axios.get(<span class="string">&quot;https://koa.bootcss.com/&quot;</span>);</span><br><span class="line">  ctx.msg += res.data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(middlewareA);</span><br><span class="line">app.use(middlewareB);</span><br><span class="line">app.use(middlewareC);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Koa&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="洋葱模型"><a href="#洋葱模型" class="headerlink" title="洋葱模型"></a>洋葱模型</h3><p>洋葱模型其实不是什么高大尚的概念 通过下图我们不难发现</p>
<p>所有中间件都会被 request 访问两次 就像剥洋葱一样 这就是洋葱模型</p>
<img src="https://gitee.com/LuckyChou/blog-images/raw/master/node/middleware.png" />

<h2 id="express-对比-koa"><a href="#express-对比-koa" class="headerlink" title="express 对比 koa"></a>express 对比 koa</h2><ul>
<li><p>express 是完整和强大的，其中帮助我们内置了非常多好用的功能;</p>
</li>
<li><p>koa 是简洁和自由的，它只包含最核心的功能，并不会对我们使用其他中间件进行任何的限制。 甚至是在 app 中连最基本的 get、post 都没有给我们提供;我们需要通过自己或者路由来判断请求方式或者其他功能</p>
</li>
<li><p>koa 中间件支持 async await</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-顺序表</title>
    <url>/Data-Structure/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li><p>创建顺序表</p>
</li>
<li><p>初始化</p>
</li>
<li><p>添加元素</p>
</li>
<li><p>删除元素</p>
</li>
<li><p>按位查找</p>
</li>
<li><p>按值查找</p>
</li>
<li><p>销毁顺序表</p>
</li>
</ul>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10<span class="comment">//定义最大的长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;<span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize];<span class="comment">//初始化一个静态数组来存放元素</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//记录顺序表的长度</span></span><br><span class="line">&#125; SqList;<span class="comment">//将顺序表结构重命名为SqList</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxSize; ++i) &#123;</span><br><span class="line">        L.data[i] = <span class="number">0</span>;<span class="comment">//将所有元素赋值为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.length = <span class="number">0</span>;<span class="comment">//将顺序表的初始长度设置为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加元素 在位序的i的地方插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数据合理性判断</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span> || L.length &gt; MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt; i - <span class="number">1</span>; j--) &#123;</span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;<span class="comment">//将位序为i处放入e</span></span><br><span class="line">    L.length++;<span class="comment">//顺序表长度加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素 删除位序为i的元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; L.length + <span class="number">1</span> || i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];<span class="comment">//返回被删除的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L.length; j++) &#123;</span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按位查找</span></span><br><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LocateElem</span><span class="params">(SqList &amp;L, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == e)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; ++i) &#123;</span><br><span class="line">        L.data[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, L.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    initList(L);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        ListInsert(L, i, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Date Structure</category>
      </categories>
      <tags>
        <tag>Date Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Node 模块化</title>
    <url>/FE/Node/modularization/</url>
    <content><![CDATA[<p>node模块化采用commonjs的方式 即 require / module.export 的形式</p>
<h2 id="module-export-export-？"><a href="#module-export-export-？" class="headerlink" title="module.export === export ？"></a>module.export === export ？</h2><p>我们直接输出 module.exports === exports</p>
<p>会发现两者是相等的 所以exports实际上是module.exports的引用</p>
<p>而require引用的永远是module.exports</p>
<p>也就是说对于exports只能使用exports.xxx = xxx 的形式赋值</p>
<p>因为一旦修改了exports的指向 那么它最终将不会被require引用</p>
<p>而module.exports既可以使用module.exports.xxx = xxx</p>
<p>也可以使用module.exports = xxx</p>
<a id="more"></a>

<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>TODO</p>
<h2 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h2><h3 id="有后缀名"><a href="#有后缀名" class="headerlink" title="有后缀名"></a>有后缀名</h3><h3 id="无后缀名"><a href="#无后缀名" class="headerlink" title="无后缀名"></a>无后缀名</h3><p>按如下循序查找</p>
<ul>
<li><p>把x当作文件</p>
<ul>
<li><p>x</p>
</li>
<li><p>x.js</p>
</li>
<li><p>x.json</p>
</li>
<li><p>x.node</p>
</li>
</ul>
</li>
<li><p>把x当作文件夹</p>
<ul>
<li><p>x/index.js</p>
</li>
<li><p>x/index.json</p>
</li>
<li><p>x/index.node</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>应知应会 CSS</title>
    <url>/FE/Interview/CSS/</url>
    <content><![CDATA[<h2 id="1-display-none-与-visibility-hidden-的区别"><a href="#1-display-none-与-visibility-hidden-的区别" class="headerlink" title="1.display: none;与 visibility: hidden;的区别"></a>1.display: none;与 visibility: hidden;的区别</h2><ul>
<li><p>联系：它们都能让元素不可见</p>
</li>
<li><p>区别：</p>
<ul>
<li><p>display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；</p>
</li>
<li><p>visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见</p>
</li>
<li><p>display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；</p>
</li>
<li><p>visibility: hidden;是继承属性，子孙节点消失由于继承了 hidden，通过设置 visibility: visible;可以让子孙节点显式</p>
</li>
<li><p>修改常规流中元素的 display 通常会造成文档重排。修改 visibility 属性只会造成本元素的重绘。</p>
</li>
<li><p>读屏器不会读取 display: none;元素内容；会读取 visibility: hidden;元素内容</p>
</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="2-BFC"><a href="#2-BFC" class="headerlink" title="2.BFC"></a>2.BFC</h2><p>块格式化上下文（Block Formatting Context，BFC）是 Web 页面的可视化 CSS 渲染的一部分，</p>
<p>是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p>
<p>通俗来讲</p>
<ul>
<li><p>BFC 是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。</p>
</li>
<li><p>如果一个元素符合触发 BFC 的条件，则 BFC 中的元素布局不受外部影响。</p>
</li>
</ul>
<p>创建 BFC</p>
<p>（1）根元素或包含根元素的元素</p>
<p>（2）浮动元素 float ＝ left|right 或 inherit（≠none）</p>
<p>（3）绝对定位元素 position ＝ absolute 或 fixed</p>
<p>（4）display ＝ inline-block|flex|inline-flex|table-cell 或 table-caption</p>
<p>（5）overflow ＝ hidden|auto 或 scroll(≠visible)</p>
<p>BFC 指的是块级格式化上下文，一个元素形成了 BFC 之后，那么它内部元素产生的布局不会影响到外部元素，</p>
<p>外部元素的布局也不会影响到 BFC 中的内部元素。一个 BFC 就像是一个隔离区域，和其他区域互不影响。</p>
<p>一般来说根元素是一个 BFC 区域，浮动和绝对定位的元素也会形成 BFC，display 属性的值为 inline-block、flex</p>
<p>这些属性时也会创建 BFC。还有就是元素的 overflow 的值不为 visible 时都会创建 BFC。</p>
<h3 id="3-BFC-布局与普通文档流布局的区别"><a href="#3-BFC-布局与普通文档流布局的区别" class="headerlink" title="3.BFC 布局与普通文档流布局的区别"></a>3.BFC 布局与普通文档流布局的区别</h3><p>普通文档流布局</p>
<ul>
<li><p>浮动的元素是不会被父元素计算高度</p>
</li>
<li><p>相邻两个元素的 margin 会重叠</p>
</li>
<li><p>margin 会传递给父元素</p>
</li>
<li><p>非浮动元素会覆盖浮动元素的位置</p>
</li>
</ul>
<h3 id="4-清除浮动"><a href="#4-清除浮动" class="headerlink" title="4.清除浮动"></a>4.清除浮动</h3><p>比较好的方法有</p>
<ul>
<li>给父级元素添加 class</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearFix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>; <span class="comment">/*设置内容为空*/</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>; <span class="comment">/*高度为0*/</span></span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">0</span>; <span class="comment">/*行高为0*/</span></span><br><span class="line">  <span class="attribute">display</span>: block; <span class="comment">/*将文本转为块级元素*/</span></span><br><span class="line">  <span class="attribute">visibility</span>: hidden; <span class="comment">/*将元素隐藏*/</span></span><br><span class="line">  <span class="attribute">clear</span>: both; <span class="comment">/*清除浮动*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearFix</span> &#123;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>; <span class="comment">/*为了兼容IE*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>父级元素设置 overflow:hidden;触发 BFC</p>
</li>
<li><p>父元素内结尾处添加 div 标签并设置 class 为 clear:both</p>
</li>
</ul>
<h3 id="5-CSS-权重"><a href="#5-CSS-权重" class="headerlink" title="5.CSS 权重"></a>5.CSS 权重</h3><p>!important &gt; 内联式 &gt; id &gt; class &gt; tag</p>
<h3 id="6-display-inline-block"><a href="#6-display-inline-block" class="headerlink" title="6.display:inline-block"></a>6.display:inline-block</h3><p>多个元素设置为 inline-block 显示在一行时 元素之间会有间隙</p>
<p>解决</p>
<ul>
<li><p>去掉所有的换行和空格</p>
</li>
<li><p>使用 margin 为负值</p>
</li>
</ul>
<h2 id="7-postcss-的使用"><a href="#7-postcss-的使用" class="headerlink" title="7.postcss 的使用"></a>7.postcss 的使用</h2><ul>
<li><p>PostCSS 提供了一个解析器，它能够将 CSS 解析成抽象语法树</p>
</li>
<li><p>通过在 PostCSS 这个平台上，我们能够开发一些插件，来处理我们的 CSS，比如热门的：autoprefixer</p>
</li>
</ul>
<h2 id="8-base64-的使用"><a href="#8-base64-的使用" class="headerlink" title="8.base64 的使用"></a>8.base64 的使用</h2><ul>
<li><p>用于减少 HTTP 请求</p>
</li>
<li><p>适用于小图片</p>
</li>
<li><p>base64 的体积约为原图的 4/3</p>
</li>
</ul>
<h2 id="9-外边距重叠"><a href="#9-外边距重叠" class="headerlink" title="9.外边距重叠"></a>9.外边距重叠</h2><ul>
<li><p>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</p>
</li>
<li><p>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</p>
</li>
<li><p>两个外边距一正一负时，折叠结果是两者的相加的和。</p>
</li>
</ul>
<h2 id="10-IFB"><a href="#10-IFB" class="headerlink" title="10.IFB"></a>10.IFB</h2><p>IFC 指的是行级格式化上下文，它有这样的一些布局规则：</p>
<p>（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。</p>
<p>（2）当一行不够的时候会自动切换到下一行。</p>
<p>（3）行级上下文的高度由内部最高的内联盒子的高度决定。</p>
<h2 id="11-媒体查询"><a href="#11-媒体查询" class="headerlink" title="11.媒体查询"></a>11.媒体查询</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">width:</span> <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-如何实现单行／多行文本溢出的省略（…）"><a href="#12-如何实现单行／多行文本溢出的省略（…）" class="headerlink" title="12.如何实现单行／多行文本溢出的省略（…）"></a>12.如何实现单行／多行文本溢出的省略（…）</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*单行文本溢出*/</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-CSS-中哪些属性可以继承"><a href="#13-CSS-中哪些属性可以继承" class="headerlink" title="13.CSS 中哪些属性可以继承"></a>13.CSS 中哪些属性可以继承</h2><p>每个 CSS 属性定义的概述都指出了这个属性是默认继承的，还是默认不继承的。这决定了当你没有为元素的属性指定值时该如何计算值。</p>
<p>当元素的一个继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值（这里的意思应 该是在该属性本身的定义中的默认值）。</p>
<p>当元素的一个非继承属性（在 Mozilla code 里有时称之为 reset property）没有指定值时，则取属性的初始值 initial v alue（该值在该属性的概述里被指定）。</p>
<p>有继承性的属性：</p>
<p>（1）字体系列属性 font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust</p>
<p>（2）文本系列属性 text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、 text-transform、direction、color</p>
<p>（3）表格布局属性 caption-side border-collapse empty-cells</p>
<p>（4）列表属性 list-style-type、list-style-image、list-style-position、list-style</p>
<p>（5）光标属性 cursor</p>
<p>（6）元素可见性 visibility</p>
<p>（7）还有一些不常用的；speak，page，设置嵌套引用的引号类型 quotes 等属性</p>
<p>注意：当一个属性不是继承属性时，可以使用 inherit 关键字指定一个属性应从父元素继承它的值，inherit 关键字用于显式地 指定继承性，可用于任何继承性/非继承性属性。</p>
<p>每一个属性在定义中都给出了这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用父元素的同属性的值 来作为自己的值。</p>
<p>一般具有继承性的属性有，字体相关的属性，font-size 和 font-weight 等。文本相关的属性，color 和 text-align 等。</p>
<p>表格的一些布局属性、列表属性如 list-style 等。还有光标属性 cursor、元素可见性 visibility。</p>
<p>一个属性不是继承属性的时候，我们也可以通过将它的值设置为 inherit 来使它从父元素那获取同名的属性值来继承。</p>
<h2 id="14-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用"><a href="#14-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用" class="headerlink" title="14.::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用"></a>14.::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用</h2><p>单冒号（:）用于 CSS3 伪类，双冒号（::）用于 CSS3 伪元素。（伪元素由双冒号和伪元素名称组成）</p>
<p>双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，</p>
<p>比如:first-line、:first-letter、:before、:after 等，而新的在 CSS3 中引入的伪元素则不允许再支持旧的单冒号的写法。</p>
<p>想让插入的内容出现在其它内容前，使用::before，否者，使用::after；</p>
<p>在代码顺序上，::after 生成的内容也比::before 生成的内容靠后。如果按堆栈视角，::after 生成的内容会在::before 生成的内容之上。</p>
<p>回答：</p>
<p>在 css3 中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号来表示伪元素。</p>
<p>伪类一般匹配的是元素的一些特殊状态，如 hover、link 等，而伪元素一般匹配的特殊的位置，比如 after、before 等。</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试收录</title>
    <url>/FE/Interview/Interview/</url>
    <content><![CDATA[<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型 prototype</p>
<p>给其他对象提供共享属性的方法</p>
<p>构造函数的 prototype 指向原型对象 原型对象的 constructor 指向构造函数</p>
<p>实例对象的<code>__proto__</code>指向原型对象</p>
<p>原型对象的<code>__proto__</code>指向 Object 的原型对象</p>
<p>Object 的原型对象的<code>__proto__</code>指向 null</p>
<p>Object 的 prototype 指向 Object 的原型对象</p>
<p>Object 的原型对象的 constructor 指向 Object</p>
<p>访问一个对象的属性时 就会沿着原型链一层一层往上找</p>
<p>若到 Object.prototype 还未找到 就返回 undefined</p>
<img src="https://gitee.com/LuckyChou/blog-images/raw/master/js/prototypeChain.png" />

<a id="more"></a>

<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>M Model 数据层</p>
<p>V View 视图层</p>
<p>VM View-Model 业务逻辑层</p>
<h2 id="从输入-url-到页面经历了什么"><a href="#从输入-url-到页面经历了什么" class="headerlink" title="从输入 url 到页面经历了什么"></a>从输入 url 到页面经历了什么</h2><ul>
<li><p>DNS 解析 将域名解析成 IP 地址</p>
</li>
<li><p>TCP 连接 三次握手</p>
</li>
<li><p>发送 HTTP 请求</p>
</li>
<li><p>服务器响应 HTTP 请求并返回响应报文</p>
</li>
<li><p>浏览器解析渲染页面</p>
</li>
<li><p>断开连接 TCP 四次挥手</p>
</li>
</ul>
<p>三次握手</p>
<p>浏览器告诉服务器我要发送请求了 请你准备好</p>
<p>服务器响应浏览器 我准备好了 你发送请求吧</p>
<p>浏览器告诉服务器我马上就发送了 准备接受吧</p>
<p>四次挥手</p>
<p>浏览器告诉服务器 我请求报文发送完毕了 你关闭吧</p>
<p>服务器告诉浏览器 我请求报文接受完毕了 我要关闭了</p>
<p>服务器告诉浏览器 我响应报文发送完毕了 你关闭吧</p>
<p>浏览器告诉服务器 我响应报文接受完毕了 我要关闭了</p>
<h2 id="webpack-loader-和-plugin-的区别"><a href="#webpack-loader-和-plugin-的区别" class="headerlink" title="webpack loader 和 plugin 的区别"></a>webpack loader 和 plugin 的区别</h2><ul>
<li><p>Loader 只负责单纯的文件转换</p>
</li>
<li><p>Plugin 丰富了 webpack 的功能 比如压缩代码</p>
</li>
</ul>
<h2 id="style-loader-和-css-loader-的加载顺序"><a href="#style-loader-和-css-loader-的加载顺序" class="headerlink" title="style-loader 和 css-loader 的加载顺序"></a>style-loader 和 css-loader 的加载顺序</h2><p>loader 的加载顺序是从右往左</p>
<p>这里的编译顺序是先用 css-loader 将 css 代码编译</p>
<p>再交给 style-loader 插入到网页里面去</p>
<p>所以 css-loader 在右，style-loader 在左</p>
<h2 id="Promise-的方法"><a href="#Promise-的方法" class="headerlink" title="Promise 的方法"></a>Promise 的方法</h2><ul>
<li><p>Promise.all 全部都成功时</p>
</li>
<li><p>Promise.allSettled 全部都结束时</p>
</li>
<li><p>Promise.any 有一个返回 fulfilled</p>
</li>
<li><p>Promise.race 返回第一个 fulfilled 或 rejected</p>
</li>
<li><p>Promise.reject</p>
</li>
<li><p>Promise.resolve</p>
</li>
</ul>
<h2 id="http-强缓存-协商缓存"><a href="#http-强缓存-协商缓存" class="headerlink" title="http 强缓存 协商缓存"></a>http 强缓存 协商缓存</h2><ul>
<li><p>强缓存 Expires Cache-control</p>
</li>
<li><p>协商缓存 ETag last-modifed</p>
</li>
</ul>
<h3 id="Expires-vs-Cache-Control"><a href="#Expires-vs-Cache-Control" class="headerlink" title="Expires vs Cache-Control"></a>Expires vs Cache-Control</h3><p><strong>Expires</strong></p>
<p>Response header 里的过期时间 浏览器再次加载时 如果在这个时间内 就命中强缓存</p>
<p><strong>Cache-Control</strong></p>
<p>当设置 max-age = 300 表示 在接下来的五分钟内再次请求 就会命中强缓存</p>
<p>Expires 是 Http1.0 的产物 Cache-Control 是 1.1 的产物</p>
<p>两者同时存在的话 后者优先级更高</p>
<p>Expires 是过时的产物 只是为了兼容</p>
<p>对比 Expires Cache-Control 的时间段 控制起来更加容易</p>
<h3 id="ETag-Last-Modified"><a href="#ETag-Last-Modified" class="headerlink" title="ETag Last-Modified"></a>ETag Last-Modified</h3><p><strong>ETag</strong></p>
<p>上一次加载资源时 response header 的一个唯一标识 一旦资源有变化 ETag 就会重新生成</p>
<p>浏览器下一次向服务器发送请求时 会将上一次 response header 的 Etag 放入 request header 的 If-None-Match 中</p>
<p>服务器会进行对比 如果相等 就命中协商缓存</p>
<p><strong>Last-Modified</strong></p>
<p>是该资源文件最后一次修改的时间 会在上一次 response header 中返回</p>
<p>浏览器会在下一次 request header 中 放在 If- Modified-Since 中带上</p>
<p>服务器会进行对比 如果相等 就命中协商缓存</p>
<p>Etag 比后者优先级更高</p>
<p>但是性能比不上后者 因为每次变更 Etag 都要重新生成 但是后者只是记录一个时间</p>
<p>精度上 Etag 也比后者更好</p>
<h2 id="New-内部实现了什么"><a href="#New-内部实现了什么" class="headerlink" title="New 内部实现了什么"></a>New 内部实现了什么</h2><p>在内存中创建一个新的对象</p>
<p>构造函数内部的 this 指向这个对象</p>
<p>将这个对象的 prototype 指向构造函数的 prototype 这样这个对象就拥有构造函数中的方法</p>
<p>执行构造函数中的代码</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件的三个阶段</p>
<p>捕获 -&gt; 目标 -&gt; 冒泡</p>
<p>事件委托就是利用冒泡 将子元素的事件通过事件冒泡在父元素触发事件</p>
<p>可以通过 addEventListener 的第三个参数来决定是捕获还是冒泡</p>
<p>true 事件捕获</p>
<p>false （默认）事件冒泡</p>
<p>阻止冒泡</p>
<p>stopPropagation</p>
<p>IE cancleBubble</p>
<h2 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h2><ul>
<li><p>beforeCreate</p>
</li>
<li><p>created 最早这里有 $data 可以在这里发送网络请求</p>
</li>
<li><p>beforeMount</p>
</li>
<li><p>mounted 最早这里有 $el 可以在这里操作 dom</p>
</li>
<li><p>beforeUpdate</p>
</li>
<li><p>updated</p>
</li>
<li><p>beforeDestroy</p>
</li>
<li><p>destroyed</p>
</li>
</ul>
<p>keep-alive 专属</p>
<ul>
<li><p>activated</p>
</li>
<li><p>deactivated</p>
</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>内部函数引用了外部函数的变量</p>
<p>可以延长外部函数变量的作用域</p>
<h2 id="单向数据流和双向数据流在编码中的体现"><a href="#单向数据流和双向数据流在编码中的体现" class="headerlink" title="单向数据流和双向数据流在编码中的体现"></a>单向数据流和双向数据流在编码中的体现</h2><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>从组件角度来看 数据从组件树由上往下流动 即只从父组件流向子组件</p>
<p>这样的好处是防止子组件意外的修改了父组件的状态</p>
<p>对于 Vuex 这些状态管理工具来说</p>
<p>数据流的流向也是单向的</p>
<p>即组件发送 dispatch/commit -&gt; store -&gt; view</p>
<p>总的来说 单向数据流的好处是使状态变得可记录 可追踪</p>
<h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p>指 view 的改变会改变 modal</p>
<p>Modal 的改变会改变 view</p>
<p>这样的好处是省事方便 省去了很多业务代码</p>
<p>但是一但出错 紊乱的数据流会变得难以追踪和定位</p>
<h2 id="Vue-实现数据双向绑定的原理"><a href="#Vue-实现数据双向绑定的原理" class="headerlink" title="Vue 实现数据双向绑定的原理"></a>Vue 实现数据双向绑定的原理</h2><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>Object.key 可以获取对象的所有属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, attr, &#123;</span><br><span class="line">  value 不能和 set / get 一起使用</span><br><span class="line">  writable 修改 默认 <span class="literal">false</span></span><br><span class="line">  enumerable 枚举 默认 <span class="literal">false</span></span><br><span class="line">  onfigurable 删除 默认 fslse</span><br><span class="line">  set</span><br><span class="line">  get</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hander = &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">obj, prop, value</span>)</span> &#123;</span><br><span class="line">    obj[prop] = value;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;prop&#125;</span>属性的set方法执行了`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">obj, prop</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;prop&#125;</span>属性的get方法执行了`</span>);</span><br><span class="line">    <span class="keyword">return</span> obj[prop];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="实现继承的几种方式"><a href="#实现继承的几种方式" class="headerlink" title="实现继承的几种方式"></a>实现继承的几种方式</h2><details yellow><summary> <p>继承</p> </summary>
              <div class='content'>
              <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="built_in">this</span>.name = name || <span class="string">&#x27;-&gt;father&#x27;</span>;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Father.prototype.age = <span class="number">18</span>;</span><br><span class="line">Father.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;----------原型链继承----------&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name || <span class="string">&#x27;-&gt;son&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Son(<span class="string">&#x27;son&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.name); <span class="comment">// son</span></span><br><span class="line">s.sayAge(); <span class="comment">// 18</span></span><br><span class="line">s.sayName(); <span class="comment">// son</span></span><br><span class="line"><span class="built_in">console</span>.log(s.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Father); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Son); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;----------构造函数继承----------&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.name = name || <span class="string">&#x27;-&gt;son&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Son(<span class="string">&#x27;son&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.name); <span class="comment">// son</span></span><br><span class="line"><span class="comment">//s.sayAge(); // 抛出错误</span></span><br><span class="line">s.sayName(); <span class="comment">// son</span></span><br><span class="line"><span class="built_in">console</span>.log(s.age); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Father); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Son); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;----------实例继承----------&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">new</span> Father();</span><br><span class="line">  f.name = name || <span class="string">&#x27;-&gt;son&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Son(<span class="string">&#x27;son&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.name); <span class="comment">// son</span></span><br><span class="line">s.sayAge(); <span class="comment">// 18</span></span><br><span class="line">s.sayName(); <span class="comment">// son</span></span><br><span class="line"><span class="built_in">console</span>.log(s.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Father); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Son); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;----------组合继承----------&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.name = name || <span class="string">&#x27;-&gt;son&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="comment">// 修复构造函数指向</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Son(<span class="string">&#x27;son&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.name); <span class="comment">// son</span></span><br><span class="line">s.sayAge(); <span class="comment">// 18</span></span><br><span class="line">s.sayName(); <span class="comment">// son</span></span><br><span class="line"><span class="built_in">console</span>.log(s.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Father); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Son); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;----------寄生组合继承----------&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.name = name || <span class="string">&#x27;-&gt;son&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个没有实例方法的类</span></span><br><span class="line">  <span class="keyword">var</span> None = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  None.prototype = Father.prototype;</span><br><span class="line">  <span class="comment">// 将实例作为子类的原型</span></span><br><span class="line">  Son.prototype = <span class="keyword">new</span> None();</span><br><span class="line">  <span class="comment">// 修复构造函数指向</span></span><br><span class="line">  Son.prototype.constructor = Son;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Son(<span class="string">&#x27;son&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.name); <span class="comment">// son</span></span><br><span class="line">s.sayAge(); <span class="comment">// 18</span></span><br><span class="line">s.sayName(); <span class="comment">// son</span></span><br><span class="line"><span class="built_in">console</span>.log(s.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Father); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Son); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h2><h2 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h2><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><ul>
<li><p>constructor()</p>
</li>
<li><p>static getDerivedStateFromProps()</p>
</li>
<li><p>render()</p>
</li>
<li><p>componentDidMount()</p>
</li>
</ul>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><ul>
<li><p>static getDerivedStateFromProps()</p>
</li>
<li><p>shouldComponentUpdate()</p>
</li>
<li><p>render()</p>
</li>
<li><p>getSnapshotBeforeUpdate()</p>
</li>
<li><p>componentDidUpdate()</p>
</li>
</ul>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><ul>
<li>componentWillUnmount()</li>
</ul>
<h2 id="Hook-中怎么模拟类组件的生命周期"><a href="#Hook-中怎么模拟类组件的生命周期" class="headerlink" title="Hook 中怎么模拟类组件的生命周期"></a>Hook 中怎么模拟类组件的生命周期</h2><ul>
<li><p>第一个参数 函数形式 可实现等同于 componentDidMount shouldComponentUpdate componentWillUnmount</p>
</li>
<li><p>并且可以返回一个函数 用来消除副作用 类似 componentWillUnmount 可以做一些事件的解绑 定时器的关闭等</p>
</li>
<li><p>第二个参数 数组 状态依赖项 实现性能优化 如果传[] 则等同于不开启 shouldComponentUpdate</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>应知应会 安全</title>
    <url>/FE/Interview/Security/</url>
    <content><![CDATA[<p><strong>XSS（Cross Site Scripting，跨站脚本攻击）</strong></p>
<ul>
<li><p>这是前端最常见的攻击方式，很多大型网站（如 Facebook）都被 XSS 攻击过。</p>
</li>
<li><p>举一个例子，我在一个博客网站正常发表一篇文章，输入汉字、英文和图片，完全没有问题。</p>
<p>但是如果我写的是恶意的 JS 脚本，例如获取到<code>document.cookie</code>然后传输到自己的服务器上，</p>
<p>那我这篇博客的每一次浏览都会执行这个脚本，都会把访客 cookie 中的信息偷偷传递到我的服务器上来。</p>
</li>
</ul>
<blockquote>
<p>其实原理上就是黑客通过某种方式（发布文章、发布评论等）将一段特定的 JS 代码隐蔽地输入进去。<br>然后别人再看这篇文章或者评论时，之前注入的这段 JS 代码就执行了。<br><strong>JS 代码一旦执行，那可就不受控制了，因为它跟网页原有的 JS 有同样的权限</strong>，<br>例如可以获取 server 端数据、可以获取 cookie 等。于是，攻击就这样发生了。</p>
</blockquote>
<a id="more"></a>

<p><strong>XSS 的危害</strong></p>
<p>XSS 的危害相当大，如果页面可以随意执行别人不安全的 JS 代码，轻则会让页面错乱、功能缺失，重则会造成用户的信息泄露。</p>
<p>比如早些年社交网站经常爆出 XSS 蠕虫，通过发布的文章内插入 JS，</p>
<p>用户访问了感染不安全 JS 注入的文章，会自动重新发布新的文章，</p>
<p>这样的文章会通过推荐系统进入到每个用户的文章列表面前，很快就会造成大规模的感染。</p>
<p>还有利用获取 cookie 的方式，将 cookie 传入入侵者的服务器上，入侵者就可以模拟 cookie 登录网站，对用户的信息进行篡改。</p>
<p><strong>XSS 的预防</strong></p>
<p>那么如何预防 XSS 攻击呢？—— 最根本的方式，就是对用户输入的内容进行验证和替换，需要替换的字符有：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&amp; 替换为：&amp;amp;</span><br><span class="line">&lt; 替换为：&amp;lt;</span><br><span class="line">&gt; 替换为：&amp;gt;</span><br><span class="line">” 替换为：&amp;quot;</span><br><span class="line">‘ 替换为：&amp;#x27;</span><br><span class="line">/ 替换为：&amp;#x2f;</span><br></pre></td></tr></table></figure>

<p>替换了这些字符之后，黑客输入的攻击代码就会失效，XSS 攻击将不会轻易发生。</p>
<p>除此之外，还可以通过对 cookie 进行较强的控制，比如对敏感的 cookie 增加<code>http-only</code>限制，让 JS 获取不到 cookie 的内容。</p>
<p><strong>CSRF（Cross-site request forgery，跨站请求伪造）</strong></p>
<blockquote>
<p>CSRF 是借用了当前操作者的权限来偷偷地完成某个操作，而不是拿到用户的信息。</p>
</blockquote>
<ul>
<li><p>例如，一个支付类网站，给他人转账的接口是<code>http://buy.com/pay?touid=999&amp;money=100</code>，</p>
<p>而这个接口在使用时没有任何密码或者 token 的验证，只要打开访问就直接给他人转账。一个用户已经登录了<code>http://buy.com</code>，</p>
<p>在选择商品时，突然收到一封邮件，而这封邮件正文有这么一行代码<code>&lt;img src=&quot;http://buy.com/pay?touid=999&amp;money=100&quot;/&gt;</code>，</p>
<p>他访问了邮件之后，其实就已经完成了购买。</p>
</li>
<li><p>CSRF 的发生其实是借助了一个 cookie 的特性。</p>
<p>我们知道，登录了<code>http://buy.com</code>之后，cookie 就会有登录过的标记了，</p>
<p>此时请求<code>http://buy.com/pay?touid=999&amp;money=100</code>是会带着 cookie 的，</p>
<p>因此 server 端就知道已经登录了。而如果在<code>http://buy.com</code>去请求其他域名的 API 例如<code>http://abc.com/api</code>时，</p>
<p>是不会带 cookie 的，这是浏览器的同源策略的限制。</p>
<p>但是 —— <strong>此时在其他域名的页面中，请求<code>http://buy.com/pay?touid=999&amp;money=100</code>，会带着<code>buy.com</code>的 cookie ，这是发生 CSRF 攻击的理论基础。</strong></p>
</li>
</ul>
<blockquote>
<p>预防 <code>CSRF</code> 就是加入各个层级的权限验证，例如现在的购物网站，<br>  只要涉及现金交易，肯定要输入密码或者指纹才行。除此之外，敏感的接口使用<code>POST</code>请求而不是<code>GET</code>也是很重要的。</p>
</blockquote>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>应知应会 HTML</title>
    <url>/FE/Interview/HTML/</url>
    <content><![CDATA[<h2 id="1-盒子模型"><a href="#1-盒子模型" class="headerlink" title="1.盒子模型"></a>1.盒子模型</h2><ul>
<li><p>Content box: 这个区域是用来显示内容，大小可以通过设置 width 和 height</p>
</li>
<li><p>Padding box: 包围在内容区域外部的空白区域； 大小通过 padding 相关属性设置</p>
</li>
<li><p>Border box: 边框盒包裹内容和内边距。大小通过 border 相关属性设置</p>
</li>
<li><p>Margin box: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 margin 相关属性设置</p>
</li>
</ul>
<h3 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h3><p>width 和 height 会单独计算 padding</p>
<h3 id="IE-盒模型"><a href="#IE-盒模型" class="headerlink" title="IE 盒模型"></a>IE 盒模型</h3><p>width 和 height 包含了 padding 这看上了很方便</p>
<p>但是浏览器默认使用标准盒模型 可以使用 box-sizing: border-box 来切换至 IE 盒模型</p>
<h2 id="2-SGML-HTML-XML-XHTML"><a href="#2-SGML-HTML-XML-XHTML" class="headerlink" title="2.SGML / HTML / XML / XHTML"></a>2.SGML / HTML / XML / XHTML</h2><ul>
<li><p>SGML 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。</p>
</li>
<li><p>HTML 是超文本标记语言，主要是用于规定怎么显示网页。</p>
</li>
<li><p>XML 是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限。</p>
</li>
<li><p>XHTML 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="3-行内元素"><a href="#3-行内元素" class="headerlink" title="3.行内元素"></a>3.行内元素</h2><ul>
<li><p>b, big, i, small, tt</p>
</li>
<li><p>abbr, acronym, cite, code, dfn, em, kbd, strong, samp, var</p>
</li>
<li><p>a, bdo, br, img, map, object, q, script, span, sub, sup</p>
</li>
<li><p>button, input, label, select, textarea</p>
</li>
</ul>
<h2 id="4-块级元素"><a href="#4-块级元素" class="headerlink" title="4.块级元素"></a>4.块级元素</h2><ul>
<li>div, ul, ol, li, dl, dt, dd, h1, h2, h3, h4, h5, h6, p</li>
</ul>
<h2 id="5-行内-块级-区别"><a href="#5-行内-块级-区别" class="headerlink" title="5.行内 / 块级 区别"></a>5.行内 / 块级 区别</h2><ul>
<li><p>格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。</p>
</li>
<li><p>内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。</p>
</li>
<li><p>行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效（可以设置 line-height），设置 margin 和 padding 的上下不会对其他元素产生影响。</p>
</li>
</ul>
<h2 id="6-页面导入样式时，使用-link-和-import-有什么区别"><a href="#6-页面导入样式时，使用-link-和-import-有什么区别" class="headerlink" title="6.页面导入样式时，使用 link 和 @import 有什么区别"></a>6.页面导入样式时，使用 link 和 @import 有什么区别</h2><ul>
<li><p>从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；link 是 HTML 提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。</p>
</li>
<li><p>加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。</p>
</li>
<li><p>兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容性问题。</p>
</li>
<li><p>DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用 @import 的方式插入样式。</p>
</li>
</ul>
<h2 id="7-浏览器渲染原理"><a href="#7-浏览器渲染原理" class="headerlink" title="7.浏览器渲染原理"></a>7.浏览器渲染原理</h2><p>（1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</p>
<p>（2）然后对 CSS 进行解析，生成 CSSOM 规则树。</p>
<p>（3）根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</p>
<p>（4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</p>
<p>（5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</p>
<p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<h2 id="8-渲染过程中遇到-JS-文件怎么处理？（浏览器解析过程）"><a href="#8-渲染过程中遇到-JS-文件怎么处理？（浏览器解析过程）" class="headerlink" title="8.渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）"></a>8.渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）</h2><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。</p>
<p>也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p>
<h2 id="9-script-标签的-defer-和-async-属性"><a href="#9-script-标签的-defer-和-async-属性" class="headerlink" title="9.script 标签的 defer 和 async 属性"></a>9.script 标签的 defer 和 async 属性</h2><p>（1）脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</p>
<p>（2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。</p>
<p>（3）async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。</p>
<h2 id="10-什么是文档的预解析？（浏览器解析过程）"><a href="#10-什么是文档的预解析？（浏览器解析过程）" class="headerlink" title="10.什么是文档的预解析？（浏览器解析过程）"></a>10.什么是文档的预解析？（浏览器解析过程）</h2><p>Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p>
<h2 id="11-CSS-如何阻塞文档解析？（浏览器解析过程）"><a href="#11-CSS-如何阻塞文档解析？（浏览器解析过程）" class="headerlink" title="11.CSS 如何阻塞文档解析？（浏览器解析过程）"></a>11.CSS 如何阻塞文档解析？（浏览器解析过程）</h2><p>如果未完成 CSS 的下载或者 CSS 树构建，考虑到 JS 可能会请求样式信息，浏览器会在 CSS 下载完并且构建完 CSS 树后处理 JS</p>
<h2 id="12-什么是重绘和回流？（浏览器绘制过程）"><a href="#12-什么是重绘和回流？（浏览器绘制过程）" class="headerlink" title="12.什么是重绘和回流？（浏览器绘制过程）"></a>12.什么是重绘和回流？（浏览器绘制过程）</h2><ul>
<li><p>不影响布局的只引发重绘</p>
</li>
<li><p>影响布局的会引发回流并重绘</p>
</li>
</ul>
<h2 id="13-HTML-语义化的理解"><a href="#13-HTML-语义化的理解" class="headerlink" title="13.HTML 语义化的理解"></a>13.HTML 语义化的理解</h2><p>（1） 用正确的标签做正确的事情。</p>
<p>（2） html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</p>
<p>（3） 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;</p>
<p>（4） 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;</p>
<p>（5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p>
<h2 id="14-前端需要注意哪些-SEO"><a href="#14-前端需要注意哪些-SEO" class="headerlink" title="14.前端需要注意哪些 SEO"></a>14.前端需要注意哪些 SEO</h2><p>（1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可。</p>
<p>（2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。</p>
<p>（3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取。</p>
<p>（4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容</p>
<p>（5）少用 iframe：搜索引擎不会抓取 iframe 中的内容</p>
<p>（6）非装饰性图片必须加 alt</p>
<p>（7）提高网站速度：网站速度是搜索引擎排序的一个重要指标</p>
<h2 id="15-cookies，sessionStorage-和-localStorage-的区别"><a href="#15-cookies，sessionStorage-和-localStorage-的区别" class="headerlink" title="15.cookies，sessionStorage 和 localStorage 的区别"></a>15.cookies，sessionStorage 和 localStorage 的区别</h2><p>SessionStorage， LocalStorage， Cookie 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。</p>
<p>区别在于前两者属于 HTML5 WebStorage，创建它们的目的便于客户端存储数据。而 cookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）。cookie 数据始终在同源（协议、主机、端口相同）的 http 请求中携带（即使不需要），会在浏览器和服务器间来回传递。</p>
<p>存储大小：<br>cookie 数据大小不能超过 4 k 。</p>
<p>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</p>
<p>有期时间：<br>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。</p>
<p>sessionStorage 数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。</p>
<p>cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</p>
<p>作用域：<br>sessionStorage 只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。</p>
<p>localStorage 在所有同源窗口中都是共享的。</p>
<p>cookie 在所有同源窗口中都是共享的。</p>
<p>回答：<br>浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。</p>
<p>cookie 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</p>
<p>sessionStorage 是 html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。</p>
<p>localStorage 也是 html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</p>
<p>上面几种方式都是存储少量数据的时候的存储方式，当我们需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>应知应会 JS</title>
    <url>/FE/Interview/JS/</url>
    <content><![CDATA[<h2 id="1-异步"><a href="#1-异步" class="headerlink" title="1.异步"></a>1.异步</h2><p>JS语言是单线程的</p>
<p>JS 需要异步的根本原因是 JS 是单线程运行的，即在同一时间只能做一件事，不能“一心二用”。</p>
<blockquote>
<p>一个 Ajax 请求由于网络比较慢，请求需要 5 秒钟。<br>如果是同步，这 5 秒钟页面就卡死在这里啥也干不了了。<br>异步的话，就好很多了，5 秒等待就等待了，其他事情不耽误做，至于那 5 秒钟等待是网速太慢，不是因为 JS 的原因。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a = <span class="literal">false</span>;</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"><span class="function"><span class="title">while</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;while执行了&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的执行结果不是100ms后a为false 所以打断while循环</p>
<p>事实上 当程序进入while循环后  就一直是死循环了</p>
<p>因为JS是单线程语言  所以无法执行到定时器</p>
<a id="more"></a>

<h2 id="2-Set-amp-amp-Map"><a href="#2-Set-amp-amp-Map" class="headerlink" title="2.Set &amp;&amp; Map"></a>2.Set &amp;&amp; Map</h2><p>Set和Map 实例都不允许元素有重复</p>
<p>Set的key和value一样 类似于数组</p>
<p>Map的key和value可以设置 类似于对象</p>
<p>Set 实例的属性和方法有</p>
<ul>
<li><p>size：获取元素数量。</p>
</li>
<li><p>add(value)：添加元素，返回 Set 实例本身。</p>
</li>
<li><p>delete(value)：删除元素，返回一个布尔值，表示删除是否成功。</p>
</li>
<li><p>has(value)：返回一个布尔值，表示该值是否是 Set 实例的元素。</p>
</li>
<li><p>clear()：清除所有元素，没有返回值。</p>
</li>
</ul>
<p>Set 实例的遍历，可使用如下方法</p>
<ul>
<li><p>keys()：返回键名的遍历器。</p>
</li>
<li><p>values()：返回键值的遍历器。不过由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），</p>
<p>所以keys()和values()返回结果一致。</p>
</li>
<li><p>entries()：返回键值对的遍历器。</p>
</li>
<li><p>forEach()：使用回调函数遍历每个成员。</p>
</li>
</ul>
<p>Map 实例的属性和方法如下：</p>
<ul>
<li><p>size：获取成员的数量</p>
</li>
<li><p>set：设置成员 key 和 value</p>
</li>
<li><p>get：获取成员属性值</p>
</li>
<li><p>has：判断成员是否存在</p>
</li>
<li><p>delete：删除成员</p>
</li>
<li><p>clear：清空所有</p>
</li>
</ul>
<p>Map 实例的遍历方法有：</p>
<ul>
<li><p>keys()：返回键名的遍历器。</p>
</li>
<li><p>values()：返回键值的遍历器。</p>
</li>
<li><p>entries()：返回所有成员的遍历器。</p>
</li>
<li><p>forEach()：遍历 Map 的所有成员。</p>
</li>
</ul>
<h2 id="3-XMLHttpRequest"><a href="#3-XMLHttpRequest" class="headerlink" title="3.XMLHttpRequest"></a>3.XMLHttpRequest</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.onreadystatechange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">            alert(xhr.responseText)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">xhr.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<p>xhr.readyState的状态码说明：</p>
<ul>
<li><p>0 代理被创建，但尚未调用 open() 方法。</p>
</li>
<li><p>1 open() 方法已经被调用。</p>
</li>
<li><p>2 send() 方法已经被调用，并且头部和状态已经可获得。</p>
</li>
<li><p>3 下载中， responseText 属性已经包含部分数据。</p>
</li>
<li><p>4 下载操作已完成</p>
</li>
</ul>
<p>xhr.status 即 HTTP 状态码，有 2xx 3xx 4xx 5xx 这几种，比较常用的有以下几种：</p>
<ul>
<li><p>200 正常</p>
</li>
<li><p>3xx</p>
<ul>
<li><p>301 永久重定向</p>
</li>
<li><p>302 临时重定向。临时的，不是永久的</p>
</li>
<li><p>304 资源找到但是不符合请求条件，不会返回任何主体。</p>
<p>如发送 GET 请求时，head 中有If-Modified-Since: xxx（要求返回更新时间是xxx时间之后的资源），</p>
<p>如果此时服务器 端资源未更新，则会返回304，即不符合要求</p>
</li>
</ul>
</li>
<li><p>404 找不到资源</p>
</li>
<li><p>5xx 服务器端出错了</p>
</li>
</ul>
<h2 id="4-Fetch"><a href="#4-Fetch" class="headerlink" title="4.Fetch"></a>4.Fetch</h2><p>更简洁的ajax 并且支持Promise的回调</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拿到一个本地json文件的内容</span></span><br><span class="line">fetch(<span class="string">&#x27;./demo.json&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5.闭包"></a>5.闭包</h2><p>函数A中有函数B</p>
<p>函数B中使用了函数A的变量</p>
<p>函数B就被称为闭包</p>
<h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h2><p>承接以上闭包的问题</p>
<p>用定时器的第三个问题可以解决一个老生常谈的问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(</span><br><span class="line">    (j) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">100</span>,</span><br><span class="line">    i</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 0 - 9</span></span><br></pre></td></tr></table></figure>

<h2 id="6-深拷贝"><a href="#6-深拷贝" class="headerlink" title="6.深拷贝"></a>6.深拷贝</h2><p>JSON.parse(JSON.stringify(obj))</p>
<ul>
<li><p>会忽略undefined</p>
</li>
<li><p>不能序列化函数</p>
</li>
<li><p>不能解决循环引用的对象</p>
</li>
</ul>
<p>Object.assign({}, obj)</p>
<ul>
<li>浅拷贝 只完成了属性的深拷贝</li>
</ul>
<h2 id="7-防抖-amp-amp-节流"><a href="#7-防抖-amp-amp-节流" class="headerlink" title="7.防抖 &amp;&amp; 节流"></a>7.防抖 &amp;&amp; 节流</h2><h2 id="8-call-amp-amp-apply-amp-amp-bind"><a href="#8-call-amp-amp-apply-amp-amp-bind" class="headerlink" title="8.call &amp;&amp; apply &amp;&amp; bind"></a>8.call &amp;&amp; apply &amp;&amp; bind</h2><ul>
<li><p>bind 返回一个改变this的函数 强绑定  无法再修改内部this的指向</p>
</li>
<li><p>apply 立即执行该函数  接受一个参数数组</p>
</li>
<li><p>call  立即执行该函数  接受一个参数列表</p>
</li>
</ul>
<h2 id="10-事件的三个阶段"><a href="#10-事件的三个阶段" class="headerlink" title="10.事件的三个阶段"></a>10.事件的三个阶段</h2><p>捕获 - 目标 - 冒泡</p>
<p>可以用addEventListener的第三个参数来决定是捕获还是冒泡</p>
<p>默认是false 冒泡  改为true 则为捕获</p>
<p>事件代理</p>
<p>思路： </p>
<p>如果是动态生成的元素 可以考虑在父元素上绑定事件 </p>
<p>利用事件冒泡  在父元素处触发事件</p>
<h2 id="11-跨域"><a href="#11-跨域" class="headerlink" title="11.跨域"></a>11.跨域</h2><p>JSONP</p>
<ul>
<li><p>利用script标签不受跨域限制</p>
</li>
<li><p>仅限于get请求</p>
</li>
</ul>
<p>document.domain</p>
<ul>
<li><p>适用于二级域名相同的情况</p>
<p>如  a.chou.com &amp;&amp; b.chou.com</p>
</li>
</ul>
<h2 id="12-Event-Loop"><a href="#12-Event-Loop" class="headerlink" title="12.Event Loop"></a>12.Event Loop</h2><p>执行顺序：</p>
<p>同步 &gt; 微任务 &gt; 宏任务</p>
<p>微任务</p>
<ul>
<li><p>process.nextTick</p>
</li>
<li><p>Promise</p>
</li>
<li><p>Object.observe</p>
</li>
<li><p>MutationObserver</p>
</li>
</ul>
<p>宏任务</p>
<ul>
<li><p>script </p>
</li>
<li><p>setTimeout</p>
</li>
<li><p>setInterval</p>
</li>
<li><p>I/O</p>
</li>
<li><p>UI rendering</p>
</li>
</ul>
<p>所以页面的script标签要写在页面的最下面 防止页面阻塞</p>
<h2 id="13-浏览器渲染机制"><a href="#13-浏览器渲染机制" class="headerlink" title="13.浏览器渲染机制"></a>13.浏览器渲染机制</h2><ul>
<li><p>处理HTML并构建DOM树</p>
</li>
<li><p>处理CSS并构建CSSOM树</p>
</li>
<li><p>将DOM树和CSSOM树合并成一棵渲染树</p>
</li>
<li><p>根据渲染树来布局 计算每一个节点的位置</p>
</li>
<li><p>调用GPU绘制 合成图层 显示在屏幕上</p>
</li>
</ul>
<h2 id="14-重绘-amp-amp-回流"><a href="#14-重绘-amp-amp-回流" class="headerlink" title="14.重绘 &amp;&amp; 回流"></a>14.重绘 &amp;&amp; 回流</h2><p>重绘：不改变外观 只改变例如背景色 透明度等</p>
<p>回流：布局或几何属性需要改变</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>一些些题目</title>
    <url>/FE/Interview/Question/</url>
    <content><![CDATA[<h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><h3 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h3><p>以下这段代码的输出为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">].reduce(</span><br><span class="line">  (acc, cur) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> acc.concat(cur);</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure>

<details yellow><summary> <p>查看答案</p> </summary>
              <div class='content'>
              <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">答案: [ 1, 2, 0, 1, 2, 3 ]</span><br><span class="line">解析: [1,2]为初始值 一开始的acc就是[1,2]</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<a id="more"></a>

<h3 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h3><p>以下这段代码的输出为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (age &gt; <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> message = <span class="string">&#x27;U are old enough&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> message = <span class="string">&#x27;U are too young&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge(<span class="number">21</span>);</span><br></pre></td></tr></table></figure>

<details yellow><summary> <p>查看答案</p> </summary>
              <div class='content'>
              <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">答案: ReferenceError</span><br><span class="line">解析: const有块级作用域 在return语句中 在当前作用域下找不到message变量</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="case3"><a href="#case3" class="headerlink" title="case3"></a>case3</h3><p>以下这段代码的输出为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> x = (y = <span class="number">10</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> y);</span><br></pre></td></tr></table></figure>

<details yellow><summary> <p>查看答案</p> </summary>
              <div class='content'>
              <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">答案:  undefined number</span><br><span class="line">解析:  let x = (y = 10) 相当于 y = 10 let x = y</span><br><span class="line">      而y则变成了全局变量 可以用window.y获取到</span><br><span class="line">      let有块级作用域 在外部无法访问</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="case4"><a href="#case4" class="headerlink" title="case4"></a>case4</h3><p>以下这段代码的输出为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line"></span><br><span class="line">obj.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure>

<details yellow><summary> <p>查看答案</p> </summary>
              <div class='content'>
              <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">答案:  &#123; name: &#x27;chou&#x27;, age: 18 &#125;</span><br><span class="line">解析:  Object.freeze(obj)使得我们无法对obj进行修改</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="case5"><a href="#case5" class="headerlink" title="case5"></a>case5</h3><p>以下这段代码的输出为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParams</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;chou&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">getParams<span class="string">`<span class="subst">$&#123;name&#125;</span> is <span class="subst">$&#123;age&#125;</span> years old`</span>;</span><br></pre></td></tr></table></figure>

<details yellow><summary> <p>查看答案</p> </summary>
              <div class='content'>
              <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">答案:  &#123; &#x27;0&#x27;: [ &#x27;&#x27;, &#x27; is &#x27;, &#x27; years old&#x27; ], &#x27;1&#x27;: &#x27;chou&#x27;, &#x27;2&#x27;: 18 &#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="case6"><a href="#case6" class="headerlink" title="case6"></a>case6</h3><p>以下这段代码的输出为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> colorConfig = &#123;</span><br><span class="line">  red: <span class="literal">true</span>,</span><br><span class="line">  yellow: <span class="literal">false</span>,</span><br><span class="line">  blue: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> color = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colorConfig.color[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<details yellow><summary> <p>查看答案</p> </summary>
              <div class='content'>
              <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">答案:  TypeError</span><br><span class="line">解析:  colorConfig.color[1]会先执行colorConfig.color 返回undefined</span><br><span class="line">      然后undefined[1] 会返回Cannot read property &#x27;1&#x27; of undefined</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="case7"><a href="#case7" class="headerlink" title="case7"></a>case7</h3><p>以下这段代码的输出为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">&#x27;number&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<details yellow><summary> <p>查看答案</p> </summary>
              <div class='content'>
              <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">答案:  [ undefined, undefined, undefined ]</span><br><span class="line">解析:  if (typeof item === &#x27;number&#x27;) return 语句 条件成立 但是没有返回值 默认返回undefined</span><br><span class="line">      return item * 2 中 item 都已经是undefined</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="case8"><a href="#case8" class="headerlink" title="case8"></a>case8</h3><p>以下这段代码的输出为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>].map(<span class="built_in">parseInt</span>);</span><br></pre></td></tr></table></figure>

<details yellow><summary> <p>查看答案</p> </summary>
              <div class='content'>
              <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">答案:  [ 1, NaN, NaN ]</span><br><span class="line">解析:  该语句在执行时候 等价于[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;].map((value,index) =&gt; parseInt(value,index))</span><br><span class="line">parseInt(&#x27;1&#x27;,0) // 基数为0时 当10进制来处理 1*10^0</span><br><span class="line">parseInt(&#x27;2&#x27;,1) // 基数为1 只有一个状态0 2不在里面 推出NaN</span><br><span class="line">parseInt(&#x27;3&#x27;,2) // 基数为2 状态有0 1 2 推出3不在里面 NaN</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="case8-1"><a href="#case8-1" class="headerlink" title="case8"></a>case8</h3><p>以下这段代码的输出为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<details yellow><summary> <p>查看答案</p> </summary>
              <div class='content'>
              <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">答案:  [Function: b]</span><br><span class="line">解析:  显然 干扰我们的只有立即执行函数内部的b = 20 这条语句到底有没有赋值成功</span><br><span class="line">      答案是立即执行函数无法被赋值 因为JS内部将立即调用函数当成了const定义的常量</span><br><span class="line">      我们可以在严格模式下 测试这段代码</span><br><span class="line">      var b = 10</span><br><span class="line">      (function b () &#123;</span><br><span class="line">        &#x27;use strict&#x27;</span><br><span class="line">        b = 20</span><br><span class="line">        console.log(b)</span><br><span class="line">      &#125;)()</span><br><span class="line">      我们可以看到 控制台马上就给我们反馈了一个TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="case9"><a href="#case9" class="headerlink" title="case9"></a>case9</h3><p>以下这段代码的输出为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="number">4</span>,</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">  splice: <span class="built_in">Array</span>.prototype.splice,</span><br><span class="line">  push: <span class="built_in">Array</span>.prototype.push,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.push(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure>

<details yellow><summary> <p>查看答案</p> </summary>
              <div class='content'>
              <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">答案:  &#123;</span><br><span class="line">        &#x27;2&#x27;: 1,</span><br><span class="line">        &#x27;3&#x27;: 4,</span><br><span class="line">        length: 3,</span><br><span class="line">        splice: [Function: splice],</span><br><span class="line">        push: [Function: push]</span><br><span class="line">      &#125;</span><br><span class="line">解析:  只有一个对象有splice就会变成伪数组</span><br><span class="line">      这一题的push会使length+1 然后在下标为length的地方插入新值</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="case10"><a href="#case10" class="headerlink" title="case10"></a>case10</h3><p>以下这段代码的输出为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> changeAge = <span class="function">(<span class="params">x = &#123; ...person &#125;</span>) =&gt;</span> (x.age += <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> changeAgeAndName = <span class="function">(<span class="params">x = &#123; ...person &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  x.age += <span class="number">1</span>;</span><br><span class="line">  x.name = <span class="string">&#x27;Sam&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">changeAge(person);</span><br><span class="line">changeAgeAndName();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br></pre></td></tr></table></figure>

<details yellow><summary> <p>查看答案</p> </summary>
              <div class='content'>
              <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">答案:  &#123; name: &#x27;chou&#x27;, age: 19 &#125;</span><br><span class="line">解析:  第一处函数调用我们传入了参数 而参数是一个对象 方法体中的操作会直接影响到这个对象</span><br><span class="line">      而第二处函数调用我们没有传入参数  但是它有默认值 person对象的一个拷贝 所以不会影响到我们最终的</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h2 id="手写题"><a href="#手写题" class="headerlink" title="手写题"></a>手写题</h2><h3 id="Promise-实现红绿灯交替"><a href="#Promise-实现红绿灯交替" class="headerlink" title="Promise 实现红绿灯交替"></a>Promise 实现红绿灯交替</h3><blockquote>
<p>红灯三秒亮一次，绿灯一秒亮一次，黄灯 2 秒亮一次；如何让三个灯不断交替重复亮灯？（用 Promise 实现）</p>
</blockquote>
<details yellow><summary> <p>查看答案</p> </summary>
              <div class='content'>
              <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;green&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">light</span>(<span class="params">timer, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(cb());</span><br><span class="line">    &#125;, timer);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  light(<span class="number">3000</span>, red)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> light(<span class="number">2000</span>, green);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> light(<span class="number">1000</span>, yellow);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      step();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">step();</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="最大公共子串"><a href="#最大公共子串" class="headerlink" title="最大公共子串"></a>最大公共子串</h3><blockquote>
<p>input : [‘floor’, ‘flower’, ‘flow’] ===&gt; output: flo</p>
</blockquote>
<details yellow><summary> <p>查看答案</p> </summary>
              <div class='content'>
              <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCommon</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> str = arr[<span class="number">0</span>].slice(<span class="number">0</span>, idx);</span><br><span class="line">  <span class="keyword">while</span> (arr.every(<span class="function">(<span class="params">item</span>) =&gt;</span> item.includes(str))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str === arr[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    str = arr[<span class="number">0</span>].slice(<span class="number">0</span>, ++idx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str.slice(<span class="number">0</span>, str.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><blockquote>
<p>反转字符串 多个空格最后只显示一个<br>input : hello lucky chou! ===&gt; chou! lucky hello</p>
</blockquote>
<details yellow><summary> <p>查看答案</p> </summary>
              <div class='content'>
              <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> arr = str</span><br><span class="line">    .trim()</span><br><span class="line">    .split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    .reduce(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (curr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        prev.push(curr);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;, [])</span><br><span class="line">    .reverse()</span><br><span class="line">    .forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      res += item + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res.trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">temp(<span class="string">&#x27;hello i am $&#123;name&#125; i like $&#123;sport&#125;&#x27;</span>, &#123;</span><br><span class="line">  sport: <span class="string">&#x27;basketball&#x27;</span>,</span><br><span class="line">  name: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<details yellow><summary> <p>查看答案</p> </summary>
              <div class='content'>
              <p>对正则不太熟悉 暂时想到了这种解法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">temp</span>(<span class="params">str, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.includes(key)) &#123;</span><br><span class="line">      str = str.replace(key, obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  str = str.replace(<span class="regexp">/\$&#123;/g</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="regexp">/\&#125;/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>应知应会 Vue</title>
    <url>/FE/Interview/Vue/</url>
    <content><![CDATA[<h2 id="1-MVVM（数据驱动视图的方式）"><a href="#1-MVVM（数据驱动视图的方式）" class="headerlink" title="1.MVVM（数据驱动视图的方式）"></a>1.MVVM（数据驱动视图的方式）</h2><img src="http://images4.10qianwan.com/10qianwan/20190608/b_0_201906080345393289.jpg"  />

<ul>
<li><p>MVVM 是 Model-View-ViewModel 的缩写</p>
</li>
<li><p>Model：代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑。</p>
<p>我们把 Model 称为数据层，因为它只关心数据，不关心其他任何行为</p>
</li>
<li><p>View：用户操作界面。当 ViewModel 对 Model 进行更新的时候，会通过数据绑定更新到 View</p>
</li>
<li><p>ViewModel：业务逻辑层，View 需要什么数据，ViewModel 要提供这个数据；</p>
<p>View 有某些操作，ViewModel 就要响应这些操作</p>
</li>
</ul>
<p>MVVM 模式简化了界面于业务的依赖，解决了数据频繁更新</p>
<p>MVVM 利用数据的双向绑定</p>
<p>使得 Model 变化时 ViewModel 会自动更新</p>
<p>而 ViewModel 变化时，View 也会自动变化</p>
<a id="more"></a>

<h2 id="2-Vue-生命周期"><a href="#2-Vue-生命周期" class="headerlink" title="2.Vue 生命周期"></a>2.Vue 生命周期</h2><blockquote>
<p>总共分为 8 个阶段 创建前/后 载入前/后 更新前/后 销毁前/后</p>
</blockquote>
<p>各个生命周期的作用</p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>组件实例被创建之初，组件的属性生效之前</td>
</tr>
<tr>
<td>created</td>
<td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td>
</tr>
<tr>
<td>beforeMount</td>
<td>在挂载开始之前被调用：相关的 render 函数首次被调用</td>
</tr>
<tr>
<td>mounted</td>
<td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td>
</tr>
<tr>
<td>update</td>
<td>组件数据更新之后</td>
</tr>
<tr>
<td>activited</td>
<td>keep-alive 专属，组件被激活时调用</td>
</tr>
<tr>
<td>deadctivated</td>
<td>keep-alive 专属，组件被销毁时调用</td>
</tr>
<tr>
<td>beforeDestory</td>
<td>组件销毁前调用</td>
</tr>
<tr>
<td>destoryed</td>
<td>组件销毁后调用</td>
</tr>
</tbody></table>
<br>

<img src="http://poetries1.gitee.io/img-repo/2020/07/61.png">

<br>

<h2 id="3-Vue2-x-实现数据双向绑定的原理"><a href="#3-Vue2-x-实现数据双向绑定的原理" class="headerlink" title="3.Vue2.x 实现数据双向绑定的原理"></a>3.Vue2.x 实现数据双向绑定的原理</h2><p>Object.defineProperty 数据劫持 + 发布者订阅者模式</p>
<h2 id="4-Vue-组件间的参数传递"><a href="#4-Vue-组件间的参数传递" class="headerlink" title="4.Vue 组件间的参数传递"></a>4.Vue 组件间的参数传递</h2><p>父组件与子组件传值</p>
<ul>
<li><p>父组件传给子组件：子组件通过 props 方法接受数据</p>
</li>
<li><p>子组件传给父组件：子组件通过$emit 自定义事件</p>
</li>
</ul>
<h2 id="5-Vue-的路由实现：hash-模式和-history-模式"><a href="#5-Vue-的路由实现：hash-模式和-history-模式" class="headerlink" title="5.Vue 的路由实现：hash 模式和 history 模式"></a>5.Vue 的路由实现：hash 模式和 history 模式</h2><ul>
<li><p>hash 模式：# 用 window.location.hash 读取</p>
</li>
<li><p>history 模式： pushState 和 replaceState 是一个栈操作</p>
</li>
</ul>
<h2 id="6-Vuex"><a href="#6-Vuex" class="headerlink" title="6.Vuex"></a>6.Vuex</h2><ul>
<li><p>只用来读取的状态集中放在 store 中</p>
</li>
<li><p>改变状态的方式是提交 mutations，这是个同步的事物；异步逻辑应该封装在 action 中</p>
</li>
<li><p>state：Vuex 使用单一状态树,即每个应用将仅仅包含一个 store 实例，但单一状态树和模块化并不冲突。</p>
<p>存放的数据状态，不可以直接修改里面的数据。</p>
</li>
<li><p>mutations：mutations 定义的方法动态修改 Vuex 的 store 中的状态或数据</p>
</li>
<li><p>getters：类似 vue 的计算属性，主要用来过滤一些数据。</p>
</li>
<li><p>action：actions 可以理解为通过将 mutations 里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。</p>
<p>view 层通过 store.dispath 来分发 action</p>
</li>
</ul>
<h2 id="7-v-if-和-v-show-区别"><a href="#7-v-if-和-v-show-区别" class="headerlink" title="7.v-if 和 v-show 区别"></a>7.v-if 和 v-show 区别</h2><ul>
<li><p>v-if 按照条件是否渲染 （不一定渲染）</p>
</li>
<li><p>v-show 是 display 的 block 或 none （一定渲染）</p>
</li>
</ul>
<h2 id="8-route和-router-的区别"><a href="#8-route和-router-的区别" class="headerlink" title="8.$route和$router 的区别"></a>8.$route和$router 的区别</h2><ul>
<li><p>$router 是路由实例 包括了路由的跳转方法，钩子函数等</p>
</li>
<li><p>$route 是路由信息对象，包括 path、params 等</p>
</li>
</ul>
<h2 id="9-如何让-CSS-只在当前组件起作用"><a href="#9-如何让-CSS-只在当前组件起作用" class="headerlink" title="9.如何让 CSS 只在当前组件起作用"></a>9.如何让 CSS 只在当前组件起作用</h2><p>组件内的 style 标签添加 scoped 如果不添加 则默认为全局样式</p>
<h2 id="10-scoped-样式穿透"><a href="#10-scoped-样式穿透" class="headerlink" title="10.scoped 样式穿透"></a>10.scoped 样式穿透</h2><blockquote>
<p>scoped 虽然避免了组件之间的样式污染，但是很多时候我们需要修改组件中的某个样式，但是又不想去除 scoped 属性</p>
</blockquote>
<p>尤其是在使用第三方的 UI 库修改其样式时</p>
<p>解决：</p>
<ul>
<li>使用/deep/</li>
</ul>
<h2 id="11-lt-keep-alive-gt-的作用"><a href="#11-lt-keep-alive-gt-的作用" class="headerlink" title="11.&lt;keep-alive&gt;的作用"></a>11.<code>&lt;keep-alive&gt;</code>的作用</h2><blockquote>
<p>keep-alive 可以实现组件缓存，当组件切换时不会对当前组件进行卸载</p>
</blockquote>
<ul>
<li><code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染</li>
</ul>
<blockquote>
<p>比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，</p>
</blockquote>
<p>那么就可以对列表组件使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染</p>
<ul>
<li><p>常用的两个属性<code>include/exclude</code>，允许组件有条件的进行缓存</p>
</li>
<li><p>两个生命周期<code>activated/deactivated</code>，用来得知当前组件是否处于活跃状态</p>
</li>
</ul>
<h2 id="12-在-Vue-中使用插件的步骤"><a href="#12-在-Vue-中使用插件的步骤" class="headerlink" title="12.在 Vue 中使用插件的步骤"></a>12.在 Vue 中使用插件的步骤</h2><ul>
<li><p>import from 导入该插件</p>
</li>
<li><p>Vue.use(xxx)</p>
<p>该方法会在内部调用插件的 install 方法</p>
</li>
</ul>
<h2 id="13-Vue-组件中的-data-为什么必须是函数"><a href="#13-Vue-组件中的-data-为什么必须是函数" class="headerlink" title="13.Vue 组件中的 data 为什么必须是函数"></a>13.Vue 组件中的 data 为什么必须是函数</h2><ul>
<li><p>每个组件都是 Vue 的实例</p>
</li>
<li><p>组件共享 data 属性，当 data 的值是一个引用类型时，改变其中一个会影响其他</p>
</li>
</ul>
<h2 id="14-vue-router-有哪几种导航守卫"><a href="#14-vue-router-有哪几种导航守卫" class="headerlink" title="14.vue-router 有哪几种导航守卫"></a>14.vue-router 有哪几种导航守卫</h2><blockquote>
<p>全局前置守卫 router.beforeEach</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>to: Route</code>: 即将要进入的目标（路由对象）</p>
</li>
<li><p><code>from: Route</code>: 当前导航正要离开的路由</p>
</li>
<li><p><code>next: Function</code>: 一定要调用该方法来 <code>resolve</code> 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截）</p>
</li>
<li><p>执行效果依赖 next 方法的调用参数。</p>
</li>
<li><p><code>next()</code>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</p>
</li>
<li><p><code>next(false)</code>:取消进入路由，url 地址重置为 from 路由地址(也就是将要离开的路由地址)</p>
</li>
</ul>
<blockquote>
<p>全局解析守卫</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>全局后置钩子</p>
</blockquote>
<p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>路由独享的守卫</p>
</blockquote>
<p>你可以在路由配置上直接定义 beforeEnter 守卫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>组件内的守卫</p>
</blockquote>
<ul>
<li><p>beforeRouteEnter</p>
</li>
<li><p>beforeRouteUpdate (2.2 新增)</p>
</li>
<li><p>beforeRouteLeave</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  <span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeRouteUpdate</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="15-watch-vs-computed"><a href="#15-watch-vs-computed" class="headerlink" title="15.watch vs computed"></a>15.watch vs computed</h2><p><strong>computed:</strong></p>
<ul>
<li><p>computed 是计算属性,也就是计算值,它更多用于计算值的场景</p>
</li>
<li><p>computed 具有缓存性,computed 的值在 getter 执行后是会缓存的，只有在它依赖的属性值改变之后，</p>
<p>下一次获取 computed 的值时才会重新调用对应的 getter 来计算 computed 适用于计算比较消耗性能的计算场景</p>
</li>
</ul>
<p><strong>watch:</strong></p>
<ul>
<li><p>更多的是「观察」的作用,类似于某些数据的监听回调,用于观察 props $emit 或者本组件的值,</p>
<p>当数据变化时来执行回调进行后续操作</p>
</li>
<li><p>无缓存性，页面重新渲染时值不变化也会执行</p>
</li>
</ul>
<p><strong>小结:</strong></p>
<ul>
<li><p>当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为 computed</p>
</li>
<li><p>如果你需要在某个数据变化时做一些事情，使用 watch 来观察这个数据变化</p>
</li>
</ul>
<h2 id="16-ref-的作用"><a href="#16-ref-的作用" class="headerlink" title="16.ref 的作用"></a>16.ref 的作用</h2><ul>
<li><p>获取 dom 元素<code>this.$refs.xxx</code></p>
</li>
<li><p>获取子组件中的数据</p>
</li>
<li><p>调用子组件中的方法</p>
</li>
</ul>
<h2 id="17-Vue-中的-key-有什么用"><a href="#17-Vue-中的-key-有什么用" class="headerlink" title="17.Vue 中的 key 有什么用"></a>17.Vue 中的 key 有什么用</h2><ul>
<li>key 是 Vue 中的 vnode 标记的唯一 id，通过这个 key，我们可以使 diff 操作更加准确，更快速</li>
</ul>
<h2 id="18-v-model-的原理"><a href="#18-v-model-的原理" class="headerlink" title="18.v-model 的原理"></a>18.v-model 的原理</h2><p>可以看成是 input 和 value 的语法糖</p>
<ul>
<li><p>:value 动态的将 data 绑定给 input</p>
</li>
<li><p>@input 一旦有输入 就修改 data 中的数据</p>
</li>
</ul>
<h2 id="19-v-if-和-v-for-为什么不建议连用"><a href="#19-v-if-和-v-for-为什么不建议连用" class="headerlink" title="19.v-if 和 v-for 为什么不建议连用"></a>19.v-if 和 v-for 为什么不建议连用</h2><p>v-for 会优于 v-if 先执行</p>
<p>如果此时 v-if 的执行结果是 false 就会造成性能浪费</p>
<p>可以用嵌套的标签 在大盒子上使用 v-if</p>
<h2 id="20-Vue-改变数组触发试图更新"><a href="#20-Vue-改变数组触发试图更新" class="headerlink" title="20.Vue 改变数组触发试图更新"></a>20.Vue 改变数组触发试图更新</h2><p>调用方法：Vue.set(target,key.value)</p>
<p>target 可以是对象或数组</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>React小册 -- 扬帆起航</title>
    <url>/FE/React/basic/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li><p>父子组件通信</p>
</li>
<li><p>生命周期函数</p>
</li>
<li><p>状态提升</p>
</li>
<li><p>ref</p>
</li>
<li><p>context</p>
</li>
<li><p>合成事件</p>
</li>
<li><p>event 对象</p>
</li>
<li><p>高阶组件</p>
</li>
<li><p>受控组件/非受控组件</p>
</li>
<li><p>dangerouslySetInnerHTML</p>
</li>
<li><p>动手实现 Vue 中的 slot</p>
</li>
<li><p>动手实现 Vue 中的 v-show</p>
</li>
<li><p>StrictMode</p>
</li>
</ul>
<a id="more"></a>

<p>本章节的 demo 都以类组件为例 等 hook 章节后都为函数式组件</p>
<h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><h4 id="父组件-gt-子组件"><a href="#父组件-gt-子组件" class="headerlink" title="父组件 -&gt; 子组件"></a>父组件 -&gt; 子组件</h4><p>父 -&gt; 子 比较简单</p>
<p>父组件直接通过 props 来传递属性</p>
<p>类组件用<code>this.props.[属性名]</code>即可拿到对应的属性</p>
<p>函数式组件直接使用<code>props.[属性名]</code>即可</p>
<p>以下 Demo 为 我们在父组件中决定在子组件中 要展示的元素</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;p&gt;我是子组件&lt;/p&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;<span class="built_in">this</span>.props.movies.map(<span class="function">(<span class="params">movie, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;movie&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">          &#125;)&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;Child movies=&#123;[<span class="string">&#x27;姜子牙&#x27;</span>, <span class="string">&#x27;哪吒&#x27;</span>, <span class="string">&#x27;杨戬&#x27;</span>]&#125; /&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子 —&gt; 父</p>
<p>原理和 父 -&gt; 子 类似</p>
<p>在父组件用 props 向子组件传递一个回调函数</p>
<p>然后在子组件用<code>this.props.&lt;函数名&gt;</code>触发这个回调函数</p>
<p>我们继续更改以下以上 Demo 让子组件告诉父组件 我要删除谁</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;p&gt;我是子组件&lt;/p&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;<span class="built_in">this</span>.props.movies.map(<span class="function">(<span class="params">movie, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">              &lt;li key=&#123;index&#125; onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.handleDeleteClick(index)&#125;&gt;</span><br><span class="line">                &#123;movie&#125;</span><br><span class="line">              &lt;/li&gt;</span><br><span class="line">            );</span><br><span class="line">          &#125;)&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleDeleteClick</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.onDelete &amp;&amp; <span class="built_in">this</span>.props.onDelete(index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;Child</span><br><span class="line">          movies=&#123;[<span class="string">&#x27;姜子牙&#x27;</span>, <span class="string">&#x27;哪吒&#x27;</span>, <span class="string">&#x27;杨戬&#x27;</span>]&#125;</span><br><span class="line">          onDelete=&#123;<span class="function">(<span class="params">index</span>) =&gt;</span> <span class="built_in">this</span>.handleDeleteMovie(index)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleDeleteMovie</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`子组件要删除的是第<span class="subst">$&#123;index&#125;</span>项`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h3><p>主要参考官方的<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">生命周期图谱</a></p>
<p>props state 的改变 和 forceUpdate() 将会重新调用<code>render()</code>生命周期函数 具体内容可见下几讲</p>
<ul>
<li><p>constructor</p>
<ul>
<li><p>初始化内部的 state</p>
</li>
<li><p>为事件绑定 this</p>
</li>
</ul>
</li>
<li><p>shouldComponentUpdate</p>
<ul>
<li>对比更新前后数据 优化性能</li>
</ul>
</li>
<li><p>componentDidMount</p>
<ul>
<li>网络请求</li>
</ul>
</li>
<li><p>componentWillUnmount</p>
<ul>
<li>清除定时器等 优化性能</li>
</ul>
</li>
</ul>
<h3 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h3><p>状态提升只是一个概念性的东西</p>
<p>状态就是指 子组件间共享的一些数据</p>
<p>提升就是指 将这些状态保存在离它们最近的父组件</p>
<p>比如更改主题 我们就需要将主题这个状态存放在根组件下 然后通过 props 一层一层往下传递</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>现在 我们简单的实现一个 DEMO</p>
<p>有一个 输入框 和 获取用户名的按钮</p>
<p>通过点击按钮 获取用户名</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      username: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          name=<span class="string">&quot;username&quot;</span></span><br><span class="line">          value=&#123;<span class="built_in">this</span>.state.username&#125;</span><br><span class="line">          onChange=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.handleUsernameChange(e)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.showName()&#125;&gt;GET NAME&lt;/button&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleUsernameChange</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      username: e.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">`U NAME IS <span class="subst">$&#123;<span class="built_in">this</span>.state.username&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止 我们所有的数据 都是来自于组件内部维护的 state</p>
<p>那么我们能否直接通过 标签自身 来实现这个功能呢</p>
<p>React 向我们提供了 <strong>ref</strong> 可以来获取 dom</p>
<p>ref 主要有三种实现方式可以来获取 dom</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.usernameRef = React.createRef()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &#123;<span class="comment">/* ref 后可以等于 字符串/对象/函数 */</span>&#125;</span><br><span class="line">        &#123;<span class="comment">/* 方式一 字符串 */</span>&#125;</span><br><span class="line">        &#123;<span class="comment">/* 此方法不推荐 在后续版本中可能会被移除 */</span>&#125;</span><br><span class="line">        &lt;input ref=<span class="string">&quot;usernameRef&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">        &#123;<span class="comment">/* 方式二 对象 */</span>&#125;</span><br><span class="line">        &lt;input ref=&#123;<span class="built_in">this</span>.usernameRef&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &#123;<span class="comment">/* 方式三 函数 */</span>&#125;</span><br><span class="line">        &lt;input ref=&#123;<span class="function">(<span class="params">_usernameRef</span>) =&gt;</span> (<span class="built_in">this</span>._usernameRef = _usernameRef)&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.showName()&#125;&gt;GET NAME&lt;/button&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>方式二 和 方式三的区别是</p>
<ul>
<li><p>通过<code>React.createRef()</code>创建 其实例在 current 属性下</p>
</li>
<li><p>而通过函数创建 其实例就是我们所命名的那个属性</p>
</li>
</ul>
<p>我们可以通过打印 this 来看一下 三者之间的区别（当然 第一种已经不推荐）</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">context: &#123;&#125;</span><br><span class="line">props: &#123;&#125;</span><br><span class="line">refs: &#123;usernameRef: input&#125;  // 方式一</span><br><span class="line">state: null</span><br><span class="line">updater: &#123;isMounted: ƒ, enqueueSetState: ƒ, enqueueReplaceState: ƒ, enqueueForceUpdate: ƒ&#125;</span><br><span class="line">usernameRef: &#123;current: input&#125; // 方式二</span><br><span class="line">_reactInternalInstance: &#123;_processChildContext: ƒ&#125;</span><br><span class="line">_reactInternals: FiberNode &#123;tag: 1, key: null, stateNode: Example, elementType: ƒ, type: ƒ, …&#125;</span><br><span class="line">_usernameRef: input // 方式三</span><br></pre></td></tr></table></figure>

<p><strong>写在最后 在生产中 千万不要这样去操作 dom</strong></p>
<p><strong>所有可以使用声明式完成的功能都不要使用命令式</strong></p>
<p><strong>除非我们需要实现 聚焦 动画 等 必须要获取到 dom 的操作</strong></p>
<h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>假设 我们有一个 App 组件</p>
<p>然后 App 组件下有一个 HeaderWrapper 组件</p>
<p>HeaderWrapper 组件 内部 又有一个 Nav 组件</p>
<p>那么 如果我们共享 App 组件 中的数据 到 Nav 组件</p>
<p>就要 经过 HeaderWrapper 组件 传递到 Nav 组件</p>
<p>传统的代码如下</p>
<p>我们可以用 <code>&#123;...this.props&#125;</code> 的写法 将 props 传递给子组件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeaderWrapper</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;Nav &#123;...this.props&#125; /&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nav</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span>name: &#123;this.props.name&#125;<span class="tag">&lt;/&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;HeaderWrapper name=&#123;<span class="string">&#x27;chou&#x27;</span>&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 HeaderWrapper 组件 可能不需要这一层的数据 但是 我们在传递数据中却要将数据传递给它</p>
<p>这时 React 给我们提供了一个属性 <strong>context</strong> 用来解决</p>
<p>常用 API</p>
<ul>
<li><p>React.createContext(defaultValue)</p>
</li>
<li><p>contextType</p>
</li>
<li><p>Provider</p>
</li>
<li><p>Consumer</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步 我们创建一个context对象 可以传入一个默认值</span></span><br><span class="line"><span class="keyword">const</span> UserContext = React.createContext(&#123;</span><br><span class="line">  name: <span class="string">&#x27;defaultName&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeaderWrapper</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;Nav &#123;...this.props&#125; /&gt;</span><br><span class="line">        &lt;List /&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nav</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 第二步 在需要 使用的地方 使用contextType</span></span><br><span class="line">  <span class="keyword">static</span> contextType = UserContext;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;Nav&lt;/div&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是函数式组件 需要使用这种特殊写法</span></span><br><span class="line"><span class="comment">// 我们可以打印出value 来观察它确实拿到了context中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;UserContext.Consumer&gt;</span><br><span class="line">      &#123;<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &lt;/UserContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 第三步 用Provider包裹需要共享数据的组件</span></span><br><span class="line">      &lt;UserContext.Provider value=&#123;<span class="built_in">this</span>.state&#125;&gt;</span><br><span class="line">        &lt;HeaderWrapper /&gt;</span><br><span class="line">      &lt;/UserContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 在实际开发中 我们不会使用 context</p>
<p>在下一章我就会介绍到 在开发中 用来管理状态的 <strong>Redux</strong></p>
<p>而它的模式 就和 context 类似</p>
<h3 id="合成事件"><a href="#合成事件" class="headerlink" title="合成事件"></a>合成事件</h3><p>React 中 绑定事件的 onClick 等等 其实是 React 中的合成事件</p>
<p>它和原生的 onclick 事件 不同 主要是用于抹平各浏览器之间的差异</p>
<p>同时 React 不只是期望运行在 Web 环境 也期望运行在客户端 ios Android 等</p>
<p>所以 React 重新封装了这些事件</p>
<p>用一套代码 来适用所有场景</p>
<h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><p>在绑定事件时 传入的第一个参数默认就是 React 中的 event 对象</p>
<p>同样的 React 也封装了这个对象 为了适合所有开发场景下的使用</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.getEvent(e)&#125;&gt;Get Event&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getEvent</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">    <span class="comment">// SyntheticBaseEvent &#123;_reactName: &quot;onClick&quot;, _targetInst: null, type: &quot;click&quot;, nativeEvent: MouseEvent, target: button, …&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><p>高阶组件就是一个函数 它接收一个组件 并返回一个新的组件</p>
<p>主要功能有</p>
<ul>
<li><p>可操作所有传入的 props</p>
</li>
<li><p>可操作组件的生命周期</p>
</li>
<li><p>可操作组件的 static 方法</p>
</li>
<li><p>获取 refs</p>
</li>
<li><p>可操作 state</p>
</li>
<li><p>可以渲染劫持</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NavBar = ThemeHOC(</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">          &lt;p style=&#123;&#123; <span class="attr">color</span>: <span class="built_in">this</span>.props.theme &#125;&#125;&gt;NavBar&lt;/p&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Message = LifeHOC(</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        username: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">          &lt;p&gt;Message&lt;/p&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;我是原来的componentDidMount，我执行了&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强props</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemeHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">theme</span>=<span class="string">&#123;</span>&#x27;<span class="attr">red</span>&#x27;&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 劫持生命周期方法 props state render方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LifeHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 劫持到原组件的实例 并可以修改它</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 可操作所有传入的props</span></span><br><span class="line">      <span class="comment">// 可操作组件的生命周期</span></span><br><span class="line">      <span class="comment">// 可操作组件的static方法</span></span><br><span class="line">      <span class="comment">// 获取refs</span></span><br><span class="line">      <span class="comment">// 可操作state</span></span><br><span class="line">      <span class="comment">// 可以渲染劫持</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;NavBar /&gt;</span><br><span class="line">        &lt;Message name=&#123;<span class="string">&#x27;chou&#x27;</span>&#125; /&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="受控组件-非受控组件"><a href="#受控组件-非受控组件" class="headerlink" title="受控组件/非受控组件"></a>受控组件/非受控组件</h3><p>受控组件的意思 主要是针对表单这些元素</p>
<p>其 value 由 state 来维护 但是也会造成每一个表单都需要编写事件去更新数据的麻烦</p>
<p>非受控组件 则是 表单的数据由表单自己去维护</p>
<p>主要是 通过 ref 来实现</p>
<p>官方主要推荐受控组件的方式</p>
<h3 id="dangerouslySetInnerHTML"><a href="#dangerouslySetInnerHTML" class="headerlink" title="dangerouslySetInnerHTML"></a>dangerouslySetInnerHTML</h3><p>假设有以下代码 我们想要渲染出 tag 中原有的样式</p>
<p>直接渲染的话 它会被当成字符串 渲染在页面上</p>
<p>需要使用 dangerouslySetInnerHTML</p>
<p>但是也存在副作用 正如它的名字 dangerously 一样</p>
<p>不合时宜的使用 可能会你的页面遭受 XSS 攻击</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      tag: <span class="string">&#x27;&lt;h2&gt;HELLO REACT&lt;/h2&gt;&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &#123;<span class="comment">/* 页面中显示 &lt;h2&gt;HELLO REACT&lt;/h2&gt; */</span>&#125;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.tag&#125;</span><br><span class="line"></span><br><span class="line">        &#123;<span class="comment">/* 页面正确解析h2标签 */</span>&#125;</span><br><span class="line">        &lt;div dangerouslySetInnerHTML=&#123;&#123; <span class="attr">__html</span>: <span class="built_in">this</span>.state.tag &#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动手实现-Vue-中的-slot"><a href="#动手实现-Vue-中的-slot" class="headerlink" title="动手实现 Vue 中的 slot"></a>动手实现 Vue 中的 slot</h3><p>第一版 所有嵌套在组件内部的子组件 都会在<code>props.children</code>这个属性内</p>
<p>我们可以通过 <code>props.children[index]</code> 来拿对应位置的组件</p>
<p>缺点：使用者 必须 <strong>按顺序</strong> 传入组件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabBar</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;tab-bar&quot;</span>&gt;</span><br><span class="line">          &lt;Fragment className=<span class="string">&quot;tab-bar-img&quot;</span>&gt;&#123;<span class="built_in">this</span>.props.children[<span class="number">0</span>]&#125;&lt;/Fragment&gt;</span><br><span class="line">          &lt;Fragment className=<span class="string">&quot;tab-bar-title&quot;</span>&gt;</span><br><span class="line">            &#123;<span class="built_in">this</span>.props.children[<span class="number">1</span>]&#125;</span><br><span class="line">          &lt;/Fragment&gt;</span><br><span class="line">          &lt;Fragment className=<span class="string">&quot;tab-bar-more&quot;</span>&gt;&#123;<span class="built_in">this</span>.props.children[<span class="number">2</span>]&#125;&lt;/Fragment&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;TabBar&gt;</span><br><span class="line">          &lt;span&gt;头像&lt;/span&gt;</span><br><span class="line">          &lt;span&gt;标题&lt;/span&gt;</span><br><span class="line">          &lt;span&gt;更多&lt;/span&gt;</span><br><span class="line">        &lt;/TabBar&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vue 中有具名组件的概念 我们继续改进代码来实现吧</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotSwapper</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; leftSlot, midSlot, rightSlot &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;span className=<span class="string">&quot;leftSlot&quot;</span>&gt;&#123;leftSlot&#125;&lt;/span&gt;</span><br><span class="line">        &lt;span className=<span class="string">&quot;midSlot&quot;</span>&gt;&#123;midSlot&#125;&lt;/span&gt;</span><br><span class="line">        &lt;span className=<span class="string">&quot;rightSlot&quot;</span>&gt;&#123;rightSlot&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;SlotSwapper</span><br><span class="line">        leftSlot=&#123;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>这是左边的插槽<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">        midSlot=&#123;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>这是中间的插槽<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">        rightSlot=&#123;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>这是右边的插槽<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将 JSX 作为 props 传入给子组件</p>
<p>然后在子组件解构 这样就可以拿到每一个对应的 slot 而不用去考虑顺序的问题</p>
<h3 id="动手实现-Vue-中的-v-show"><a href="#动手实现-Vue-中的-v-show" class="headerlink" title="动手实现 Vue 中的 v-show"></a>动手实现 Vue 中的 v-show</h3><p>Vue 中 有两种显示隐藏元素的指令 分别是</p>
<ul>
<li><p>v-show (元素并没有被移除)</p>
</li>
<li><p>v-if / v-else (元素被移除了)</p>
</li>
</ul>
<p>而我们在 React 中 用条件渲染 时 默认就是使用了 v-if 这种模式</p>
<p>如果这个操作是频繁的 大量的 创建元素 和 销毁元素 无疑是浪费性能的</p>
<p>下面是简单的 条件渲染的 DEMO</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      isShow: <span class="literal">true</span>,</span><br><span class="line">      text: <span class="string">&#x27;HIDE&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.isShow &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>NOW U SEE ME<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.handleHideClick()&#125;&gt;</span><br><span class="line">          &#123;<span class="built_in">this</span>.state.text&#125;</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleHideClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      isShow: !<span class="built_in">this</span>.state.isShow,</span><br><span class="line">      text: <span class="built_in">this</span>.state.isShow ? <span class="string">&#x27;SHOW&#x27;</span> : <span class="string">&#x27;HIDE&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们动手来改造上面这段代码 让它具有 v-show 这种功能</p>
<p>思路：我们可以动态决定组件的 style</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div style=&#123;&#123; <span class="attr">display</span>: <span class="built_in">this</span>.state.isShow ? <span class="string">&#x27;block&#x27;</span> : <span class="string">&#x27;none&#x27;</span> &#125;&#125;&gt;</span><br><span class="line">  NOW U SEE ME</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="StrictMode"><a href="#StrictMode" class="headerlink" title="StrictMode"></a>StrictMode</h3><p>使用 create-react-app 脚手架创建项目时 默认会在跟标签外面包裹<code>StrictMode</code></p>
<p>和<code>Fragment</code>一样 <code>StrictMode</code>不会创建任何 UI 元素 正如字面意思一样 它主要用于</p>
<ul>
<li><p>识别不安全的生命周期</p>
</li>
<li><p>使用过时的 ref 的 API</p>
</li>
<li><p>检查意外的副作用</p>
<ul>
<li>开发环境下会调用两次 constructor</li>
</ul>
</li>
<li><p>识别废弃的 findDOMNode 方法</p>
</li>
<li><p>检测过时的 context API</p>
</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React小册 -- css</title>
    <url>/FE/React/css/</url>
    <content><![CDATA[<p>React 官网对于 CSS 并没有明确的规范</p>
<p>以下提供两种开发者喜爱的 React CSS 解决方案</p>
<h3 id="CSS-MODULE"><a href="#CSS-MODULE" class="headerlink" title="CSS MODULE"></a>CSS MODULE</h3><p>首先 我们准备好</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./css/header.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./css/footer.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;header&quot;</span>&gt;我是Header&lt;/div&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Footer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;footer&quot;</span>&#125;&gt;我是Footer&lt;/div&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;Footer /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是 css 文件</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* header.css */</span></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">22px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* footer.css */</span></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一段传统的 CSS 引入方案</p>
<p>但是 CSS 是层叠样式表 对于重名的选择器 后面的会覆盖前面的</p>
<p>所以上述两个 css 文件后在引入后 footer.css 后引入会覆盖 header.css 中重名的选择器</p>
<p>这时候 我们我们使用 css modules 就可以解决这种问题</p>
<p>相当于给每一个 css 文件都生成了各自的作用域</p>
<ul>
<li><p>将所有的 css 文件名 改成 xxx.module.css</p>
</li>
<li><p>给引入的 css 文件取名 例如 <code>import HeaderStyle from &#39;./css/header.module.css&#39;</code></p>
</li>
<li><p>将每一个 class 当成变量来使用 例如 <code>&lt;div className=&#123;FooterStyle.footer&#125;&gt;我是Footer&lt;/div&gt;</code></p>
</li>
</ul>
<p>这种方案的优点很明显 我们不需要额外的学习成本 使用简单</p>
<p>但是 对于需要动态生成的 css 样式 这一种方案就显得无能为力了</p>
<h4 id="在-create-react-app-中集成-sass-并开启-css-module"><a href="#在-create-react-app-中集成-sass-并开启-css-module" class="headerlink" title="在 create-react-app 中集成 sass 并开启 css module"></a>在 create-react-app 中集成 sass 并开启 css module</h4><p>首先暴露出 webpack 配置 脚本命令在 package.json 中</p>
<p><code>yarn eject</code></p>
<p>然后安装 sass-loader 和 sass 模块</p>
<p>这里插一嘴 sass 和 scss 的区别</p>
<p>sass 有严格的语法 scss 则更像 css 文件 所以我们在开发中可以直接使用 scss</p>
<p>最后在 webpack.config.json 中插入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    &#123; <span class="attr">loader</span>: <span class="string">&#x27;style-loader&#x27;</span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        modules: &#123;</span><br><span class="line">          localIdentName: <span class="string">&#x27;[local]_[hash:base64:5]&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">loader</span>: <span class="string">&#x27;sass-loader&#x27;</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这里补充一点 如果在 css module 这种方案中修改 antd 的样式的话 你会发现它是修改不了的</p>
<p>因为它会被编译成带 hash 的 class 自然就作用不到 antd 的样式上了</p>
<p>这个时候可以使用：global 的方式 在编译的时候就是按照原来的 class 进行输出 例如</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:global</span> &#123;</span><br><span class="line">  .antd-xxx &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-id">#ccc</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  :global &#123;</span><br><span class="line">    <span class="selector-class">.antd-xxx</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>:global 不是必须在顶部声明的</p>
<h3 id="CSS-IN-JS"><a href="#CSS-IN-JS" class="headerlink" title="CSS IN JS"></a>CSS IN JS</h3><p>对于这种方案 我们直接一个第三库 <code>styled-components</code></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add styled-components</span><br></pre></td></tr></table></figure>

<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>新建 style.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Header = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  font-size: 20px;</span></span><br><span class="line"><span class="string">  color: red;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Footer = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  color: yellow;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<p>用``包裹的语法 是标签字符串</p>
<p>styled.div 这些都是第三方库中内置的方法</p>
<p>通过标签字符串 我们不仅可以调用该方法 而且可以在方法内部 通过某种匹配 得到每一个样式</p>
<p>最后在组件中 我们可以像使用普通组件那样来使用 CSS 样式</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Header, Footer &#125; <span class="keyword">from</span> <span class="string">&#x27;./style&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header&gt;我是Header&lt;/Header&gt;</span><br><span class="line">      &lt;Footer&gt;我是Footer&lt;/Footer&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h4><h5 id="添加-attrs-属性"><a href="#添加-attrs-属性" class="headerlink" title="添加 attrs 属性"></a>添加 attrs 属性</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HYInput = styled.input.attrs(&#123;</span><br><span class="line">  placeholder: <span class="string">&quot;请填写密码&quot;</span>,</span><br><span class="line">&#125;)<span class="string">`</span></span><br></pre></td></tr></table></figure>

<h5 id="props-穿透"><a href="#props-穿透" class="headerlink" title="props 穿透"></a>props 穿透</h5><p>props 可以被传递给 styled 组件</p>
<p>在组件中 我们传递 props</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Header color=<span class="string">&quot;blue&quot;</span>&gt;&lt;/Header&gt;</span><br></pre></td></tr></table></figure>

<p>在 styled 组件中 我们可以接收到 props</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Header = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  color: <span class="subst">$&#123;(props) =&gt; props.color&#125;</span>;</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br></pre></td></tr></table></figure>

<h5 id="支持伪类和伪元素"><a href="#支持伪类和伪元素" class="headerlink" title="支持伪类和伪元素"></a>支持伪类和伪元素</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Footer = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  color: yellow;</span></span><br><span class="line"><span class="string">  &amp;:hover &#123;</span></span><br><span class="line"><span class="string">    color: blue;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  &amp;::after &#123;</span></span><br><span class="line"><span class="string">    content: &#x27;页脚&#x27;;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<h5 id="支持选择器嵌套"><a href="#支持选择器嵌套" class="headerlink" title="支持选择器嵌套"></a>支持选择器嵌套</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Footer = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  color: yellow;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  p &#123;</span></span><br><span class="line"><span class="string">    color: red;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React小册 -- 生命周期</title>
    <url>/FE/React/lifecycle/</url>
    <content><![CDATA[<h3 id="React-15"><a href="#React-15" class="headerlink" title="React 15"></a>React 15</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">constructor()</span><br><span class="line">componentWillReceiveProps() -- 过时</span><br><span class="line">shouldComponentUpdate()</span><br><span class="line">componentWillMount() -- 过时</span><br><span class="line">componentWillUpdate() -- 过时</span><br><span class="line">componentDidUpdate()</span><br><span class="line">componentDidMount()</span><br><span class="line">render()</span><br><span class="line">componentWillUnmount()</span><br></pre></td></tr></table></figure>

<h3 id="React-16"><a href="#React-16" class="headerlink" title="React 16"></a>React 16</h3><p><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">React16 生命周期图谱</a></p>
<p>在 React16 前 React 采用同步渲染的方式 每次组件更新 都会构建一颗新的 dom 树 然后进行 diff 实现对 dom 的定向更新</p>
<p>但是这个过程 是一个十分耗时的递归过程</p>
<p>有可能在这个期间 用户都无法进行任何的操作 因为这个过程抢占了主线程 浏览器无法响应其他任何操作</p>
<p>而 React16 用 Fiber 架构重写了核心算法</p>
<p>将同步渲染改为了异步渲染</p>
<p>查看生命周期图谱左侧 可以看到生命周期又被分为了三个阶段</p>
<ul>
<li><p>render 阶段：纯净且没有副作用，可能会被 React 暂停、终止或重新启动</p>
</li>
<li><p>pre-commit 阶段：可以读取 DOM</p>
</li>
<li><p>commit 阶段：可以使用 DOM，运行副作用，安排更新</p>
</li>
</ul>
<p>用户感知到是 commit 阶段 所以这个阶段始终使用同步渲染 避免任何异步渲染带来的风险</p>
<p>而 render 阶段则会将一个大的更新任务拆解为许多个小任务</p>
<p>每当执行完一个小任务时，渲染线程都会把主线程交回去，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿</p>
<p>因为 render 阶段的生命周期有可能被打断重新执行 所以在 render 阶段的生命周期就变得不那么”安全“了</p>
<p>回过头来 看看 react15 有哪些生命周期位于 render 阶段</p>
<ul>
<li><p>componentWillMount</p>
</li>
<li><p>componentWillUpdate</p>
</li>
<li><p>componentWillRecevieProps</p>
</li>
</ul>
<p>因为它们阻碍了 Fiber 架构 所以在 React16 中将其弃用</p>
<p>并且把新增的 getDerivedStateFromProps 用 static 修饰，阻止用户在其内部使用 this</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React小册 -- props &amp; state</title>
    <url>/FE/React/props-state/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li><p>props</p>
</li>
<li><p>state</p>
</li>
<li><p>setState 同步 or 异步</p>
</li>
</ul>
<a id="more"></a>

<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><h4 id="props-默认值"><a href="#props-默认值" class="headerlink" title="props 默认值"></a>props 默认值</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    address: <span class="string">&#x27;hangzhou&#x27;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="built_in">this</span>.props.address&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用 Address.defaultProps 的语法去设置默认值</p>
<h4 id="使用-propTypes-进行类型检查"><a href="#使用-propTypes-进行类型检查" class="headerlink" title="使用 propTypes 进行类型检查"></a>使用 propTypes 进行类型检查</h4><p>propsTypes 在使用时 需要引入 prop-types 库</p>
<p><strong>注意 在 使用时 propTypes 要以小写开头</strong></p>
<p>具体配置 官网已经写的很详细了 <a href="https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html">参考</a></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    address: <span class="string">&#x27;hangzhou&#x27;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意 这里的propTypes 是小驼峰</span></span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    address: PropTypes.string.isRequired,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="built_in">this</span>.props.address&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Address address=&#123;<span class="string">&#x27;123&#x27;</span>&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述验证 我们期望 address 传入一个字符串 但是父组件传入了一个数字</p>
<p>控制台 就会进行警告 但是它不是报错</p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>和 props 不同的是 props 是外部数据来维护组件</p>
<p>而 state 是内部数据来维护组件</p>
<p>但是不管是 props 还是 state 都是<strong>不可变数据</strong></p>
<p>即 我们不可以直接去修改原始数据的 props 和 state</p>
<p>必须 拷贝一份新的数据进行修改</p>
<h4 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h4><p>setState 继承自 Component 所以我们可以在组件中直接使用 setState 方法</p>
<p>我们来看一下以下代码片段</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">      age: <span class="number">18</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;p&gt;name : &#123;<span class="built_in">this</span>.state.name&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;age : &#123;<span class="built_in">this</span>.state.age&#125;&lt;/p&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.handleNameChange()&#125;&gt;change name&lt;/button&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleNameChange</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      name: <span class="string">&#x27;luckychou&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 state 中保存了两个状态 name 和 age</p>
<p>但是 在点击按钮的时候 我们只修改了 name 这一个属性</p>
<p>所以 在这个操作的时候 age 属性 到底会有影响嘛</p>
<p>但其实 React 在 setState 这一个操作中 其实是合并了前后的 state</p>
<p>用到了 Object.assign({},oldState,newState)</p>
<h5 id="异步-or-同步"><a href="#异步-or-同步" class="headerlink" title="异步 or 同步"></a>异步 or 同步</h5><p>我们修改一下刚刚的代码片段</p>
<p>在执行 setState 的前后 都打印一下 我们的 name 属性</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">handleNameChange</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.name)</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    name: <span class="string">&#x27;luckychou&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以惊奇的发现 两次的打印结果都是 chou 并未更新成 最新的数据</p>
<p>那如果我们需要拿到最新的 state 并基于最新的数据进行操作 该怎么办呢</p>
<p>这时 我们可以给 setState 传入第二个参数 这是一个回调函数</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">handleNameChange</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.name)</span><br><span class="line">  <span class="built_in">this</span>.setState(</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">&#x27;luckychou&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;我是最新的数据哦,name : &#x27;</span>, <span class="built_in">this</span>.state.name)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比 三次打印结果 我们可以发现 使用这种方法 我们确实可以拿到最新的 state</p>
<p>我们继续修改我们的代码 添加 count 状态 和 button 按钮 并为其绑定事件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">handleCountAdd</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="built_in">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="built_in">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="built_in">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那如果是这样呢</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">handleCountAdd</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="built_in">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="built_in">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="built_in">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未使用定时器的情况下 我们会得到超出预期的结果</p>
<p>虽然 事件内部执行了 三次 +1 的操作 但是点击按钮时 呈现的效果还是 只加了一次 1</p>
<p>而使用定时器则和我们的预期一致</p>
<p>OK 现在 我们来做一个总结</p>
<ul>
<li><p>setState 在合成事件(onClick)和回调函数中是异步的</p>
</li>
<li><p>在定时器和原生事件(通过 dom addEventListener)中是同步的</p>
</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React小册 -- hooks 轻巧快艇 vs 重装战舰</title>
    <url>/FE/React/hooks/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li><p>类组件需要继承 class，函数组件不需要</p>
</li>
<li><p>类组件可以访问生命周期方法，函数组件不能</p>
</li>
<li><p>类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以</p>
</li>
<li><p>类组件中可以定义并维护 state（状态），而函数组件不可以 （hook 之后改变了这种情况）</p>
</li>
<li><p>……</p>
</li>
</ul>
<a id="more"></a>

<p>类组件的状态 一般由组件内部维护 这样就会造成组件的复用性很差</p>
<p>而函数式组件 又无法保存状态 比如如下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>); <span class="comment">//1</span></span><br><span class="line">add(<span class="number">1</span>); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>我们无法在函数中保存 result 的状态 因为每一次执行函数时 都会重新初始化 result</p>
<p>这个时候 hook 就横空出世了 它想要解决的问题就是</p>
<p>让函数式组件拥有类似类组件的功能</p>
<p>说得更具体一点，函数组件更加契合 React 框架的设计理念</p>
<p>我们来看一个简单的 demo</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfilePageClass</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  showMessage = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">&#x27;Followed &#x27;</span> + <span class="built_in">this</span>.props.user);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="built_in">this</span>.showMessage, <span class="number">3000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Follow<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfilePageFunction</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> showMessage = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">&#x27;Followed &#x27;</span> + props.user);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(showMessage, <span class="number">3000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Follow<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    user: <span class="string">&#x27;lucky&#x27;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          &lt;b&gt;Choose profile to view: &lt;/b&gt;</span><br><span class="line">          &lt;select</span><br><span class="line">            value=&#123;<span class="built_in">this</span>.state.user&#125;</span><br><span class="line">            onChange=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.setState(&#123; <span class="attr">user</span>: e.target.value &#125;)&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            &lt;option value=<span class="string">&quot;lucky&quot;</span>&gt;lucky&lt;/option&gt;</span><br><span class="line">            &lt;option value=<span class="string">&quot;chou&quot;</span>&gt;chou&lt;/option&gt;</span><br><span class="line">            &lt;option value=<span class="string">&quot;ramires&quot;</span>&gt;ramires&lt;/option&gt;</span><br><span class="line">          &lt;/select&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;h1&gt;Welcome to &#123;<span class="built_in">this</span>.state.user&#125;’s profile!&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">          &lt;ProfilePageFunction user=&#123;<span class="built_in">this</span>.state.user&#125; /&gt;</span><br><span class="line">          &lt;b&gt; (<span class="function"><span class="keyword">function</span>)&lt;/<span class="title">b</span>&gt;</span></span><br><span class="line"><span class="function">        &lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="function">        &lt;<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="function">          &lt;<span class="title">ProfilePageClass</span> <span class="title">user</span>=</span>&#123;<span class="built_in">this</span>.state.user&#125; /&gt;</span><br><span class="line">          &lt;b&gt; (<span class="class"><span class="keyword">class</span>)&lt;/<span class="title">b</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">p</span>&gt;<span class="title">Can</span> <span class="title">you</span> <span class="title">spot</span> <span class="title">the</span> <span class="title">difference</span> <span class="title">in</span> <span class="title">the</span> <span class="title">behavior</span>?&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="class">      &lt;/&gt;</span></span><br><span class="line"><span class="class">    )</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过 setTimeout 将预期中的渲染推迟了 3s，打破了 this.props 和渲染动作之间的这种时机上的关联</p>
<p>进而导致类组件在渲染时捕获到的是一个错误的、修改后的 this.props</p>
<p>而函数式组件可以确保在任何时机下读取到的 props，都是最初捕获到的那个 props</p>
<p>所以函数组件是一个更加匹配其设计理念、也更有利于逻辑拆分与重用的组件表达形式</p>
<h2 id="内置-hooks"><a href="#内置-hooks" class="headerlink" title="内置 hooks"></a>内置 hooks</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#39;react&#39;;</span><br><span class="line">import &#123; Statistic, Button &#125; from &#39;antd&#39;;</span><br><span class="line">import &#123; LikeOutlined &#125; from &#39;@ant-design&#x2F;icons&#39;;</span><br><span class="line"></span><br><span class="line">const Counter: React.FunctionComponent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState&lt;number&gt;(0);</span><br><span class="line"></span><br><span class="line">  const addCountSync &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    setCount(count + 1);</span><br><span class="line">    setCount(count + 1);</span><br><span class="line">    setCount(count + 1);</span><br><span class="line">    setCount(count + 1);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const addCountAsync &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    setCount((preState) &#x3D;&gt; preState + 1);</span><br><span class="line">    setCount((preState) &#x3D;&gt; preState + 1);</span><br><span class="line">    setCount((preState) &#x3D;&gt; preState + 1);</span><br><span class="line">    setCount((preState) &#x3D;&gt; preState + 1);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Statistic value&#x3D;&#123;count&#125; prefix&#x3D;&#123;&lt;LikeOutlined &#x2F;&gt;&#125; &#x2F;&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;ADD COUNTER&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; addCountSync()&#125;&gt;ADD COUNTER SYNC&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; addCountAsync()&#125;&gt;ADD COUNTER ASYNC&lt;&#x2F;Button&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Counter;</span><br></pre></td></tr></table></figure>

<h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * useReducer</span><br><span class="line"> * 和redux没有关系 组件之间不共享数据</span><br><span class="line"> * 是useState的一种替代方案</span><br><span class="line"> * 对于复杂的业务 使用useReducer比useState会有更好的可读性</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import React, &#123; useReducer &#125; from &#39;react&#39;;</span><br><span class="line">import &#123; Button &#125; from &#39;antd&#39;;</span><br><span class="line"></span><br><span class="line">enum Actions &#123;</span><br><span class="line">  ADD_COUNT_VALUE &#x3D; &#39;ADD_COUNT_VALUE&#39;,</span><br><span class="line">  SUB_COUNT_VALUE &#x3D; &#39;SUB_COUNT_VALUE&#39;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IState &#123;</span><br><span class="line">  count: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IAction &#123;</span><br><span class="line">  type: Actions;</span><br><span class="line">  payload?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myReducers &#x3D; (state: IState, action: IAction) &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; payload &#x3D; 1 &#125; &#x3D; action;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case Actions.ADD_COUNT_VALUE:</span><br><span class="line">      return &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        count: state.count + payload,</span><br><span class="line">      &#125;;</span><br><span class="line">    case Actions.SUB_COUNT_VALUE:</span><br><span class="line">      return &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        count: state.count - payload,</span><br><span class="line">      &#125;;</span><br><span class="line">    default:</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Count &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [state, dispatch] &#x3D; useReducer(myReducers, &#123; count: 0 &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;当前计数：&#123;state.count&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;Button</span><br><span class="line">        onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: Actions.ADD_COUNT_VALUE, payload: 2 &#125;)&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        +2</span><br><span class="line">      &lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: Actions.SUB_COUNT_VALUE &#125;)&#125;&gt;</span><br><span class="line">        -1</span><br><span class="line">      &lt;&#x2F;Button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Count &#x2F;&gt;</span><br><span class="line">      &lt;Count &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * useEffect</span><br><span class="line"> * 允许函数组件执行副作用操作 在一定程度上弥补了生命周期的缺席</span><br><span class="line"> * 可以接收两个参数，分别是回调函数与依赖数组 useEffect(callBack, [])</span><br><span class="line"> * 第一个参数 函数形式 可实现等同于componentDidMount shouldComponentUpdate componentWillUnmount</span><br><span class="line"> * 并且可以返回一个函数 用来消除副作用 类似componentWillUnmount 可以做一些事件的解绑 定时器的关闭等</span><br><span class="line"> * 第二个参数 数组 状态依赖项 实现性能优化 如果传[] 则等同于不开启shouldComponentUpdate</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import React, &#123; FC, useEffect, useState &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">import &#123; Button, Tag &#125; from &#39;antd&#39;;</span><br><span class="line"></span><br><span class="line">const App: FC &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [state, setState] &#x3D; useState&lt;Number[]&gt;([]);</span><br><span class="line">  const [tag, setTag] &#x3D; useState&lt;string&gt;(&#39;Tag&#39;);</span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;state更新了&#39;);</span><br><span class="line"></span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&#39;componentWillUnmount&#39;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [state]);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Button</span><br><span class="line">        onClick&#x3D;&#123;() &#x3D;&gt;</span><br><span class="line">          setState((prevState) &#x3D;&gt; [</span><br><span class="line">            ...prevState,</span><br><span class="line">            Math.trunc(Math.random() * 10),</span><br><span class="line">          ])</span><br><span class="line">        &#125;</span><br><span class="line">      &gt;</span><br><span class="line">        change state</span><br><span class="line">      &lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setTag(&#39;new Tag&#39;)&#125;&gt;change tag&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;br &#x2F;&gt;</span><br><span class="line">      &lt;Tag color&#x3D;&quot;orange&quot;&gt;&#123;tag&#125;&lt;&#x2F;Tag&gt;</span><br><span class="line">      &#123;state.map((item, idx) &#x3D;&gt; &#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;Tag color&#x3D;&quot;orange&quot; key&#x3D;&#123;idx&#125;&gt;</span><br><span class="line">            &#123;item&#125;</span><br><span class="line">          &lt;&#x2F;Tag&gt;</span><br><span class="line">        );</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * useContext</span><br><span class="line"> * 可以在子组件之间共享数据</span><br><span class="line"> * 1)在组件外创建context对象 const AppContext &#x3D; React.createContext(&#123;&#125;)</span><br><span class="line"> * 2)父组件内使用context对象下的Provider 并赋值</span><br><span class="line"> * 3)在子组件内过去context对象 React.useContext(AppContext)</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">interface ITheme &#123;</span><br><span class="line">  theme: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const AppContext &#x3D; React.createContext&lt;ITheme&gt;(&#123;</span><br><span class="line">  theme: &#39;red&#39;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const NavBar &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; theme &#125; &#x3D; React.useContext(AppContext);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2 style&#x3D;&#123;&#123; color: theme &#125;&#125;&gt;NavBar&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Message &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; theme &#125; &#x3D; React.useContext(AppContext);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2 style&#x3D;&#123;&#123; color: theme &#125;&#125;&gt;Message&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;AppContext.Provider value&#x3D;&#123;&#123; theme: &#39;red&#39; &#125;&#125;&gt;</span><br><span class="line">      &lt;NavBar &#x2F;&gt;</span><br><span class="line">      &lt;Message &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;AppContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * useRef</span><br><span class="line"> * 获取结点</span><br><span class="line"> * 保存数据</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import &#123; Button, Input &#125; from &#39;antd&#39;;</span><br><span class="line">import React, &#123; FC, useRef, useState &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">const App: FC &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState&lt;number&gt;(0);</span><br><span class="line">  const numRef &#x3D; useRef&lt;number&gt;(count);</span><br><span class="line">  const domRef &#x3D; useRef&lt;HTMLInputElement | null&gt;(null);</span><br><span class="line">  const antdRef &#x3D; useRef&lt;Input | null&gt;(null);</span><br><span class="line">  const showRef &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(domRef.current, antdRef.current);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input defaultValue&#x3D;&quot;h5&quot; ref&#x3D;&#123;domRef&#125; &#x2F;&gt;</span><br><span class="line">      &lt;Input defaultValue&#x3D;&quot;antd&quot; ref&#x3D;&#123;antdRef&#125; style&#x3D;&#123;&#123; width: 200 &#125;&#125;&gt;&lt;&#x2F;Input&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; showRef()&#125;&gt;showRef&lt;&#x2F;Button&gt;</span><br><span class="line"></span><br><span class="line">      &lt;p&gt;count : &#123;count&#125;&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">      &#123;&#x2F;* numRef的值始终引用最初的那个count *&#x2F;&#125;</span><br><span class="line">      &lt;p&gt;numRef : &#123;numRef.current&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;+1&lt;&#x2F;Button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>在之前的章节中 我们用 shouldComponentUpdate 实现过性能优化</p>
<p>也用过 PureComponent 和 memo 来实现</p>
<p>在使用 memo 的时候 React 内部使用的是浅层比较</p>
<p>对于函数和对象 其实不管怎样都是不会相等的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">() =&gt; &#123;&#125; === <span class="function">() =&gt;</span> &#123;&#125; <span class="comment">// false</span></span><br><span class="line">&#123;&#125; === &#123;&#125; <span class="comment">// false</span></span><br><span class="line">[] === [] <span class="comment">// false</span></span><br><span class="line"><span class="number">1</span> === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> === <span class="string">&#x27;1&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>所以假设 我们在父组件中将<strong>引用数据类型</strong>当作 props 传递给子组件时</p>
<p>这时候 子组件的 memo 就会失效</p>
<p>而在 hook 中 对于函数 我们可以用 useCallback 将函数包装</p>
<p>对于对象 我们可以使用 useMemo 将对象包装</p>
<p>注：滥用 useCallback 不仅不会优化性能 还会造成性能浪费</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * useCallback</span><br><span class="line"> * 有一个父组件，其中包含子组件，子组件接收一个函数作为props；</span><br><span class="line"> * 通常而言，如果父组件更新了，子组件也会执行更新；但是大多数场景下，更新是没有必要的，</span><br><span class="line"> * 我们可以借助useCallback来返回函数，然后把这个函数作为props传递给子组件；这样，子组件就能避免不必要的更新</span><br><span class="line"> * useCallback(()&#x3D;&gt;&#123;&#125;,[])</span><br><span class="line"> * 第一个参数 是一个函数</span><br><span class="line"> * 第二个参数 是一个数组 是这个函数的依赖项 只有依赖项更新 函数才会重新执行</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import &#123; Button &#125; from &#39;antd&#39;;</span><br><span class="line">import React, &#123; useState, useCallback, memo &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">interface IProps &#123;</span><br><span class="line">  getSum: () &#x3D;&gt; number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Child1 &#x3D; memo((&#123; getSum &#125;: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;我是子组件 在父组件中没使用useCallback&#39;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;getSum&#125;&gt;没使用useCallback&lt;&#x2F;Button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const Child2 &#x3D; memo((&#123; getSum &#125;: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;我是子组件 在父组件中使用了useCallback&#39;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;getSum&#125;&gt;使用了useCallback&lt;&#x2F;Button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const Parent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [num, setNum] &#x3D; useState(0);</span><br><span class="line">  const [max, setMax] &#x3D; useState(100);</span><br><span class="line"></span><br><span class="line">  const getSum1 &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;getSum1方法执行了&#39;);</span><br><span class="line">    let sum &#x3D; 0;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; max; i++) &#123;</span><br><span class="line">      sum +&#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const getSum2 &#x3D; useCallback(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;getSum2方法执行了&#39;);</span><br><span class="line">    let sum &#x3D; 0;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; max; i++) &#123;</span><br><span class="line">      sum +&#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;, [max]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;sum : &#123;getSum1()&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;sum : &#123;getSum2()&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;num : &#123;num&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setNum(num + 1)&#125;&gt;change num&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setMax((pre) &#x3D;&gt; pre * 2)&#125;&gt;change max&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Child1 getSum&#x3D;&#123;getSum1&#125; &#x2F;&gt;</span><br><span class="line">      &lt;Child2 getSum&#x3D;&#123;getSum2&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Parent;</span><br></pre></td></tr></table></figure>

<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * useMemo</span><br><span class="line"> * 有一个父组件，其中包含子组件，子组件接收一个对象作为props；</span><br><span class="line"> * 通常而言，如果父组件更新了，子组件也会执行更新；但是大多数场景下，更新是没有必要的，</span><br><span class="line"> * 我们可以借助useMemo来返回函数，然后把这个对象作为props传递给子组件；这样，子组件就能避免不必要的更新</span><br><span class="line"> * useMemo(()&#x3D;&gt;(&#123;&#125;),[])</span><br><span class="line"> * 第一个参数 是一个函数 返回一个对象</span><br><span class="line"> * 第二个参数 是一个数组 包含了这个对象的依赖项 只有依赖项更新 函数才会重新执行</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import &#123; Button &#125; from &#39;antd&#39;;</span><br><span class="line">import React, &#123; useState, useMemo, memo &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">interface IProps &#123;</span><br><span class="line">  age?: number;</span><br><span class="line">  stu?: &#123; name: string; age: number &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接收的是基本数据类型 memo生效</span><br><span class="line">const Child &#x3D; memo((&#123; age &#125;: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;props为基本数据类型的子组件渲染了&#39;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;props为基本数据类型&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;h2&gt;age:&#123;age&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 父组件中没有使用useMemo 子组件的memo失效</span><br><span class="line">const Child1 &#x3D; memo((&#123; stu &#125;: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;props为引用数据类型 未使用useMemo&#39;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;props为引用数据类型 未使用useMemo&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;h2&gt;</span><br><span class="line">        &#123;stu?.name&#125;:&#123;stu?.age&#125;</span><br><span class="line">      &lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 父组件中使用了useMemo 子组件的memo生效</span><br><span class="line">const Child2 &#x3D; memo((&#123; stu &#125;: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;props为引用数据类型 使用useMemo&#39;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;props为引用数据类型 使用useMemo&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;h2&gt;</span><br><span class="line">        &#123;stu?.name&#125;:&#123;stu?.age&#125;</span><br><span class="line">      &lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const Parent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line">  const [age, setAge] &#x3D; useState(18);</span><br><span class="line">  const [name, setName] &#x3D; useState(&#39;lucky&#39;);</span><br><span class="line"></span><br><span class="line">  const stu1 &#x3D; &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const stu2 &#x3D; useMemo(</span><br><span class="line">    () &#x3D;&gt; (&#123;</span><br><span class="line">      name,</span><br><span class="line">      age,</span><br><span class="line">    &#125;),</span><br><span class="line">    [age]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Child age&#x3D;&#123;age&#125; &#x2F;&gt;</span><br><span class="line">      &lt;Child1 stu&#x3D;&#123;stu1&#125; &#x2F;&gt;</span><br><span class="line">      &lt;Child2 stu&#x3D;&#123;stu2&#125; &#x2F;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;count&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;change count&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setAge(age + 1)&#125;&gt;change age&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setName(&#39;lucky chou&#39;)&#125;&gt;change name&lt;&#x2F;Button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Parent;</span><br></pre></td></tr></table></figure>

<h2 id="自定义-hook"><a href="#自定义-hook" class="headerlink" title="自定义 hook"></a>自定义 hook</h2><p>自定义 hook 的函数名 必须以 use 开头 比如下面是一个打印组件创建/销毁的 useLogger hook</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useLogger = <span class="function">(<span class="params">componentName</span>) =&gt;</span> &#123;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;componentName&#125;</span>组件被创建了`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;componentName&#125;</span>组件被销毁了`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Header = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  useLogger(<span class="string">&#x27;Header&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;Header&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Footer = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  useLogger(<span class="string">&#x27;Footer&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;Footer&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [show, setShow] = useState(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setShow(!show)&#125;&gt;&#123;show ? <span class="string">&#x27;hidden&#x27;</span> : <span class="string">&#x27;show&#x27;</span>&#125;&lt;/button&gt;</span><br><span class="line">      &#123;show &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span>&#125;</span><br><span class="line">      &#123;show &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Footer</span> /&gt;</span></span>&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>告别难以理解的 Class</p>
<ul>
<li><p>this</p>
</li>
<li><p>生命周期</p>
</li>
</ul>
</li>
<li><p>解决业务逻辑难以拆分的问题</p>
<ul>
<li>逻辑一度与生命周期耦合在一起</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="comment">// 1. 这里发起异步调用</span></span><br><span class="line"><span class="comment">// 2. 这里从 props 里获取某个数据，根据这个数据更新 DOM</span></span><br><span class="line"><span class="comment">// 3. 这里设置一个订阅</span></span><br><span class="line"><span class="comment">// 4. 这里随便干点别的什么</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">componentWillUnMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 在这里卸载订阅</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 在这里根据 DidMount 获取到的异步数据更新 DOM</span></span><br><span class="line">  <span class="comment">// 2. 这里从 props 里获取某个数据，根据这个数据更新 DOM（和 DidMount 的第2步一样）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使状态逻辑复用变得简单可行</p>
<ul>
<li><p>HOC（高阶组件）</p>
</li>
<li><p>Render Props</p>
</li>
</ul>
</li>
<li><p>函数组件从设计思想上来看，更加契合 React 的理念。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React小册 -- redux</title>
    <url>/FE/React/redux/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add redux</span><br></pre></td></tr></table></figure>

<p>如果安装过程很慢 可以切换淘宝镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h2 id="Redux-简介"><a href="#Redux-简介" class="headerlink" title="Redux 简介"></a>Redux 简介</h2><img src="https://gitee.com/LuckyChou/blog-images/raw/master/react/redux.png" alt="Redux" />

<p>Redux 是一套管理公共状态的第三方工具 虽然不是 React 官方开发 但已经成为 React 管理状态事实上的标准</p>
<p>类似于 Vue 的 Vuex</p>
<h3 id="Redux-工作流程"><a href="#Redux-工作流程" class="headerlink" title="Redux 工作流程"></a>Redux 工作流程</h3><ul>
<li><p>事件内定义 action 并 dispatch 出去</p>
</li>
<li><p>reducer 接收到 action 进行操作 返回一个新的 state 给 store</p>
</li>
<li><p>store 接收到新的 state 数据发生改变</p>
</li>
<li><p>页面通过 store.subscribe 订阅 store 更新页面</p>
</li>
</ul>
<a id="more"></a>

<p>我们将 Redux 的整个工作流程类比成一个借书的流程</p>
<p>可以看成是如下的操作</p>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>图书馆管理员</p>
<p>他有一本记录借书的本子 reducer</p>
<p>上面写了借书有关的信息 action</p>
<img src="https://gitee.com/LuckyChou/blog-images/raw/master/react/redux-store.png" />

<h3 id="React-Components"><a href="#React-Components" class="headerlink" title="React Components"></a>React Components</h3><p>借书的人</p>
<h3 id="Action-Creators"><a href="#Action-Creators" class="headerlink" title="Action Creators"></a>Action Creators</h3><p>借书人发起借书的申请</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: BORROW_BOOKS,</span><br><span class="line">  text: <span class="string">&#x27;I want to borrow a book&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改变 store 中数据唯一的方法就是 component 提交 action</strong></p>
<p>reducer 中根据 action 中的 type 值来区分请求 并执行具体的操作</p>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>图书管管理员的笔记 记录着各种借书还书的记录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = defaultState, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> BORROW_BOOKS:</span><br><span class="line">      <span class="comment">// 不能修修改state 只能返回一个新的state</span></span><br><span class="line">        <span class="keyword">const</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state))</span><br><span class="line">        <span class="comment">// do Something......</span></span><br><span class="line">        <span class="keyword">return</span> newState</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原则：reducer 中不能修改 state 只能返回一个新的 state</p>
<p>为了防止在操作中不小心修改 state 对象 我们可以引入<code>immutable.js</code>库</p>
<h2 id="Comment-amp-amp-Redux"><a href="#Comment-amp-amp-Redux" class="headerlink" title="Comment &amp;&amp; Redux"></a>Comment &amp;&amp; Redux</h2><p>现在我们用 Redux 重新改造一下我们的 Comment</p>
<h3 id="Redux-DevTools"><a href="#Redux-DevTools" class="headerlink" title="Redux DevTools"></a>Redux DevTools</h3><p>在开始改造我们的项目前 我们再安装一个 chrome 插件</p>
<p>它可以使我们的 Redux 调试 变的极为方便</p>
<p>在创建 store 的方法中传入第二个参数</p>
<p><code>window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>再次启动项目 即可在浏览器调试工具中看到有 redux 选项</p>
<p>好啦 准备工作都完成啦 接下来 我们开始吧</p>
<p>我们要实现的例子很简单就是借助 redux 来管理我们的用户名和列表</p>
<h3 id="创建-store"><a href="#创建-store" class="headerlink" title="创建 store"></a>创建 store</h3><p>我们在项目中创建 store 文件夹</p>
<p>在目录下新建</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">├─ Home</span><br><span class="line">  ├─ actionCreators.ts</span><br><span class="line">  ├─ reducers.ts</span><br><span class="line">  ├─ actionTypes.ts</span><br><span class="line">├─ Article</span><br><span class="line">  ├─ actionCreators.ts</span><br><span class="line">  ├─ reducers.ts</span><br><span class="line">  ├─ actionTypes.ts</span><br></pre></td></tr></table></figure>

<h4 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h4><p>我们在这个文件中创建 store 并引入 redux 库中给我们提供的<code>combineReducers</code>工具函数来合并这两个 reducers</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">&#x27;./home/reducers&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> article <span class="keyword">from</span> <span class="string">&#x27;./article/reducers&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">  home,</span><br><span class="line">  article,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(</span><br><span class="line">  rootReducer,</span><br><span class="line">  <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>createStore</code>中第一个参数传入 reducer</p>
<p>第二个参数可以传入 enhancer 这里我们传入 Redux DevTools 有关的参数</p>
<h4 id="reducer-js"><a href="#reducer-js" class="headerlink" title="reducer.js"></a>reducer.js</h4><p>reducer 用于处理每一个来自组件派发的 action 它将决定每一次 dispatch 后 store 如何变化</p>
<p>这里以 home 页面改变 name 的 action 为例子</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; SET_USER_NAME &#125; <span class="keyword">from</span> <span class="string">&#x27;./actionTypes&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; IAction &#125; <span class="keyword">from</span> <span class="string">&#x27;@type/index&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  username: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = defaultState, <span class="attr">action</span>: IAction) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SET_USER_NAME:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">username</span>: action.username &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 defaultState 为数据的默认值</p>
<p>reducer 文件中只做一件事 就是处理 component 中提交的 action 请求</p>
<p>它导出一个方法</p>
<p>第一个参数 state 为 store 中的旧数据</p>
<p>第二个参数 action 为 component 提交的改变 store 的 action 请求</p>
<p>再次重申：reducer 可以接受 store 中的数据</p>
<p>但是绝不能修改 store 中的数据</p>
<p>我们可以在操作前拷贝一份 store 中数据</p>
<p>然后再对这份数据进行修改 最后 return 出去</p>
<h4 id="actionTypes-js"><a href="#actionTypes-js" class="headerlink" title="actionTypes.js"></a>actionTypes.js</h4><p>管理着我们所有 action 的 type</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SUBMIT_COMMENT_VALUE = <span class="string">&#x27;submit_comment_value&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DELETE_COMMENT_ITEM = <span class="string">&#x27;delete_comment_item&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="actionCreators-js"><a href="#actionCreators-js" class="headerlink" title="actionCreators.js"></a>actionCreators.js</h4><p>统一管理着我们创建 action 的方法</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_USER_NAME = <span class="string">&#x27;SET_USER_NAME&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果为使用 react-redux 连接库</p>
<p>那么你大概会需要用到以下三个 api</p>
<ul>
<li><p>store.dispatch</p>
</li>
<li><p>store.getState</p>
</li>
<li><p>store.subscribe</p>
</li>
</ul>
<p>它们分别用来派发 action 获取 store 和监听 store 的变化</p>
<p>我们一般会将 store.getState 放在构造函数中用于初始化时获取 store</p>
<p>然后使用 store.subscribe 这个方法监听 store 的变化 并更新 store 保持组件中的 store 时刻与最新的一致</p>
<p>demo 如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.state = store.getState()</span><br><span class="line">    <span class="built_in">this</span>.handleStoreChange = <span class="built_in">this</span>.handleStoreChange.bind(<span class="built_in">this</span>)</span><br><span class="line">    store.subscribe(<span class="built_in">this</span>.handleStoreChange)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>但是为了方便使用 我们一般会再引入一个第三方库 <code>react-redux</code></p>
<p>使用这个库可以让我们的组件与 store 之间的连接更为顺畅</p>
<p>使用起来也很简单</p>
<p>首先 我们在根组件处 调用 Provider</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import RouterTemp from &#39;@router&#x2F;temp&#39;;</span><br><span class="line">import &#123; RouteConfigComponentProps &#125; from &#39;react-router-config&#39;;</span><br><span class="line">import &#123; Provider &#125; from &#39;react-redux&#39;;</span><br><span class="line">import store from &#39;@store&#x2F;redux&#x2F;index&#39;;</span><br><span class="line">const index &#x3D; (props: RouteConfigComponentProps) &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Provider store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">      &lt;RouterTemp routerName&#x3D;&quot;&#x2F;store&quot; renderRoutes&#x3D;&#123;props!.route!.routes&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">export default index;</span><br></pre></td></tr></table></figure>

<p>然后在需要用到 store 的组件中 使用 react-redux 提供的高阶组件 connect 导出我们的组件即可</p>
<p>mapStateToProps 和 mapDispatchToProps 两个函数需要我们去实现 它们用于将 store 和 dispatch 映射到我们组件的 props 中</p>
<p>demo 如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123; connect &#125; from &#39;react-redux&#39;;</span><br><span class="line">import * as ACTIONS from &#39;@store&#x2F;redux&#x2F;home&#x2F;actionCreators&#39;;</span><br><span class="line">import &#123; Button &#125; from &#39;antd&#39;;</span><br><span class="line"></span><br><span class="line">interface IProps &#123;</span><br><span class="line">  username: string;</span><br><span class="line">  setUsername: (username: string) &#x3D;&gt; void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Home &#x3D; (props: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Home&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;h2&gt;&#123;props.username&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; props.setUsername(&#39;lucky&#39;)&#125;&gt;change name&lt;&#x2F;Button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const mapStateToProps &#x3D; (state: any) &#x3D;&gt; (&#123;</span><br><span class="line">  username: state.home.username,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps &#x3D; (dispatch: any) &#x3D;&gt; (&#123;</span><br><span class="line">  setUsername: (payload: string) &#x3D;&gt; dispatch(ACTIONS.setUsername(payload)),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(Home);</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li><p>immutable.js</p>
</li>
<li><p>combineReducers</p>
</li>
</ul>
<p>immutable.js 可以防止我们对 state 进行修改 破坏了 State 是只读的这个原则</p>
<p>具体的 API 可参考<a href="https://immutable-js.github.io/immutable-js/">官网</a></p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>本文中的 demo 都是同步代码 如果我们在发送 action 的时候 需要执行一些异步操作 这个时候应该怎么办呢</p>
<p>reducer 中是否可以处理异步操作呢？？？</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React小册 -- ssr</title>
    <url>/FE/React/ssr/</url>
    <content><![CDATA[<p>TODO 文章还在整理中</p>
<details yellow><summary> <p>SPA HTML</p> </summary>
              <div class='content'>
              <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/favicon.ico&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;theme-color&quot;</span> <span class="attr">content</span>=<span class="string">&quot;#000000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">&quot;description&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">&quot;Web site created using create-react-app&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/logo192.png&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;manifest&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/manifest.json&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span>You need to enable JavaScript to run this app.<span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/static/js/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/static/js/0.chunk.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/static/js/main.chunk.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="SPA-vs-SSR"><a href="#SPA-vs-SSR" class="headerlink" title="SPA vs SSR"></a>SPA vs SSR</h3><h3 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h3><ul>
<li><p>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</p>
<p>请注意，截至目前，Google 和 Bing 可以很好对同步 JavaScript 应用程序进行索引。在这里，同步是关键。如果你的应用程序初始展示 loading 菊花图，然后通过 Ajax 获取内容，抓取工具并不会等待异步完成后再行抓取页面内容。也就是说，如果 SEO 对你的站点至关重要，而你的页面又是异步获取内容，则你可能需要服务器端渲染(SSR)解决此问题。</p>
</li>
<li><p>更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验，并且对于那些「内容到达时间(time-to-content) 与转化率直接相关」的应用程序而言，服务器端渲染 (SSR) 至关重要。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="next-js"><a href="#next-js" class="headerlink" title="next.js"></a>next.js</h2>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React小册 -- rematch</title>
    <url>/FE/React/rematch/</url>
    <content><![CDATA[<p>关于 rematch 的介绍 可以参考<a href="https://rematch.gitbook.io/handbook/mu-de">传送门</a></p>
<p>rematch 可以简化传统的 redux 使我们免去写 actionType actionCreator</p>
<p>我们用 rematch 来实现一个数字的累加操作</p>
<p>保存 store 的文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    num: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    <span class="function"><span class="title">setNum</span>(<span class="params">state, num</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, num &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  effects: <span class="function">(<span class="params">dispatch</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">increment</span>(<span class="params">payload, rootState</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; num &#125; = rootState.count;</span><br><span class="line">      num += payload;</span><br><span class="line">      dispatch.count.setNum(num);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> count;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>model.js 在这个文件中 我们做一个聚合导出 可以让代码更加清晰</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> count &#125; <span class="keyword">from</span> <span class="string">&#x27;./count&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> total &#125; <span class="keyword">from</span> <span class="string">&#x27;./total&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> ...</span><br></pre></td></tr></table></figure>

<p>init 函数会帮助我们创建一个 store 同时它会帮助我们自动开启 redux devtools 调试工具</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; init &#125; <span class="keyword">from</span> <span class="string">&#x27;@rematch/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> models <span class="keyword">from</span> <span class="string">&#x27;./model&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = init(&#123; models &#125;);</span><br></pre></td></tr></table></figure>

<p>业务组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider, useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; store &#125; <span class="keyword">from</span> <span class="string">&#x27;./models&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = useSelector(<span class="function">(<span class="params">state</span>) =&gt;</span> state.count);</span><br><span class="line">  <span class="keyword">const</span> dispatch = useDispatch();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div&gt;&#123;counter.num&#125;&lt;/div&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch.count.increment(<span class="number">1</span>)&#125;&gt;+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch.count.increment(<span class="number">10</span>)&#125;&gt;+<span class="number">10</span>&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">View</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;Counter /&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 我介绍一下 useSelector 和 useDispatch</p>
<p>这是 react-redux 在 7.x 之后为了 hook 而推出的</p>
<p>useSelector 返回 Redux store 的引用</p>
<p>useDispatch 返回 Redux store 中对 dispatch 函数的引用</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React小册 -- router</title>
    <url>/FE/React/router/</url>
    <content><![CDATA[<blockquote>
<p>React Router 这一块相对简单 <a href="https://reactrouter.com/web/guides/quick-start">官方文档</a> 已经说的很明白了 在这里 只是做一些简单的 Demo 记录</p>
</blockquote>
<a id="more"></a>

<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>项目目录</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">├── about/</span><br><span class="line">│   ├── address/</span><br><span class="line">│     ├── index.jsx</span><br><span class="line">│   ├── culture/</span><br><span class="line">│     ├── index.jsx</span><br><span class="line">│   ├── index.jsx</span><br><span class="line">├── article/</span><br><span class="line">│   ├── index.jsx</span><br><span class="line">├── profile/</span><br><span class="line">│   ├── index.jsx</span><br><span class="line">├── home/</span><br><span class="line">│   ├── index.jsx</span><br></pre></td></tr></table></figure>

<p>about 组件 我又嵌套了两个路由</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Link, NavLink, Route &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Culture <span class="keyword">from</span> <span class="string">&#x27;./culture&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Address <span class="keyword">from</span> <span class="string">&#x27;./address&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">About</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">      &lt;p&gt;About&lt;/p&gt;</span><br><span class="line">      &lt;Link to=<span class="string">&quot;/about/culture&quot;</span>&gt;文化&lt;/Link&gt;</span><br><span class="line">      &lt;NavLink to=<span class="string">&quot;/about/address&quot;</span>&gt;地址&lt;/NavLink&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Route path=<span class="string">&quot;/about/culture&quot;</span> component=&#123;Culture&#125;&gt;&lt;/Route&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/about/address&quot;</span> component=&#123;Address&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;/BrowserRouter&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最外层的 App 组件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Link, NavLink, Route &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;./home&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">&#x27;./profile&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;./about&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Article <span class="keyword">from</span> <span class="string">&#x27;./article&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      id: <span class="number">1</span>,</span><br><span class="line">      profile: &#123;</span><br><span class="line">        name: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;BrowserRouter&gt;</span><br><span class="line">          &lt;Link to=<span class="string">&quot;/&quot;</span>&gt;首页&lt;/Link&gt;</span><br><span class="line">          &#123;<span class="comment">/* 将对象作为参数传递到对应的页面 */</span>&#125;</span><br><span class="line">          &#123;<span class="comment">/* 对应的页面可以通过props.location获取到这个对象 */</span>&#125;</span><br><span class="line">          &lt;NavLink</span><br><span class="line">            to=&#123;&#123;</span><br><span class="line">              pathname: <span class="string">&#x27;/profile&#x27;</span>,</span><br><span class="line">              state: <span class="built_in">this</span>.state.profile,</span><br><span class="line">            &#125;&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            我的</span><br><span class="line">          &lt;/NavLink&gt;</span><br><span class="line">          &lt;Link to=<span class="string">&quot;/about&quot;</span>&gt;关于&lt;/Link&gt;</span><br><span class="line">          &#123;<span class="comment">/* 动态路由 */</span>&#125;</span><br><span class="line">          &lt;Link to=&#123;<span class="string">`/article/<span class="subst">$&#123;<span class="built_in">this</span>.state.id&#125;</span>`</span>&#125;&gt;文章&lt;/Link&gt;</span><br><span class="line">          &#123;<span class="comment">/* exact开启精确匹配 否则/会匹配所有路由*/</span>&#125;</span><br><span class="line">          &lt;Route exact path=<span class="string">&quot;/&quot;</span> component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/profile&quot;</span> component=&#123;Profile&#125;&gt;&lt;/Route&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/about&quot;</span> component=&#123;About&#125;&gt;&lt;/Route&gt;</span><br><span class="line">          &#123;<span class="comment">/* :为动态路由固定写法 */</span>&#125;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/article/:id&quot;</span> component=&#123;Article&#125;&gt;&lt;/Route&gt;</span><br><span class="line">        &lt;/BrowserRouter&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<h2 id="统一管理-Router"><a href="#统一管理-Router" class="headerlink" title="统一管理 Router"></a>统一管理 Router</h2><p>使用过 Vue 的小伙伴应该都知道</p>
<p>Vue 将所有的路由都放在了一个文件中进行了统一的管理</p>
<p>如果在 React 中也想要将路由进行统一管理的话</p>
<p>就可以引入一个第三方的库 <code>react-router-config</code> <a href="https://www.npmjs.com/package/react-router-config">具体使用</a></p>
<h3 id="react-router-config"><a href="#react-router-config" class="headerlink" title="react-router-config"></a>react-router-config</h3><p>我们可以在根目录下新建一个 router 文件夹 然后在里面新建 index.js 文件 用来管理我们所有的路由</p>
<p>当项目复杂时 我们也可以根据组件来拆分我们的路由</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">default</span>: About &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../about&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">default</span>: Home &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../home&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">default</span>: Profile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../profile&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    exact: <span class="literal">true</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    component: About,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/profile&#x27;</span>,</span><br><span class="line">    component: Profile,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> routes;</span><br></pre></td></tr></table></figure>

<p>然后在刚刚的组件中引入这个文件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; renderRoutes &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-config&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;BrowserRouter&gt;</span><br><span class="line">          &lt;Link to=<span class="string">&quot;/&quot;</span>&gt;首页&lt;/Link&gt;</span><br><span class="line">          &lt;NavLink</span><br><span class="line">            to=&#123;&#123;</span><br><span class="line">              pathname: <span class="string">&#x27;/profile&#x27;</span>,</span><br><span class="line">              state: <span class="built_in">this</span>.state.profile,</span><br><span class="line">            &#125;&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            我的</span><br><span class="line">          &lt;/NavLink&gt;</span><br><span class="line">          &lt;Link to=<span class="string">&quot;/about&quot;</span>&gt;关于&lt;/Link&gt;</span><br><span class="line">          &lt;Link to=&#123;<span class="string">`/article/<span class="subst">$&#123;<span class="built_in">this</span>.state.id&#125;</span>`</span>&#125;&gt;文章&lt;/Link&gt;</span><br><span class="line">          &#123;renderRoutes(routes)&#125;</span><br><span class="line">        &lt;/BrowserRouter&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>如果我们的路由存在嵌套</p>
<p>刚刚的路由表 就需要更改为如下 给需要嵌套的路由 加上 routes 属性</p>
<p>顺便提一下 对于需要精确匹配的路由 需要加上<code>exact:true</code>属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Address <span class="keyword">from</span> <span class="string">&#x27;../about/address&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Culture <span class="keyword">from</span> <span class="string">&#x27;../about/culture&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">default</span>: About &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../about&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">default</span>: Home &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../home&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">default</span>: Profile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../profile&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    exact: <span class="literal">true</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    component: About,</span><br><span class="line">    routes: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">&#x27;/about/address&#x27;</span>,</span><br><span class="line">        component: Address,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">&#x27;/about/culture&#x27;</span>,</span><br><span class="line">        component: Culture,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/profile&#x27;</span>,</span><br><span class="line">    component: Profile,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> routes;</span><br></pre></td></tr></table></figure>

<p>然后在对应的嵌套路由组件中 props 中会有一个 route 属性</p>
<p>在需要嵌套路由的组件中 我们就可以这样写</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Link, NavLink, Route &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; renderRoutes &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-config&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">About</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;culture组件:&#x27;</span>, props.route.routes);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">      &lt;p&gt;About&lt;/p&gt;</span><br><span class="line">      &lt;Link to=<span class="string">&quot;/about/culture&quot;</span>&gt;文化&lt;/Link&gt;</span><br><span class="line">      &lt;NavLink to=<span class="string">&quot;/about/address&quot;</span>&gt;地址&lt;/NavLink&gt;</span><br><span class="line">      &#123;<span class="comment">/* 因为不能将整张路由表放在这里 */</span>&#125;</span><br><span class="line">      &#123;renderRoutes(props.route.routes)&#125;</span><br><span class="line">    &lt;/BrowserRouter&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h2><p>如果我们在刚刚的 App 组件中 直接打印 props</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;App组件:&quot;</span>,<span class="built_in">this</span>.props)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">        &#123;renderRoutes(routes)&#125;</span><br><span class="line">      &lt;/BrowserRouter&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在控制台看到 它的 props 是一个空的对象</p>
<p>如果我们想在不是通过路由切换过来的组件中 获取到 history location match 这三个属性</p>
<p>这个时候就需要用到一个高阶组件 对我们的组件进行一层包裹</p>
<p>注意点 用 withRouter 导出的元素 需要包裹在<code>BrowserRouter</code>或<code>HashRouter</code>下</p>
<p>为了在一个文件下演示 将最后导出的代码 改造成如下</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyApp = withRouter(App);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AppWrapper</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;MyApp /&gt;</span><br><span class="line">      &lt;/BrowserRouter&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> _AppWrapper;</span><br></pre></td></tr></table></figure>

<h2 id="一些零碎点"><a href="#一些零碎点" class="headerlink" title="一些零碎点"></a>一些零碎点</h2><ul>
<li><p>如果想给选中的路由加样式 可以使用 NavLink 默认会给选中的样式加上 active class 如果想自定义这个 class 名字的话 可以使用 activeClassName</p>
</li>
<li><p>Link 和 NavLink 最终会被渲染成一个 a 元素 暂不支持 Vue 中 类似传入 type 可以渲染成其他元素</p>
</li>
<li><p>Redirect 可以实现路由的重定向 可以用作登录界面的判断</p>
</li>
<li><p>用 Switch 包裹的路由 会在匹配到第一个合适的路由后就停止匹配</p>
</li>
<li><p>React Router 中的 history 属性 和 window 对象下的 history 不一样 这是 React Router 进行包装后的合成对象</p>
</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React小册 -- 性能优化</title>
    <url>/FE/React/performance/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>本文主要讲解如下五个方法来做性能优化</p>
<ul>
<li><p>shouldComponentUpdate</p>
</li>
<li><p>memo</p>
</li>
<li><p>PureComponent</p>
</li>
<li><p>useMemo</p>
</li>
<li><p>useCallback</p>
</li>
</ul>
<p>先来说一下为什么要做性能优化 有哪些地方需要去做性能优化</p>
<p>我们知道组件通信是组件化之中不可缺少的内容 而一旦父组件更新了 那么子组件就必将更新</p>
<p>但是如果父组件更新的 props 不是子组件所需要的 这样每次父组件更新带来的子组件更新显然就是不必要的</p>
<p>本文的所有 demo 都使用 ts 来书写</p>
<h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><p>shouldComponentUpdate 接受两个参数 改变后的 props 和 state 返回值是一个 boolean 决定是否要更新数据</p>
<p>通过对比该生命周期的入参和该组件中实际需要的 props 和 state 有无改变就可以手动控制组件是否更新</p>
<p>demo 如下 父组件内部有两个状态 arr 和 str 子组件实际需要的只是 str 但是如果父组件更新了内部的 arr 也会带来子组件的更新</p>
<p>这个时候就可以在子组件内部使用该生命周期函数来优化性能</p>
<details yellow><summary> <p>ts shouldComponentUpdate</p> </summary>
              <div class='content'>
              <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Button, Tag &#125; from &#39;antd&#39;;</span><br><span class="line">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">interface IProps &#123;</span><br><span class="line">  arr?: Array&lt;number&gt;;</span><br><span class="line">  str?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IState &#123;</span><br><span class="line">  arr: Array&lt;number&gt;;</span><br><span class="line">  str: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Component&lt;IProps, Partial&lt;IState&gt;&gt; &#123;</span><br><span class="line">  constructor(props: IProps) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#39;子组件更新了&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps: IProps, nextState: IState) &#123;</span><br><span class="line">    if (nextProps.str &#x3D;&#x3D;&#x3D; this.props.str) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;子组件&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;h2&gt;&#123;this.props.str&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent extends Component&lt;IProps, IState&gt; &#123;</span><br><span class="line">  constructor(props: IProps) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      arr: [1, 2, 3],</span><br><span class="line">      str: &#39;hello&#39;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#39;父组件更新了&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;父组件&lt;&#x2F;h1&gt;</span><br><span class="line">        &#123;this.state.arr!.map((item, idx) &#x3D;&gt; &#123;</span><br><span class="line">          return &lt;Tag key&#x3D;&#123;idx&#125;&gt;&#123;item&#125;&lt;&#x2F;Tag&gt;;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &lt;Button</span><br><span class="line">          onClick&#x3D;&#123;() &#x3D;&gt;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">              arr: [...this.state.arr, this.state.arr.length + 1],</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &gt;</span><br><span class="line">          改变子组件不需要的属性</span><br><span class="line">        &lt;&#x2F;Button&gt;</span><br><span class="line">        &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; this.setState(&#123; str: &#39;world&#39; &#125;)&#125;&gt;</span><br><span class="line">          改变子组件需要的属性</span><br><span class="line">        &lt;&#x2F;Button&gt;</span><br><span class="line">        &lt;Child str&#x3D;&#123;this.state.str&#125; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Parent;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p>React 内部预制了该组件来帮助我们进行性能优化 理论上所有继承自 React.Component 的组件都可以改写成继承 PureComponent 来提升性能</p>
<p>但是需要注意的是 一旦你的组件继承自该组件 那么就不能在你的组件中 实现 shouldComponentUpdate 这个生命周期函数了 不然你大概会在控制台上看到 React 给你的警告了</p>
<p>PureComponent 会自动的去对比该组件前后的 props 有无更新 从而决定组件是否要更新</p>
<details yellow><summary> <p>ts PureComponent</p> </summary>
              <div class='content'>
              <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Button, Tag &#125; from &#39;antd&#39;;</span><br><span class="line">import React, &#123; Component, PureComponent &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">interface IProps &#123;</span><br><span class="line">  arr?: Array&lt;number&gt;;</span><br><span class="line">  str?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IState &#123;</span><br><span class="line">  arr: Array&lt;number&gt;;</span><br><span class="line">  str: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Component&lt;IProps, Partial&lt;IState&gt;&gt; &#123;</span><br><span class="line">  constructor(props: IProps) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#39;使用Component子组件更新了&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;子组件&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;h2&gt;&#123;this.props.str&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PureChild extends PureComponent&lt;IProps, Partial&lt;IState&gt;&gt; &#123;</span><br><span class="line">  constructor(props: IProps) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#39;使用PureComponent子组件更新了&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;子组件&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;h2&gt;&#123;this.props.str&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent extends Component&lt;IProps, IState&gt; &#123;</span><br><span class="line">  constructor(props: IProps) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      arr: [1, 2, 3],</span><br><span class="line">      str: &#39;hello&#39;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#39;父组件更新了&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;父组件&lt;&#x2F;h1&gt;</span><br><span class="line">        &#123;this.state.arr!.map((item, idx) &#x3D;&gt; &#123;</span><br><span class="line">          return &lt;Tag key&#x3D;&#123;idx&#125;&gt;&#123;item&#125;&lt;&#x2F;Tag&gt;;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &lt;Button</span><br><span class="line">          onClick&#x3D;&#123;() &#x3D;&gt;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">              arr: [...this.state.arr, this.state.arr.length + 1],</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &gt;</span><br><span class="line">          改变子组件不需要的属性</span><br><span class="line">        &lt;&#x2F;Button&gt;</span><br><span class="line">        &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; this.setState(&#123; str: &#39;world&#39; &#125;)&#125;&gt;</span><br><span class="line">          改变子组件需要的属性</span><br><span class="line">        &lt;&#x2F;Button&gt;</span><br><span class="line">        &lt;Child str&#x3D;&#123;this.state.str&#125; &#x2F;&gt;</span><br><span class="line">        &lt;PureChild str&#x3D;&#123;this.state.str&#125; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Parent;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="memo"><a href="#memo" class="headerlink" title="memo"></a>memo</h3><p>和上一个 PureComponent 一样 该方法用于函数式组件 demo 如下</p>
<details yellow><summary> <p>ts memo</p> </summary>
              <div class='content'>
              <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Button, Tag &#125; from &#39;antd&#39;;</span><br><span class="line">import React, &#123; useState, useEffect, memo &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">interface IProps &#123;</span><br><span class="line">  arr?: Array&lt;number&gt;;</span><br><span class="line">  str?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Child &#x3D; (props: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;不使用memo的子组件更新了&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;子组件&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;h2&gt;&#123;props.str&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const MemoChild &#x3D; memo((props: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;memo子组件更新了&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;子组件&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;h2&gt;&#123;props.str&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const Parent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [str, setStr] &#x3D; useState&lt;string&gt;(&#39;hello&#39;);</span><br><span class="line">  const [arr, setArr] &#x3D; useState&lt;Array&lt;number&gt;&gt;([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;父组件更新了&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;父组件&lt;&#x2F;h1&gt;</span><br><span class="line">      &#123;arr.map((item, idx) &#x3D;&gt; &#123;</span><br><span class="line">        return &lt;Tag key&#x3D;&#123;idx&#125;&gt;&#123;item&#125;&lt;&#x2F;Tag&gt;;</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setArr([...arr, arr.length + 1])&#125;&gt;</span><br><span class="line">          改变子组件不需要的属性</span><br><span class="line">        &lt;&#x2F;Button&gt;</span><br><span class="line">        &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setStr(&#39;world&#39;)&#125;&gt;改变子组件需要的属性&lt;&#x2F;Button&gt;</span><br><span class="line">        &lt;Child str&#x3D;&#123;str&#125; &#x2F;&gt;</span><br><span class="line">        &lt;MemoChild str&#x3D;&#123;str&#125; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Parent;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p>接着来说 memo 我们知道对象是引用数据类型 任意两个不指向同一个地址的两个对象进行对比都会返回 false</p>
<p>所以如果子组件接受了来自父组件的属性是一个对象 那么不管如何 每当父组件更新 子组件都会跟着更新</p>
<p>因为 memo 在每次对比前后 props 时 总会返回 false 这个时候就需要使用 useMemo 来对这个对象进行包装了</p>
<p>useMemo 接收两个参数</p>
<ul>
<li><p>第一个参数 是一个函数 返回一个对象</p>
</li>
<li><p>第二个参数 是一个数组 包含了这个对象的依赖项 只有依赖项更新 函数才会重新执行 从而去更新这个对象</p>
</li>
</ul>
<p>demo 如下</p>
<details yellow><summary> <p>ts memo</p> </summary>
              <div class='content'>
              <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Button &#125; from &#39;antd&#39;;</span><br><span class="line">import React, &#123; useState, useMemo, memo &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">interface IProps &#123;</span><br><span class="line">  age?: number;</span><br><span class="line">  stu?: &#123; name: string; age: number &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接收的是基本数据类型 memo生效</span><br><span class="line">const Child &#x3D; memo((&#123; age &#125;: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;props为基本数据类型的子组件渲染了&#39;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;props为基本数据类型&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;h2&gt;age:&#123;age&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 父组件中没有使用useMemo 子组件的memo失效</span><br><span class="line">const Child1 &#x3D; memo((&#123; stu &#125;: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;props为引用数据类型 未使用useMemo&#39;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;props为引用数据类型 未使用useMemo&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;h2&gt;</span><br><span class="line">        &#123;stu?.name&#125;:&#123;stu?.age&#125;</span><br><span class="line">      &lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 父组件中使用了useMemo 子组件的memo生效</span><br><span class="line">const Child2 &#x3D; memo((&#123; stu &#125;: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;props为引用数据类型 使用useMemo&#39;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;props为引用数据类型 使用useMemo&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;h2&gt;</span><br><span class="line">        &#123;stu?.name&#125;:&#123;stu?.age&#125;</span><br><span class="line">      &lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const Parent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line">  const [age, setAge] &#x3D; useState(18);</span><br><span class="line">  const [name, setName] &#x3D; useState(&#39;lucky&#39;);</span><br><span class="line"></span><br><span class="line">  const stu1 &#x3D; &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const stu2 &#x3D; useMemo(</span><br><span class="line">    () &#x3D;&gt; (&#123;</span><br><span class="line">      name,</span><br><span class="line">      age,</span><br><span class="line">    &#125;),</span><br><span class="line">    [age]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Child age&#x3D;&#123;age&#125; &#x2F;&gt;</span><br><span class="line">      &lt;Child1 stu&#x3D;&#123;stu1&#125; &#x2F;&gt;</span><br><span class="line">      &lt;Child2 stu&#x3D;&#123;stu2&#125; &#x2F;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;count&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;change count&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setAge(age + 1)&#125;&gt;change age&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setName(&#39;lucky chou&#39;)&#125;&gt;change name&lt;&#x2F;Button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Parent;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>和 useMemo 类似 该 hook 用来做 props 为函数时的性能优化 避免每次都重新执行该函数</p>
<p>demo 如下</p>
<details yellow><summary> <p>ts memo</p> </summary>
              <div class='content'>
              <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Button &#125; from &#39;antd&#39;;</span><br><span class="line">import React, &#123; useState, useCallback, memo &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">interface IProps &#123;</span><br><span class="line">  getSum: () &#x3D;&gt; number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Child1 &#x3D; memo((&#123; getSum &#125;: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;我是子组件 在父组件中没使用useCallback&#39;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;getSum&#125;&gt;没使用useCallback&lt;&#x2F;Button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const Child2 &#x3D; memo((&#123; getSum &#125;: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;我是子组件 在父组件中使用了useCallback&#39;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;getSum&#125;&gt;使用了useCallback&lt;&#x2F;Button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const Parent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [num, setNum] &#x3D; useState(0);</span><br><span class="line">  const [max, setMax] &#x3D; useState(100);</span><br><span class="line"></span><br><span class="line">  const getSum1 &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;getSum1方法执行了&#39;);</span><br><span class="line">    let sum &#x3D; 0;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; max; i++) &#123;</span><br><span class="line">      sum +&#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const getSum2 &#x3D; useCallback(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;getSum2方法执行了&#39;);</span><br><span class="line">    let sum &#x3D; 0;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; max; i++) &#123;</span><br><span class="line">      sum +&#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;, [max]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;sum : &#123;getSum1()&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;sum : &#123;getSum2()&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;num : &#123;num&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setNum(num + 1)&#125;&gt;change num&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setMax((pre) &#x3D;&gt; pre * 2)&#125;&gt;change max&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Child1 getSum&#x3D;&#123;getSum1&#125; &#x2F;&gt;</span><br><span class="line">      &lt;Child2 getSum&#x3D;&#123;getSum2&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Parent;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React小册 -- redux中间件 redux-thunk / redux-saga</title>
    <url>/FE/React/middleware/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>redux 中的数据流大致是</p>
<p>UI —————&gt; action（plain）—————&gt; reducer —————&gt; state —————&gt; UI</p>
<p>action 是一个原始 js 对象（plain object）且 reducer 是一个纯函数</p>
<p><strong>但是如果存在副作用，比如 ajax 异步请求等等，那么应该怎么做？</strong></p>
<a id="more"></a>

<p>我们需要实现的功能也很简单 就是继续上一讲的 demo 完善 article 中的 reducer</p>
<p>article 组件中派发一个 get_list 的 action 然后我们需要在 store 中更新网络请求回来后的 lists</p>
<p>首先我们在 reducer 中处理网络请求看看行不行的通</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> TYPES <span class="keyword">from</span> <span class="string">&#x27;./actionTypes&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; IAction &#125; <span class="keyword">from</span> <span class="string">&#x27;@type/index&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> API <span class="keyword">from</span> <span class="string">&#x27;@utils/api&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  list: [],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = defaultState, <span class="attr">action</span>: IAction) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> TYPES.GET_LIST: &#123;</span><br><span class="line">      API.getList().then(<span class="function">(<span class="params">list</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(list);</span><br><span class="line">        <span class="keyword">return</span> &#123; ...state, list &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过点击按钮 我们确实可以看到控制台上打印出了 我们在 reducer 中发送网络请求后的打印语句</p>
<p>但是查看 devtools 我们会发现 store 并没有更新</p>
<p>也就是说 reducer 中所有改变 store 的方法走的都是同步的代码</p>
<p>这也不难理解 因为这会让我们的 store 变的更加可控 它不会因为异步操作的某个回掉函数在不知道什么时候改变了 store</p>
<p>但是 如果我们就是要发送请求 针对这种场景 我们该如果去实现呢</p>
<p>这个时候就可以引入中间件来帮助我们完成异步操作</p>
<p>redux 增加中间件处理副作用后的数据流大致如下</p>
<p>UI —————&gt; action(side function) —————&gt; middleware —————&gt; action(plain) —————&gt; reducer —————&gt; state —————&gt; UI</p>
<p>本文就主要介绍两种中间件 <strong>redux-thunk</strong> 和 <strong>redux-saga</strong></p>
<h3 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>store 下的入口文件 index</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, combineReducers, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">&#x27;./home/reducers&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> article <span class="keyword">from</span> <span class="string">&#x27;./article/reducers&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">  home,</span><br><span class="line">  article,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> composeEnhancers = <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> enhancer = composeEnhancers(applyMiddleware(thunkMiddleware));</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(rootReducer, enhancer);</span><br></pre></td></tr></table></figure>

<p>然后是 actionCreators</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是箭头函数的语法 用来返回一个对象</span></span><br><span class="line">() =&gt; (&#123;&#125;)</span><br><span class="line"><span class="comment">// 如果不使用简写 就需要写成如下这种样子 这两种写法是等价的</span></span><br><span class="line">() =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ACTIONS <span class="keyword">from</span> <span class="string">&#x27;./actionTypes&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> API <span class="keyword">from</span> <span class="string">&#x27;@utils/api&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Dispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getList = <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  <span class="keyword">type</span>: ACTIONS.GET_LIST,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setList = <span class="function">(<span class="params">list: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="keyword">type</span>: ACTIONS.SET_LIST,</span><br><span class="line">  list,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getListSync = <span class="function">(<span class="params">list: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="keyword">type</span>: ACTIONS.GET_LIST_ASYNC,</span><br><span class="line">  list,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getListAsync = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; list &#125; = <span class="keyword">await</span> API.getList();</span><br><span class="line">    dispatch(getListSync(list));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其他所有地方都按正常使用即可 在组件内我们使用的是进行了异步操作的那个函数</p>
<p>通过 thunk 我们可以在 dispatch 前拦截 action</p>
<p>然后进行网络请求等异步操作 最后让 action 带上我们需要的数据 变成原始的 action(plain object) 再 dispatch 出去</p>
<p>但是这种方法的缺点也很明显 就是将异步请求的操作和 actionCreator 杂糅在了一起</p>
<p>对于每一个需要异步操作的 action 我们都需要在 actionCreator 中写一个对应的函数 这样会使 actionCreator 变的越来越大 不易于管理</p>
<p>所以对应的 又有一种中间件 <strong>saga</strong></p>
<h3 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h3><p>在 saga 中 side effect 都移到了 saga.js 文件中 不再和 actionCreator 杂糅在一起</p>
<p>例如如下 saga.js 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; takeEvery, put &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getName &#125; <span class="keyword">from</span> <span class="string">&#x27;./actionCreators&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行副作用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fetchGetName</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">yield</span> axios.get(<span class="string">&#x27;/__mock__.json&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> name = res.data.data;</span><br><span class="line">  <span class="keyword">yield</span> put(getName(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听GET_NAME_VALUE action 在dispatch前执行fetchGetName 最后包装成原始action</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">mySaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> takeEvery(<span class="string">&#x27;GET_NAME_VALUE_ASYNC&#x27;</span>, fetchGetName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> mySaga;</span><br></pre></td></tr></table></figure>

<p>我们的 actionCreator 还是纯净的文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; GET_NAME_VALUE &#125; <span class="keyword">from</span> <span class="string">&#x27;./actionTypes&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getName = <span class="function">(<span class="params">name</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: GET_NAME_VALUE,</span><br><span class="line">  name,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>再来看看 saga 怎么和 store 建立联系</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware, compose &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> createSagaMiddleware <span class="keyword">from</span> <span class="string">&#x27;redux-saga&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> mySaga <span class="keyword">from</span> <span class="string">&#x27;./sagas&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> composeEnhancers = <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sagaMiddleware = createSagaMiddleware();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> enhancer = composeEnhancers(applyMiddleware(sagaMiddleware));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, enhancer);</span><br><span class="line"></span><br><span class="line">sagaMiddleware.run(mySaga);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<p>注意 触发 action 和触发 saga 的 type 不能同名 不然会导致 saga 一直执行 action</p>
<p>然后在业务组件中 我们 dispatch 的 type 应是 saga 对应的 type</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React小册 -- js基础</title>
    <url>/FE/React/js/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li><p>你需要知道的一些 JS 知识</p>
</li>
<li><p>JSX</p>
<ul>
<li><p>JSX 本质</p>
</li>
<li><p>事件绑定 （this）</p>
</li>
<li><p>条件渲染</p>
</li>
<li><p>列表渲染</p>
</li>
<li><p>注意点</p>
</li>
</ul>
</li>
<li><p>ReactElement</p>
</li>
</ul>
<a id="more"></a>

<h2 id="你需要知道的一些-JS-知识"><a href="#你需要知道的一些-JS-知识" class="headerlink" title="你需要知道的一些 JS 知识"></a>你需要知道的一些 JS 知识</h2><h3 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h3><p>函数这一块 我们主要需要掌握的就是箭头函数</p>
<p>因为在类组件中 我们总是不可避免的需要使用到 this 绑定</p>
<p>而 this 相关的操作总是或多或少的存在麻烦</p>
<p>但是箭头函数 有一个特性 其内部没有 this 会沿着作用域链往上级作用域查找 所以就绕开了 this 绑定的问题</p>
<p>简单对比一下普通函数和匿名函数</p>
<h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><ul>
<li><p><strong>谁调用函数 this 就指向谁 this 的指向只有在编译期间才能被确认</strong></p>
</li>
<li><p><strong>函数 和 变量 会自动变成全局对象 window 的方法和属性</strong></p>
</li>
<li><p><strong>所以函数的内部的 this 指向全局对象 window</strong></p>
</li>
</ul>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><ul>
<li><p><strong>箭头函数内的 this，就是箭头函数被定义时所在作用域的 this</strong></p>
</li>
<li><p><strong>不受 apply 等方法修改</strong></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo,</span><br><span class="line">  bar,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// window 在定义时就确认了</span></span><br><span class="line">obj.bar(); <span class="comment">// obj 在编译期发现是obj在调用bar</span></span><br></pre></td></tr></table></figure>

<h3 id="数组相关"><a href="#数组相关" class="headerlink" title="数组相关"></a>数组相关</h3><p>数组这一块 我们需要掌握的常用 API 有</p>
<ul>
<li><p><code>Array.prototype.map(item,index,array)</code></p>
<ul>
<li>我们在列表渲染时 需要依赖此 API 来生成每一个结点</li>
</ul>
</li>
<li><p><code>Array.prototype.slice([begin[, end]])</code></p>
<ul>
<li>state 中的状态 我们是不可以修改的 只能用新状态去覆盖旧状态 对于数组 我们就可以使用这个 API 来拷贝一个新状态 同理还有 concat 等也可 (这些方法都只能深拷贝第一层)</li>
</ul>
</li>
<li><p>其他的高阶用法可以参考 MDN 或者我的 JS 小册(TODO)</p>
</li>
</ul>
<h3 id="对象相关"><a href="#对象相关" class="headerlink" title="对象相关"></a>对象相关</h3><ul>
<li><p>同样的对于 状态中的对象 我们也不能直接修改 可以用<code>Object.assign(target, ...sources)</code>来拷贝一个新状态(也只能深拷贝第一层)</p>
</li>
<li><p>对象字面量 写法</p>
<ul>
<li>如果对象的键值名字相同 在赋值的时候 可以只写一个</li>
</ul>
</li>
<li><p>对象解构</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = &#123;</span><br><span class="line">  case1: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">  case2: <span class="string">&#x27;C&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; case1, case2 &#125; = result;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(case1); <span class="comment">// A</span></span><br><span class="line"><span class="built_in">console</span>.log(case2); <span class="comment">// C</span></span><br></pre></td></tr></table></figure>

<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>主要需要掌握的是 ES6 的导入/导出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tools.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getParam</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 一个模块中 只允许使用一个默认导出</span></span><br><span class="line"><span class="comment">// 默认导出的模块可以自定义名字 其他的必须与导出的名称一致</span></span><br><span class="line"><span class="keyword">import</span> getAge, &#123;getName,getParam&#125; <span class="keyword">from</span> tools</span><br></pre></td></tr></table></figure>

<h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><p>如果我们要使用 JSX 语法</p>
<p>我们需要在项目中引入</p>
<ul>
<li><p><code>&lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;</code></p>
</li>
<li><p><code>&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;</code></p>
<ul>
<li>将组件挂载到根节点上进行渲染</li>
</ul>
</li>
<li><p><code>&lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt;</code></p>
<ul>
<li>将 JSX 语法转换为 React.createElement</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意：在需要使用 babel 的 script 内 加上 style=”text/babel”</strong></p>
</blockquote>
<h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><h4 id="JSX-语法本质"><a href="#JSX-语法本质" class="headerlink" title="JSX 语法本质"></a>JSX 语法本质</h4><p>JSX 是 JS 的语法扩展 不能被浏览器直接执行 需要使用 babel 编译后 才可以在浏览器中正常执行</p>
<p>JSX 在 React 中用来描述用户界面 最终被 babel 编译为<code>React.createElement(type,attrs,children)</code></p>
<ul>
<li><p>type：用于标识节点的类型。它可以是类似“h1”“div”这样的标准 HTML 标签字符串，也可以是 React 组件类型或 React fragment 类型。</p>
</li>
<li><p>config：以对象形式传入，组件所有的属性都会以键值对的形式存储在 config 对象中。</p>
</li>
<li><p>children：以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的“子节点”“子元素”。</p>
</li>
</ul>
<p>所以 JSX 本质是只是一种语法糖 最终还是被转化为了<code>React.createElement</code></p>
<p>我们可以在<a href="https://www.babeljs.cn/repl#?browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=DwEwlgbgBAxgNgQwM5ILwCIAWBTBJsBO6AfAFACQoksiKGALmPXNiQCpMvAD04EZPPsSA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=es2015%2Creact%2Cstage-2&prettier=false&targets=&version=7.12.3&externalPlugins=">babel</a>官网中 查看 JSX 最终被编译成了什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;header&quot;</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;title&quot;</span>&gt;Title&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经babel转换后</span></span><br><span class="line">(<span class="string">&#x27;use strict&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*#__PURE__*/</span></span><br><span class="line">React.createElement(</span><br><span class="line">  <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    class: &#x27;header&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/*#__PURE__*/</span> React.createElement(</span><br><span class="line">    <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      class: &#x27;title&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;Title&#x27;</span></span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>createElement 中并没有十分复杂的涉及算法或真实 DOM 的逻辑，它的每一个步骤几乎都是在格式化数据</p>
<p>最后将格式化后的数据交给 React.render 来处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="comment">// 需要渲染的元素（ReactElement）</span></span><br><span class="line">  element,</span><br><span class="line">  <span class="comment">// 元素挂载的目标容器（一个真实DOM）</span></span><br><span class="line">  container,</span><br><span class="line">  <span class="comment">// 回调函数，可选参数，可以用来处理渲染结束后的逻辑</span></span><br><span class="line">  [callback]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="JSX-表达式"><a href="#JSX-表达式" class="headerlink" title="JSX 表达式"></a>JSX 表达式</h4><p>JSX 在<code>&#123;&#125;</code>中使用我们的 JS 表达式</p>
<p>在里面 我们可以使用变量 进行运算符的操作 调用方法 等等</p>
<h4 id="JSX-注释"><a href="#JSX-注释" class="headerlink" title="JSX 注释"></a>JSX 注释</h4><p>JSX 有特殊的注释方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;header&quot;</span>&gt;</span><br><span class="line">  &#123;<span class="comment">/* 我是注释 */</span>&#125;</span><br><span class="line">  我是头部</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="特殊点"><a href="#特殊点" class="headerlink" title="特殊点"></a>特殊点</h4><ul>
<li><p>由于 JSX 是 JS 的语法扩展 但是在里面我们又可以书写类似 HTML 的东西 所以为了避免冲突</p>
<ul>
<li><p>HTML 中 class 在 JS 中表示类 在 JSX 中 我们用<strong>className</strong>来代替</p>
</li>
<li><p>HTML 中 label 标签的 for 在 JS 中表示循环 在 JSX 中用<strong>htmlFor</strong>来代替</p>
</li>
</ul>
</li>
<li><p>undefined / boolean / null</p>
<ul>
<li><p>对于以上几种数据类型 JSX 不会将其渲染到页面上</p>
</li>
<li><p>利用这个特性 我们可以实现条件渲染</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">&lt;div&gt;&#123;flag &amp;&amp; <span class="string">&quot;欢迎回来~~~&quot;</span>&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="JSX-列表渲染"><a href="#JSX-列表渲染" class="headerlink" title="JSX 列表渲染"></a>JSX 列表渲染</h4><p>这一块主要使用到了数组的高阶函数 map</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _games = [<span class="string">&#x27;剑盾&#x27;</span>, <span class="string">&#x27;塞尔达&#x27;</span>, <span class="string">&#x27;马里奥制造&#x27;</span>, <span class="string">&#x27;风花雪月&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> gamesUI = _games.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div key=&#123;index&#125;&gt;&#123;item&#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    ReactDOM.render(gamesUI, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果在脚手架中 我们可以书写成如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Movies</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      games: [<span class="string">&#x27;剑盾&#x27;</span>, <span class="string">&#x27;塞尔达&#x27;</span>, <span class="string">&#x27;马里奥制造&#x27;</span>, <span class="string">&#x27;风花雪月&#x27;</span>],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; games &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> games.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JSX-事件绑定"><a href="#JSX-事件绑定" class="headerlink" title="JSX 事件绑定"></a>JSX 事件绑定</h4><p>这一块是类组件中的重点 因为我们总是难免要使用到 this</p>
<p>开始吧 我们用一个计数器来开始我们的第一个 React 事件绑定</p>
<p>首先 构建我们的 UI</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      counter: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; counter &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;&#123;counter&#125;&lt;/div&gt;</span><br><span class="line">        &lt;button&gt;+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter;</span><br></pre></td></tr></table></figure>

<p>然后我们分别通过</p>
<ul>
<li><p>普通函数</p>
</li>
<li><p>匿名函数</p>
</li>
</ul>
<p>来绑定事件 并打印出内部的 this 指向</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>)&#125;&#125;&gt;+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">&lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>)&#125;&#125;&gt;+<span class="number">1</span>&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>其结果分别是</p>
<ul>
<li><p><code>undefined</code></p>
</li>
<li><p><code>Counter &#123;props: &#123;…&#125;, context: &#123;…&#125;, refs: &#123;…&#125;, updater: &#123;…&#125;, state: &#123;…&#125;, …&#125;</code></p>
</li>
</ul>
<p>通过打印的结果 我们就有了两种 解决 this 指向的方法</p>
<ul>
<li><p>通过 bind 来改变 this 指向</p>
</li>
<li><p>直接使用匿名函数</p>
</li>
</ul>
<p>以下是两种方法的完整代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      counter: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.increment = <span class="built_in">this</span>.increment.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; counter &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;&#123;counter&#125;&lt;/div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.increment&#125;&gt;+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.increment();</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          +<span class="number">1</span></span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      counter: <span class="built_in">this</span>.state.counter + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>手动搭建一个 React / Vue 项目</title>
    <url>/FE/Tools/webpack-react-vue/</url>
    <content><![CDATA[<p>项目地址：<a href="https://github.com/LuckyChou710/ReStart-FE/tree/main/webpack-demo">https://github.com/LuckyChou710/ReStart-FE/tree/main/webpack-demo</a></p>
<details yellow><summary> <p>React dev</p> </summary>
              <div class='content'>
              <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  template: path.resolve(__dirname, <span class="string">&#x27;../public/index.html&#x27;</span>),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  entry: path.resolve(__dirname, <span class="string">&#x27;../src/index.js&#x27;</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;../build&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;js/[name].[hash].bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(mjs|js|jsx)$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;babel-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [htmlWebpackPlugin],</span><br><span class="line"></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">&#x27;.mjs&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details yellow><summary> <p>React prod</p> </summary>
              <div class='content'>
              <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  template: path.resolve(__dirname, <span class="string">&#x27;../public/index.html&#x27;</span>),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">&#x27;production&#x27;</span>, <span class="comment">// 和开发环境下的配置只是修改了 mode</span></span><br><span class="line">  entry: path.resolve(__dirname, <span class="string">&#x27;../src/index.js&#x27;</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;../build&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;js/[name].[hash].bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(mjs|js|jsx)$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;babel-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [htmlWebpackPlugin, <span class="keyword">new</span> CleanWebpackPlugin()],</span><br><span class="line"></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">&#x27;.mjs&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details yellow><summary> <p>Vue dev</p> </summary>
              <div class='content'>
              <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader/lib/plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  template: path.resolve(__dirname, <span class="string">&#x27;../public/index.html&#x27;</span>),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  entry: path.resolve(__dirname, <span class="string">&#x27;../main.js&#x27;</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;../build&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;js/[name].[hash].bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;vue-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [htmlWebpackPlugin, <span class="keyword">new</span> VueLoaderPlugin()],</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.css&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      vue$: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details yellow><summary> <p>Vue prod</p> </summary>
              <div class='content'>
              <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader/lib/plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  template: path.resolve(__dirname, <span class="string">&#x27;../public/index.html&#x27;</span>),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">&#x27;production&#x27;</span>, <span class="comment">// 和开发环境下的配置只是修改了 mode</span></span><br><span class="line">  entry: path.resolve(__dirname, <span class="string">&#x27;../main.js&#x27;</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;../build&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;js/[name].[hash].bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;vue-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [htmlWebpackPlugin, <span class="keyword">new</span> CleanWebpackPlugin(), <span class="keyword">new</span> VueLoaderPlugin()],</span><br><span class="line"></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">&#x27;.vue&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
              </div>
            </details>


<details yellow><summary> <p>package.json</p> </summary>
              <div class='content'>
              <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;webpack-demo&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;MIT&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@babel/core&quot;</span>: <span class="string">&quot;^7.13.16&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@babel/preset-env&quot;</span>: <span class="string">&quot;^7.13.15&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@babel/preset-react&quot;</span>: <span class="string">&quot;^7.13.13&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-loader&quot;</span>: <span class="string">&quot;^8.2.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;clean-webpack-plugin&quot;</span>: <span class="string">&quot;^4.0.0-alpha.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;html-webpack-plugin&quot;</span>: <span class="string">&quot;4.5.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react&quot;</span>: <span class="string">&quot;^17.0.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react-dom&quot;</span>: <span class="string">&quot;^17.0.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vue&quot;</span>: <span class="string">&quot;^2.6.12&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vue-loader&quot;</span>: <span class="string">&quot;^15.9.6&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vue-template-compiler&quot;</span>: <span class="string">&quot;^2.6.12&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span>: <span class="string">&quot;4.44.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-cli&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^3.11.2&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start:react&quot;</span>: <span class="string">&quot;webpack-dev-server --config  ./react/config/webpack.config.dev.js --open&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build:react&quot;</span>: <span class="string">&quot;webpack --config ./react/config/webpack.config.prod.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start:vue&quot;</span>: <span class="string">&quot;webpack-dev-server --config  ./vue/config/webpack.config.dev.js --open&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build:vue&quot;</span>: <span class="string">&quot;webpack --config ./vue/config/webpack.config.prod.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>npm和yarn命令对比 （速查）</title>
    <url>/FE/Tools/yarn&amp;npm/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">yarn</th>
<th align="center">npm</th>
<th align="left">命令功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong><code>yarn install</code></strong></td>
<td align="center"><strong><code>npm install</code></strong></td>
<td align="left"><strong>根据<code>pack.json</code>安装项目所需的依赖包</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn install --flat</code></strong></td>
<td align="center"><strong><code>--</code></strong></td>
<td align="left"><strong>注释 1</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn install --no-lockfile</code></strong></td>
<td align="center"><strong><code>npm install --no-package-lock</code></strong></td>
<td align="left"><strong>不读取或生成<code>yarn.lock</code>锁文件</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn install --pure-lockfile</code></strong></td>
<td align="center"><strong><code>--</code></strong></td>
<td align="left"><strong>不要生成<code>yarn.lock</code>锁文件</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn add [package]</code></strong></td>
<td align="center"><strong><code>npm install [package]</code></strong></td>
<td align="left"><strong>安装需要的依赖包</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn add [package] --dev</code></strong></td>
<td align="center"><strong><code>npm install [package] --save-dev</code></strong></td>
<td align="left"><strong>注释 2</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn add [package] --D</code></strong></td>
<td align="center"><strong><code>npm install [package] --save-dev</code></strong></td>
<td align="left"><strong>同上</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn add [package] --peer</code></strong></td>
<td align="center"><strong><code>--</code></strong></td>
<td align="left"><strong>注释 3</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn add [package] --P</code></strong></td>
<td align="center"><strong><code>--</code></strong></td>
<td align="left"><strong>同上</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn add [package] --optional</code></strong></td>
<td align="center"><strong><code>npm install [package] --save-optional</code></strong></td>
<td align="left"><strong>注释 4</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn add [package] --O</code></strong></td>
<td align="center"><strong><code>npm install [package] --save-optional</code></strong></td>
<td align="left"><strong>同上</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn add [package] --exact</code></strong></td>
<td align="center"><strong><code>npm install [package] --save-exact</code></strong></td>
<td align="left"><strong>注释 5</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn add [package] --E</code></strong></td>
<td align="center"><strong><code>npm install [package] --save-exact</code></strong></td>
<td align="left"><strong>同上</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn global add [package]</code></strong></td>
<td align="center"><strong><code>npm install [package] --global</code></strong></td>
<td align="left"><strong>全局安装依赖包</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn global upgrade</code></strong></td>
<td align="center"><strong><code>npm update --global</code></strong></td>
<td align="left"><strong>全局更新依赖包</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn add --force</code></strong></td>
<td align="center"><strong><code>npm rebuild</code></strong></td>
<td align="left"><strong>更改包内容后进行重建</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn remove [package]</code></strong></td>
<td align="center"><strong><code>npm uninstall [package]</code></strong></td>
<td align="left"><strong>卸载已经安装的依赖包</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn cache clean [package]</code></strong></td>
<td align="center"><strong><code>npm cache clean</code></strong></td>
<td align="left"><strong>注释 6</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn upgrade</code></strong></td>
<td align="center"><strong><code>rm -rf node_modules &amp;&amp; npm install</code></strong></td>
<td align="left"><strong>更新依赖包</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn version --major</code></strong></td>
<td align="center"><strong><code>npm version major</code></strong></td>
<td align="left"><strong>更新依赖包的版本</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn version --minor</code></strong></td>
<td align="center"><strong><code>npm version minor</code></strong></td>
<td align="left"><strong>更新依赖包的版本</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn version --patch</code></strong></td>
<td align="center"><strong><code>npm version patch</code></strong></td>
<td align="left"><strong>更新依赖包的版本</strong></td>
</tr>
<tr>
<td align="center"><strong><code>yarn config set registry</code></strong></td>
<td align="center"><strong><code>npm config set registry</code></strong></td>
<td align="left"><strong>修改源</strong></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 类</title>
    <url>/FE/TS/class/</url>
    <content><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">move</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;moving&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Dog(<span class="string">&quot;哈士奇&quot;</span>).move()</span><br></pre></td></tr></table></figure>


<a id="more"></a>

<h2 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 公有属性 所有地方都可访问 默认在不声明的情况下 都是public</span></span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span></span><br><span class="line">  <span class="comment">// 私有属性 只有在声明类的内部才可以访问</span></span><br><span class="line">  <span class="keyword">private</span> color: <span class="built_in">string</span></span><br><span class="line">  <span class="comment">// 受保护的属性 只有在声明类及其子类才可以访问</span></span><br><span class="line">  <span class="keyword">protected</span> weight: <span class="built_in">number</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, color: <span class="built_in">string</span>, weight: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.color = color</span><br><span class="line">    <span class="built_in">this</span>.weight = weight</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">bark</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 声明类内部 所有属性都可以访问</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27; , &#x27;</span> + <span class="built_in">this</span>.color + <span class="built_in">this</span>.weight)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在外部 只能访问 public 修饰的属性 bark 没有修饰符 默认为public</span></span><br><span class="line"><span class="keyword">new</span> Pet(<span class="string">&#x27;哈士奇&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="number">10</span>).bark()</span><br><span class="line"><span class="keyword">new</span> Pet(<span class="string">&#x27;哈士奇&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="number">10</span>).name = <span class="string">&#x27;蓝色哈士奇&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, color: <span class="built_in">string</span>, weight: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, color, weight)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">bark</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 子类中 color无法访问 因为color是父类的私有属性 但是可以访问到父类受保护的属性weight</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27; , &#x27;</span> + <span class="built_in">this</span>.weight)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="readonly修饰符"><a href="#readonly修饰符" class="headerlink" title="readonly修饰符"></a>readonly修饰符</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">readonly</span> name: <span class="built_in">string</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法分配到 &quot;name&quot; ，因为它是只读属性</span></span><br><span class="line"><span class="comment">// new Pet(&quot;哈士奇&quot;).name = &quot;二哈&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是可以读取</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Pet(<span class="string">&#x27;哈士奇&#x27;</span>).name)</span><br></pre></td></tr></table></figure>

<h2 id="存取器-setter-getter"><a href="#存取器-setter-getter" class="headerlink" title="存取器 setter getter"></a>存取器 setter getter</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">fullName</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">fullName</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;set&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Pet(<span class="string">&#x27;dog&#x27;</span>)</span><br><span class="line">dog.fullName = <span class="string">&#x27;lucky&#x27;</span> <span class="comment">// set</span></span><br><span class="line">dog.fullName <span class="comment">// get</span></span><br></pre></td></tr></table></figure>

<h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>静态属性 不需要实例化对象后再使用 直接用类名调用即可</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">move</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;moving&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pet.move()</span><br></pre></td></tr></table></figure>

<h2 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类 abstract"></a>抽象类 abstract</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// abstract声明的方法必须在实现类中实现它</span></span><br><span class="line">  <span class="keyword">abstract</span> bark(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name)</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  bark(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="把类当做接口使用"><a href="#把类当做接口使用" class="headerlink" title="把类当做接口使用"></a>把类当做接口使用</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point3d <span class="keyword">extends</span> Point &#123;</span><br><span class="line">  z: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 接口</title>
    <url>/FE/TS/interface/</url>
    <content><![CDATA[<details yellow><summary> <p>ts interface</p> </summary>
              <div class='content'>
              <figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口</span></span><br><span class="line"><span class="comment"> * 对行为的抽象</span></span><br><span class="line"><span class="comment"> * 定义的变量必须和接口中的变量一致 不能多也不能少</span></span><br><span class="line"><span class="comment"> * 类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 可选属性 ?</span></span><br><span class="line"><span class="comment"> * 只读属性 readonly</span></span><br><span class="line"><span class="comment"> * 继承接口 extends</span></span><br><span class="line"><span class="comment"> * 类实现接口 implements</span></span><br><span class="line"><span class="comment"> * 可索引的类型</span></span><br><span class="line"><span class="comment"> * 混合类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  height?: <span class="built_in">string</span>; <span class="comment">// 可选属性</span></span><br><span class="line">  <span class="keyword">readonly</span> gender: <span class="built_in">string</span>; <span class="comment">// 只读属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> chou: Person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承接口</span></span><br><span class="line"><span class="keyword">interface</span> Student <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  sno: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu: Student = &#123;</span><br><span class="line">  name: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">  sno: <span class="string">&#x27;001&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实现接口</span></span><br><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">  add(x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myCounter</span> <span class="title">implements</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  add(x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可索引的类型</span></span><br><span class="line"><span class="comment">// 表示用number索引去访问属性时 会返回string类型</span></span><br><span class="line"><span class="comment">// 例如 arr = [&#x27;chou&#x27;] arr[0] = &#x27;chou&#x27;</span></span><br><span class="line"><span class="comment">// ts支持两种索引类型 string和number 但是数字索引的返回值必须是字符串索引返回值类型的子类型</span></span><br><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>React In TypeScript</title>
    <url>/FE/TS/react-ts/</url>
    <content><![CDATA[<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx create-react-app my-app --typescript</span><br><span class="line">yarn create react-app my-app --typescript</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h2><p>create-react-app将webpack配置文件隐藏起来了</p>
<p>如果想使用webpack配置文件的话 需要使用eject命令 将这些配置文件暴露出来 但是这是一个不可逆的操作 使用前需要谨慎</p>
<p>随后在我们就可以看到一个config文件夹 </p>
<p>找到文件夹下的<code>webpack.config.js</code>文件</p>
<p>在alias下就是我们的别名配置</p>
<p>例如我们可以插入以下几行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">      ...(modules.webpackAliases || &#123;&#125;),</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: path.resolve(__dirname, <span class="string">&#x27;../src&#x27;</span>),</span><br><span class="line">      <span class="string">&#x27;@store&#x27;</span>: <span class="string">&quot;@/store&quot;</span>,</span><br><span class="line">      <span class="string">&#x27;@components&#x27;</span>: <span class="string">&quot;@/components&quot;</span>,</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>随后在根目录下找到<code>tsconfig.json</code>文件</p>
<p>在里面做上对应的配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;@/*&quot;</span>: [<span class="string">&quot;./src/*&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;@store/*&quot;</span>: [<span class="string">&quot;./src/store/*&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;@components/*&quot;</span>: [<span class="string">&quot;./src/components/*&quot;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><p>一般的 第三方模块都自己写了声明文件 所以不需要我们额外书写</p>
<p>它用来告诉编译器 我们导入的模块是什么 以此来获取代码提示等</p>
<h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p>在ts中 一般的 我们需要给每一个变量 定义类型</p>
<p>例如一个很普通的组件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">  onClick(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> AddList = <span class="function">(<span class="params">props: Props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; onClick &#125; = props</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Button <span class="keyword">type</span>=<span class="string">&quot;dashed&quot;</span> onClick=&#123;onClick&#125;&gt;</span><br><span class="line">        继续添加</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用interface 定义了该组件可以接收props的类型 这样就可以有效避免不属于该组件的props传进来 同时如果是必须传入的props也能做出有效的提醒</p>
<h2 id="css-module"><a href="#css-module" class="headerlink" title="css module"></a>css module</h2><p>这里我们可以引入一个第三方模块 来大大提升我们的开发效率</p>
<p><code>typings-for-css-modules-loader</code></p>
<p>它可能帮助我们实现css module（不需要修改文件名.module.css） 同时可以帮助我们自动生成.d.ts声明文件</p>
<p>使用 npm/yarn 安装后  找到我们刚刚配置过的<code>webpack.config.js</code>文件做相关配置</p>
<p>因为在我的项目中 css预编译器使用的是sass 所以还需要引入<code>sass-loader</code>和<code>dart-sass</code></p>
<p>注意：使用<code>dart-sass</code>而不是<code>node-sass</code> 因为<code>node-sass</code>和<code>node</code>版本强关联 可能会因为版本问题导致整个项目起不来</p>
<p>首先在<code>webpack.config.js</code>的module下删除掉原有的sass相关的配置 这一步很关键 因为脚手架默认会有相关的css module方案 可能会覆盖掉我们的配置</p>
<p>然后插入我们新的配置即可 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.scss|sass$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">&#x27;style-loader&#x27;</span>, <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">&#x27;typings-for-css-modules-loader&#x27;</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        modules: <span class="literal">true</span>, <span class="comment">//class局部作用域</span></span><br><span class="line">        namedExport: <span class="literal">true</span>,</span><br><span class="line">        camelCase: <span class="literal">true</span>,</span><br><span class="line">        minimize: <span class="literal">true</span>,</span><br><span class="line">        localIdentName: <span class="string">&#x27;[local]_[hash:base64:5]&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        config: &#123;</span><br><span class="line">          path: path.resolve(__dirname, <span class="string">&#x27;./postcss.config.js&#x27;</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">&#x27;sass-loader&#x27;</span>, <span class="comment">// 将 Sass 编译成 CSS</span></span><br><span class="line">      options: &#123;</span><br><span class="line">        implementation: <span class="built_in">require</span>(<span class="string">&#x27;sass&#x27;</span>), <span class="comment">//使用dart-sass代替node-sass</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 数据类型</title>
    <url>/FE/TS/data-type/</url>
    <content><![CDATA[<h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * boolean</span></span><br><span class="line"><span class="comment"> * 用构造函数Boolean创造的是对象不是布尔值</span></span><br><span class="line"><span class="comment"> * 直接使用Boolean可以返回一个布尔值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> isShow: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> isOk: <span class="built_in">boolean</span> = <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// let isTrue: boolean = new Boolean(false) 错误写法 等号右边是一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * number</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> username: <span class="built_in">string</span> = <span class="string">&#x27;chou&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * array</span></span><br><span class="line"><span class="comment"> * 在类型后面直接跟上[]</span></span><br><span class="line"><span class="comment"> * 使用数组泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> list1: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> list2: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tuple</span></span><br><span class="line"><span class="comment"> * 元组类型允许我们表示一个已知元素数量和类型的数组，各元素的类型不必相同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> person: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;chou&#x27;</span>, <span class="number">18</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * null &amp;&amp; undefined</span></span><br><span class="line"><span class="comment"> * 默认情况下 undefined 和 null 是所有类型的子类 可以给其他类型赋值</span></span><br><span class="line"><span class="comment"> * 在tsconfig.json中配置strict后 它们就只能赋值给void和它们自己</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// let myString: string = undefined</span></span><br><span class="line"><span class="comment">// let myNumber: number = undefined</span></span><br><span class="line"><span class="keyword">let</span> myVoid: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum</span></span><br><span class="line"><span class="comment"> * 默认情况下 从0开始为元素编号</span></span><br><span class="line"><span class="comment"> * 手动编号后 后面的元素从手动编号的那个值开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">enum</span> myColor &#123;</span><br><span class="line">  Red,</span><br><span class="line">  Green = <span class="number">2</span>,</span><br><span class="line">  Blue,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> color: myColor = myColor.Blue;</span><br><span class="line"><span class="built_in">console</span>.log(color); <span class="comment">// 3 因为我们手动给myColor编号了 Blue为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量枚举 在编译后不会有任何内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">enum</span> mouth &#123;</span><br><span class="line">  Jan = <span class="number">1</span>,</span><br><span class="line">  Feb,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减少魔法数字</span></span><br><span class="line"><span class="built_in">enum</span> STATUS &#123;</span><br><span class="line">  READY = <span class="number">0</span>,</span><br><span class="line">  OK = <span class="number">1</span>,</span><br><span class="line">  FAILED = -<span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">type</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">type</span> === STATUS.READY) &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">type</span> === STATUS.OK) &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">type</span> === STATUS.FAILED) &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * any</span></span><br><span class="line"><span class="comment"> * 可以声明那些在编程阶段还不确定的变量类型</span></span><br><span class="line"><span class="comment"> * 可以调用任意方法</span></span><br><span class="line"><span class="comment"> * 可以访问任意属性</span></span><br><span class="line"><span class="comment"> * 变量在声明的时候 未指定其类型 那么它会被识别为任意值类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> password;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// let password:any</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * void</span></span><br><span class="line"><span class="comment"> * 当一个函数没有返回值时 通常会为其声明返回值为void</span></span><br><span class="line"><span class="comment"> * 只能为void类型的变量 赋予undefined和null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;chou&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * never</span></span><br><span class="line"><span class="comment"> * 一般是那些抛出异常的函数</span></span><br><span class="line"><span class="comment"> * never是所有类型的子类</span></span><br><span class="line"><span class="comment"> * never类型没有子类 即使是any类型 也不能给never赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myError</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * object</span></span><br><span class="line"><span class="comment"> * 除number，string，boolean，symbol，null或undefined之外的类型</span></span><br><span class="line"><span class="comment"> * 在tsconfig.json中 未开启strict时 可以将null赋予object类型的变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> myObject: <span class="built_in">object</span>;</span><br><span class="line"></span><br><span class="line">myObject = &#123; <span class="attr">name</span>: <span class="string">&#x27;chou&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// myObject = null</span></span><br></pre></td></tr></table></figure>

<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 联合类型</span></span><br><span class="line"><span class="comment"> * 用 | 隔开每一个类型</span></span><br><span class="line"><span class="comment"> * 当访问属性或调用方法时 ts不确定该变量最后什么类型 所以只能是公共的类型或方法</span></span><br><span class="line"><span class="comment"> * 联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showNumber</span>(<span class="params">myNumber: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">string</span> | <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="comment">// myNumber.toFixed(3); 错误</span></span><br><span class="line">  <span class="keyword">return</span> myNumber.toString(); <span class="comment">// 只能使用string和number共有的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props1 &#123;</span><br><span class="line">  className: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Props2 &#123;</span><br><span class="line">  onClick: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;交叉类型 将多个类型合并为一个类型，新的类型将具有所有类型的特性</span></span><br><span class="line"><span class="keyword">const</span> props: Props1 &amp; Props2 = &#123;</span><br><span class="line">  onClick: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">  className: <span class="string">&#x27;luckyship-btn&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  类型断言</span></span><br><span class="line"><span class="comment"> *  类型断言好比其他语言中的类型转换</span></span><br><span class="line"><span class="comment"> *  它用在开发者明确知道类型的时候</span></span><br><span class="line"><span class="comment"> *  方法一: &lt;&gt;</span></span><br><span class="line"><span class="comment"> *  方法二: as</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getType = <span class="function"><span class="keyword">function</span> (<span class="params">val: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val.length;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (val <span class="keyword">as</span> <span class="built_in">number</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 组件传值</title>
    <url>/FE/Vue/Vue%20%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<h2 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h2><ul>
<li><p>父组件通过Prop向子组件传递数据</p>
</li>
<li><p>子组件在props中定义要接收的值</p>
</li>
</ul>
<a id="more"></a>

<p>子组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;这是子组件&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;ul v-for&#x3D;&quot;item in number&quot; :key&#x3D;&quot;item&quot;&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    number: &#123;</span><br><span class="line">      type: Array,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>父组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;这是父组件&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;hr &#x2F;&gt;</span><br><span class="line">    &lt;Children :number&#x3D;&quot;number&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Children from &#39;@&#x2F;components&#x2F;Children&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Children</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &#39;chou&#39;,</span><br><span class="line">      number: [1, 2, 3]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Prop-验证"><a href="#Prop-验证" class="headerlink" title="Prop 验证"></a>Prop 验证</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&quot;example&quot;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    &#x2F;&#x2F; 基础类型检测 (&#96;null&#96; 指允许任何类型)</span><br><span class="line">    propA: Number,</span><br><span class="line">    &#x2F;&#x2F; 可能是多种类型</span><br><span class="line">    propB: [String, Number],</span><br><span class="line">    &#x2F;&#x2F; 必传且是字符串</span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 数值且有默认值</span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 数组&#x2F;对象的默认值应当由一个工厂函数返回</span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      default: function() &#123;</span><br><span class="line">        return &#123; message: &quot;hello&quot; &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 自定义验证函数</span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: function(value) &#123;</span><br><span class="line">        return value &gt; 10;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h2><ul>
<li><p>子组件通过this.$emit自定义事件</p>
</li>
<li><p>父组件绑定该自定义事件</p>
</li>
</ul>
<p>父组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Children @showItem&#x3D;&quot;showItem&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Children from &quot;@&#x2F;components&#x2F;Children&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;Children&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    showItem(item) &#123;</span><br><span class="line">      console.log(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-for&#x3D;&quot;item in list&quot; :key&#x3D;&quot;item&quot;&gt;</span><br><span class="line">      &lt;button @click&#x3D;&quot;showItem(item)&quot;&gt;&#123;&#123; item &#125;&#125;&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;children&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      list: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    showItem(item) &#123;</span><br><span class="line">      &#x2F;&#x2F; console.log(item)</span><br><span class="line">      this.$emit(&#39;showItem&#39;,item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="兄弟之间"><a href="#兄弟之间" class="headerlink" title="兄弟之间"></a>兄弟之间</h2><p>EventBus</p>
<p>TODO</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 手写bind call apply</title>
    <url>/FE/JS/bind-call-apply/</url>
    <content><![CDATA[<h2 id="手写call"><a href="#手写call" class="headerlink" title="手写call"></a>手写call</h2><h3 id="原生call"><a href="#原生call" class="headerlink" title="原生call"></a>原生call</h3><p>我们首先来看看call方法实现了什么</p>
<a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayName.call(foo) <span class="comment">// chou</span></span><br></pre></td></tr></table></figure>

<p>不难看出</p>
<ul>
<li><p>call改变了this的指向，指向到foo对象</p>
</li>
<li><p>sayName方法执行了</p>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line"><span class="comment">// 改造foo对象</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.sayName() <span class="comment">// chou</span></span><br></pre></td></tr></table></figure>

<p>所以 如果我们</p>
<ul>
<li><p>将函数设置为对象的属性</p>
</li>
<li><p>执行该函数</p>
</li>
<li><p>删除该函数</p>
</li>
</ul>
<p>好啦 动手实现吧</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="built_in">this</span></span><br><span class="line">  context.fn()</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是call的第二个参数可以接收一个变量 </p>
<p>同时 如果不传递参数 默认会绑定window</p>
<p>好啦 我们继续模拟</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = []</span><br><span class="line">  <span class="comment">// 从第二个参数开始 因为第一个存放的是我们的函数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    args.push(<span class="built_in">arguments</span>[i])</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="built_in">this</span></span><br><span class="line">  context.fn(...args)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="手写apply"><a href="#手写apply" class="headerlink" title="手写apply"></a>手写apply</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>apply和call的区别在于 apply 的参数接收一个数组参数 而 call 则是参数列表</p>
<p>我们可以取argument的第一个元素 因为如果正确的传递 则argument的第一个元素应该是我们想要的 那个作为参数的数组</p>
<p>我们可以对这个值进行校验 </p>
<ul>
<li><p>如果不是数组 则抛出异常</p>
</li>
<li><p>如果不传 则默认只调用该方法</p>
</li>
<li><p>如果是数组 则按正确的处理</p>
</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._apply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">arguments</span>[<span class="number">1</span>]</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">if</span> (!args) &#123;</span><br><span class="line">    context.fn()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (args <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">      context.fn(...args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;CreateListFromArrayLike called on non-object&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind"></a>手写bind</h2><h3 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h3><p>我们借用 apply 或 call 返回一个新的函数即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h3><p>我们模拟bind调用中可以传递参数的形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 获取第二个参数到最后一个参数 第一个为函数 我们需要传入的变量</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个时候的arguments是指bind返回的函数传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// 用concat合并两次的参数</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三版"><a href="#第三版" class="headerlink" title="第三版"></a>第三版</h3><p>bind绑定的函数 还能用 new 关键字 来创建对象</p>
<p>TODO 此部分探索中</p>
]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript [] ==! []</title>
    <url>/FE/JS/JS%20%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>首先，== 的定义是：</p>
<br />

<img src="https://pic1.zhimg.com/cf1e9188f66186ecd77fb31ac0c5400f_r.jpg?source=1940ef5c" />

<br />

<a id="more"></a>

<p>GetValue 会获取一个子表达式的值（消除掉左值引用），在表达式 [] == ![] 中，[] 的结果就是一个空数组的引用，而 ![] 就有意思了，它会按照 11.4.9 和 9.2 节的要求得到 false。比较的行为在 11.9.3 节里，所以翻到 11.9.3：</p>
<br />

<img src="https://pic4.zhimg.com/2d0d90f2d9549f5f13ad53be3f75ace8_r.jpg?source=1940ef5c" />

<br />

<p>在这段算法里，和「[] == ![]」匹配的是条件 7，所以会递归地调用「[] == ToNumber(false)」进行比较。</p>
<p>在 9.3 节中定义了 ToNumber 原语，ToNumber(false) 等于 0，于是比较变为「[] == 0」。</p>
<p>在此处因为 [] 是对象，比较过程走分支 9，依「ToPrimitive([]) == 0」比较。</p>
<p>ToPrimitive 默认是调用 toString 方法的（依 8.2.8），于是 ToPrimitice([]) 等于空字符串。</p>
<p>结果，[] == ![] 的比较最后落到了 ‘’==false 上，</p>
<p>按照 11.9.3 中的定义会依分支 5 比较 「ToNumber(‘’)==0」，ToNumber(‘’) 依 9.3.1 等于 0，所以结果为 true。</p>
]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 函数节流 防抖</title>
    <url>/FE/JS/debounce-throttle/</url>
    <content><![CDATA[<h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    函数防抖：一个频繁触发的函数，在规定时间内，只让函数最后一次触发 例如：</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    - 用户输入搜索框 避免每次敲击键盘都发送请求</span></span><br><span class="line"><span class="comment">    - 登录、发短信等按钮避免用户点击太快，以致于发送了多次请求</span></span><br><span class="line"><span class="comment">    - 调整浏览器窗口大小时，resize 次数过于频繁</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    思路：关键在于清零 例如登录按钮点击一秒后发送登录请求 我们就可以创建一个定时器 每次用户点击的时候都清除这个定时器 让定时器重置</span></span><br><span class="line"><span class="comment">         这样就保证了这一秒内不会因为用户都频繁点击而一直发送请求 代码如下</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn  要执行的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay 延迟的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.call(<span class="built_in">this</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    函数节流：一个函数执行一次后，只有大于设定的执行周期才会执行第二次</span></span><br><span class="line"><span class="comment">    适用场景：有一个频繁触发的函数，在规定时间内，只让函数触发一次 优化性能 例如</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    - scroll时间 每隔1s重新计算位置 而不是一直计算</span></span><br><span class="line"><span class="comment">    - 浏览器播放时间 每隔1s重新计算一次播放进度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    思路：需要两个时间 lastTime 和 nowTime 来计算时间差 由此来判断是否执行事件</span></span><br><span class="line"><span class="comment">         先将lastTime初始化为0 然后获取系统时间 做差判断是否大于delay 如果大于则执行事件并将nowTime赋予lastTime 由此完成节流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn  要执行的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay 延迟的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nowTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">if</span> (nowTime - lastTime &gt; delay) &#123;</span><br><span class="line">      fn.call(<span class="built_in">this</span>);</span><br><span class="line">      lastTime = nowTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 闭包</title>
    <url>/FE/JS/closure/</url>
    <content><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li><p>闭包的形成条件</p>
<ul>
<li><p>函数嵌套</p>
</li>
<li><p>内部函数引用外部函数的局部变量</p>
</li>
</ul>
</li>
<li><p>闭包的缺点</p>
<ul>
<li> 容易造成内存泄漏 （现代浏览器性能？？？）</li>
</ul>
</li>
<li><p>闭包的优点</p>
<ul>
<li>延长外部函数局部变量的生命周期</li>
</ul>
</li>
<li><p>什么是闭包</p>
<ul>
<li><p>密闭的容器 存储数据</p>
</li>
<li><p>闭包是一个对象 键值对</p>
</li>
</ul>
</li>
</ul>
<a id="more"></a>


<h3 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()();<span class="comment">//123</span></span><br></pre></td></tr></table></figure>

<p>又上述代码可知</p>
<p>闭包延长了变量a的生命周期 让外部作用域有能力获取到函数内部的变量</p>
<p>闭包就是将函数内部和函数外部连接起来的一座桥梁</p>
<h3 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i = <span class="number">1</span> ;i &lt;=<span class="number">5</span> ;i++</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i);</span><br><span class="line">	&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码想实现 每秒输出一个数字 从1 - 5</p>
<p>但是事实上每秒输出一个6</p>
<p>因为setTimeout是异步队列 执行时 for循环里i的值已经变成了出循环的值</p>
<p>解决方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为函数是一个独立的作用域 可以记录每一个i的值 拿到属于自己的a</p>
]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深浅拷贝</title>
    <url>/FE/JS/deep-clone/</url>
    <content><![CDATA[<h2 id="concat-slice"><a href="#concat-slice" class="headerlink" title="concat / slice"></a>concat / slice</h2><p>使用 concat / slice 可以实现对一个数组的浅拷贝</p>
<p>但是第一层为深拷贝 如何理解呢</p>
<p>我们创建两个数组</p>
<ul>
<li><p>arr1 只有一层的数组</p>
</li>
<li><p>arr2 有两层的数组</p>
</li>
</ul>
<p>然后我们用 concat() 或 slice() 分别拷贝两份数组</p>
<p>然后我们来修改拷贝后的数组</p>
<p>通过原数组是否会被影响 来验证是否为深拷贝</p>
<a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copyArr1 = arr1.concat();</span><br><span class="line"><span class="keyword">var</span> copyArr2 = arr2.concat();</span><br><span class="line"></span><br><span class="line">copyArr1.push(<span class="number">10</span>);</span><br><span class="line">copyArr2[<span class="number">3</span>].push(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [ 1, 2, 4, [ 5, 6, 7, 8, 9, 10 ] ]</span></span><br></pre></td></tr></table></figure>

<p>通过最终的输出 显然易见 这两个方法只能对第一层进行深拷贝</p>
<h2 id="Object-assign-target-source……"><a href="#Object-assign-target-source……" class="headerlink" title="Object.assign(target, source……)"></a>Object.assign(target, source……)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  hobby: &#123;</span><br><span class="line">    color: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">    game: <span class="string">&#x27;basketball&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copyObj = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"></span><br><span class="line">copyObj.name = <span class="string">&#x27;LuckyChou&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> copyObj.hobby.color;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; name: &#x27;chou&#x27;, age: 18, hobby: &#123; game: &#x27;basketball&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>同样的 通过结果 我们不难发现 Object.assign() 也只是实现了对象第一层的深拷贝</p>
<p>也就是对属性的深拷贝 如果属性值是引用类型的话 那么还是拷贝了它的地址</p>
<h2 id="扩展运算符…"><a href="#扩展运算符…" class="headerlink" title="扩展运算符…"></a>扩展运算符…</h2><p>扩展运算符也能达到类似上述的效果 但是都是浅拷贝</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">&#123;...obj&#125;</span><br><span class="line">[...arr]</span><br></pre></td></tr></table></figure>

<h2 id="JSON-parse-JSON-stringify-obj"><a href="#JSON-parse-JSON-stringify-obj" class="headerlink" title="JSON.parse(JSON.stringify(obj))"></a>JSON.parse(JSON.stringify(obj))</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  hobby: &#123;</span><br><span class="line">    color: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">    game: <span class="string">&#x27;basketball&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copyObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"></span><br><span class="line">copyObj.name = <span class="string">&#x27;LuckyChou&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> copyObj.hobby.color;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; name: &#x27;chou&#x27;, age: 18, hobby: &#123; color: &#x27;blue&#x27;, game: &#x27;basketball&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>Wow! 通过结果 我们发现该方法居然实现了深拷贝 emmmmm 那么它有缺点吗</p>
<p>通过查阅<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">MDN</a> 我们可以找到这样一句话</p>
<blockquote>
<p>undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略</p>
</blockquote>
<p>也就是说对于 undefined 函数 symbol 用这种方法将无能为力</p>
<h2 id="DIY"><a href="#DIY" class="headerlink" title="DIY"></a>DIY</h2><p>既然没有完美的方案可以实现深拷贝 那么我们自己动手实现一个吧</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> o === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> o === <span class="string">&#x27;function&#x27;</span>) &amp;&amp; o !== <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isObject(obj)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;非对象&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> isArray = <span class="built_in">Array</span>.isArray(obj);</span><br><span class="line">  <span class="keyword">let</span> newObj = isArray ? [...obj] : &#123; ...obj &#125;;</span><br><span class="line">  <span class="built_in">Reflect</span>.ownKeys(newObj).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于深拷贝需要考虑到多种场景 实现起来也很困难 如果用于生产环境 推荐使用 lodash 的_clone 函数</p>
]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue Vuex</title>
    <url>/FE/Vue/Vuex/</url>
    <content><![CDATA[<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>借用官网的一段话</p>
<ul>
<li><p>Vuex 的状态存储是响应式的。</p>
<p>当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
</li>
<li><p>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。</p>
<p>这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="Vuex-内容"><a href="#Vuex-内容" class="headerlink" title="Vuex 内容"></a>Vuex 内容</h2><ul>
<li><p>state</p>
<ul>
<li>管理着公共的属性</li>
</ul>
</li>
<li><p>action</p>
<ul>
<li><p>处理异步事件</p>
</li>
<li><p>组件通过dispatch提交事件  事件内部再用commit提交同步事件</p>
</li>
</ul>
</li>
<li><p>mutation</p>
<ul>
<li><p>处理同步事件</p>
</li>
<li><p>组件通过commit提交事件</p>
</li>
</ul>
</li>
<li><p>getter</p>
<ul>
<li>可以处理state中的数据</li>
</ul>
</li>
<li><p>modules</p>
<ul>
<li>可以创建多个state</li>
</ul>
</li>
</ul>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      number : &#123;&#123; $store.state.number &#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      reverseNumber : &#123;&#123; $store.getters.reverseNum &#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;add&quot;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;sub(5)&quot;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;auto&quot;&gt;AUTO&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add() &#123;</span><br><span class="line">      this.$store.commit(&#39;add&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    sub(count) &#123;</span><br><span class="line">      this.$store.commit(&#39;sub&#39;,count)</span><br><span class="line">    &#125;,</span><br><span class="line">    auto() &#123;</span><br><span class="line">      this.$store.dispatch(&#39;auto&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        number: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">sub</span>(<span class="params">state, count</span>)</span> &#123;</span><br><span class="line">            state.number -= count</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">            state.number++</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">autoAdd</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">            state.number++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        <span class="function"><span class="title">auto</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                state.commit(<span class="string">&#x27;autoAdd&#x27;</span>)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        <span class="function"><span class="title">reverseNum</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [...(state.number + <span class="string">&#x27;&#x27;</span>)].reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h3><p>上述所有操作中涉及到dispatch和commit时</p>
<p>可以将所有的dispatch和commit(‘xxx’)中的xxx定义成一个常量</p>
<p>并将所有的除了state以外的部分抽离成一个个单独的文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── api</span><br><span class="line">│   └── ... <span class="comment"># 抽取出API请求</span></span><br><span class="line">├── components</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   └── ...</span><br><span class="line">└── store</span><br><span class="line">    ├── index.js          <span class="comment"># 我们组装模块并导出 store 的地方</span></span><br><span class="line">    ├── actions.js        <span class="comment"># 根级别的 action</span></span><br><span class="line">    ├── mutations.js      <span class="comment"># 根级别的 mutation</span></span><br><span class="line">    └── modules</span><br><span class="line">        ├── cart.js       <span class="comment"># 购物车模块</span></span><br><span class="line">        └── products.js   <span class="comment"># 产品模块</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript defineProperty 与 proxy</title>
    <url>/FE/JS/defineProperty-Proxy/</url>
    <content><![CDATA[<p>我们可以对一个对象进行赋值和取值</p>
<p>但是如果我们在赋值或取值的时候 需要进行一些操作</p>
<p>此时 我们该如何监听到数据的改变呢 实现数据监听呢</p>
<h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h2><blockquote>
<p>Object.defineProperty(obj, prop, descriptor)</p>
</blockquote>
<ul>
<li><p>obj: 要在其上定义属性的对象。</p>
</li>
<li><p>prop: 要定义或修改的属性的名称。</p>
</li>
<li><p>descriptor: 将被定义或修改的属性的描述符。</p>
<ul>
<li><p>value: 直接给这个属性赋值</p>
</li>
<li><p>writable: 是否可修改 默认 false</p>
</li>
<li><p>enumerable: 是否可枚举(遍历拿值) 默认 false</p>
</li>
<li><p>configurable: 是否可删除 默认 false</p>
</li>
<li><p>set</p>
</li>
<li><p>get</p>
</li>
</ul>
</li>
</ul>
<a id="more"></a>

<p><strong>注意：value/writable 和 set/get 不能同时出现</strong></p>
<p><strong>可理解为既然可以手动修改 则 value 必定会有值 且是可读写的</strong></p>
<p><strong>直接使用对象字面量则默认 descriptor 都为 true 若只指定 value 则默认 descriptor 都为 false</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">o.a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一方面，</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">value</span>: <span class="number">1</span> &#125;);</span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// value: &#x27;chou&#x27;,</span></span><br><span class="line">  <span class="comment">// writable: true,</span></span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">    value = newValue;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;set方法执行了&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;get方法执行了&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">&#x27;chou&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// set方法执行了</span></span><br><span class="line"><span class="comment">// get方法执行了</span></span><br><span class="line"><span class="comment">// chou</span></span><br></pre></td></tr></table></figure>

<p>如果我们需要一次定义多个属性 则可以使用<code>Object.defineProperties(obj, props)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">  property1: &#123;</span><br><span class="line">    value: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  property2: &#123;</span><br><span class="line">    value: <span class="string">&#x27;Chou&#x27;</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// etc. etc.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Vue2 就是使用了这个 Api 来实现了数据监听 从而实现了它的响应式体系</p>
<h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h2><p>Vue3 开始 将用 proxy 代替 defineProperty 那么它对比 defineProperty 有什么优势呢</p>
<p>proxy 对比 defineProperty 它的优势在于 defineProperty 只能截取到 set 和 get</p>
<p>而 proxy 有 13 种 拦截器可供选择 具体的每种拦截器<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">可参考</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">obj, prop, value</span>)</span> &#123;</span><br><span class="line">    obj[prop] = value;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;prop&#125;</span>属性的set方法执行了`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">obj, prop</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;prop&#125;</span>属性的get方法执行了`</span>);</span><br><span class="line">    <span class="keyword">return</span> obj[prop];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">obj, key</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;has方法执行了&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">&#x27;chou&#x27;</span>;</span><br><span class="line">obj.age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.name);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// name属性的set方法执行了</span></span><br><span class="line"><span class="comment">// age属性的set方法执行了</span></span><br><span class="line"><span class="comment">// name属性的get方法执行了</span></span><br><span class="line"><span class="comment">// chou</span></span><br><span class="line"><span class="comment">// has方法执行了</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 常见错误类</title>
    <url>/FE/JS/error/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近 在做JS笔试题的时候 一直分不清楚每个错误类 所以在查阅资料后 写下了这篇笔记</p>
<a id="more"></a>

<h2 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a>SyntaxError</h2><p>SyntaxError是解析代码时发生的语法错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量名错误 </span></span><br><span class="line"><span class="keyword">var</span> <span class="number">1</span>a; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺少括号 </span></span><br><span class="line"><span class="built_in">console</span>.log <span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="ReferenceError"><a href="#ReferenceError" class="headerlink" title="ReferenceError"></a>ReferenceError</h2><p>ReferenceError是引用一个不存在的变量时发生的错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如我们直接打印一个未声明的变量</span></span><br><span class="line"><span class="built_in">console</span>.log(unknownVariable) <span class="comment">// ReferenceError: unknownVariable is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log() = <span class="number">1</span> <span class="comment">// ReferenceError: Invalid left-hand side in assignment </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span> = <span class="number">1</span> <span class="comment">// ReferenceError: Invalid left-hand side in assignment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码对函数console.log的运行结果和this赋值，结果都引发了ReferenceError错误</span></span><br></pre></td></tr></table></figure>

<h2 id="RangeError"><a href="#RangeError" class="headerlink" title="RangeError"></a>RangeError</h2><p>RangeError是当一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值</p>
<h2 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h2><p>TypeError是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="number">123</span> <span class="comment">//TypeError: number is not a func</span></span><br></pre></td></tr></table></figure>

<h2 id="URIError"><a href="#URIError" class="headerlink" title="URIError"></a>URIError</h2><p>URIError是URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">decodeURI</span>(<span class="string">&#x27;%2&#x27;</span>) <span class="comment">// URIError: URI malformed</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 数组常用方法以及数组排序/逆序/去重/乱序/扁平化</title>
    <url>/FE/JS/array/</url>
    <content><![CDATA[<p>我们知道数组的本质是一个对象 假设我们有以下数组 来获取它的键名试试</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(arr))</span><br><span class="line"></span><br><span class="line"><span class="comment">//[ &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>获取到数组的 key 为 [ ‘0’, ‘1’, ‘2’, ‘3’ ]</p>
<a id="more"></a>

<p>所以我们可以用 arr[0]来获取数组中的元素</p>
<p>本质上是 Object[key]的形式获取了 value</p>
<p>而 arr[0]会被转换成 arr[‘0’] 因为对象的键名都是string类型</p>
<h2 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h2><p>我们思考一个问题 arr.length得到的一定是数组的实际长度吗</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.length) <span class="comment">//4</span></span><br><span class="line">arr[<span class="number">100</span>] = <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length) <span class="comment">//101</span></span><br></pre></td></tr></table></figure>

<p><strong>length 属性永远比 key 最大值 大一个</strong></p>
<p>注意 因为数组本质上是一个对象 所以我们可以进行如下赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;6&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [ 1, 2, 3, a: 6 ]</span></span><br></pre></td></tr></table></figure>

<p>上述操作会增加一个元素 a</p>
<p>但是数组 length 依然为 5 因为 length = Max（key） + 1</p>
<h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2><p>也适用于数组 因为它是对象</p>
<h3 id="for……in"><a href="#for……in" class="headerlink" title="for……in"></a>for……in</h3><p>循环遍历数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 for……in 循环遍历 会获取所有 key 包括非数字 key</p>
<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>注意</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>]) <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>delete 不会影响数组的长度 只是删除了数组对应 key 的 value 变成 undefined</p>
<p>但是遍历的时候会跳过这个空位 不会产生任何输出</p>
<h2 id="伪数组"><a href="#伪数组" class="headerlink" title="伪数组"></a>伪数组</h2><p>伪数组不具备任何数组的方法 如果调用会报错</p>
<p>常见的伪数组有</p>
<ul>
<li><p>函数内部的arguments</p>
</li>
<li><p>通过选择器获取到的nodeList</p>
</li>
</ul>
<p>但是伪数组有 length 属性</p>
<p>将伪数组转换为真正的数组有如下方法</p>
<p><code>Array.prototype.slice.call ( arrayLike )</code></p>
<p><code>Array.from ( arrayLike )</code> </p>
<h2 id="数组API"><a href="#数组API" class="headerlink" title="数组API"></a>数组API</h2><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><h4 id="Array-from-arrayLike-mapFn-thisArg"><a href="#Array-from-arrayLike-mapFn-thisArg" class="headerlink" title="Array.from(arrayLike[, mapFn[, thisArg]])"></a>Array.from(arrayLike[, mapFn[, thisArg]])</h4><p>方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例</p>
<ul>
<li><p>arrayLike</p>
<ul>
<li>想要转换成数组的伪数组对象或可迭代对象。</li>
</ul>
</li>
<li><p>mapFn 可选</p>
<ul>
<li>如果指定了该参数，新数组中的每个元素会执行该回调函数。</li>
</ul>
</li>
<li><p>thisArg 可选</p>
<ul>
<li>可选参数，执行回调函数 mapFn 时 this 对象。</li>
</ul>
</li>
</ul>
<p>功能：将类数组变成真正的数组 快速生成有序数组</p>
<p>例如 快速生成一个1-10的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="built_in">Array</span>(<span class="number">10</span>), <span class="function">(<span class="params">val, index</span>) =&gt;</span> index + <span class="number">1</span>); <span class="comment">// [1,2....,10]</span></span><br></pre></td></tr></table></figure>

<p>因为伪数组也有length属性 所以我们也可以改写成如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">(<span class="params">val, index</span>) =&gt;</span> index + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h4><h4 id="Array-of-element0-element1-…-elementN"><a href="#Array-of-element0-element1-…-elementN" class="headerlink" title="Array.of(element0[, element1[, …[, elementN]]])"></a>Array.of(element0[, element1[, …[, elementN]]])</h4><p>返回值: 一个新的数组实例</p>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><h4 id="arr-concat"><a href="#arr-concat" class="headerlink" title="arr.concat()"></a>arr.concat()</h4><p>功能: 合并数组 也可用于浅拷贝</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝 只拷贝最外层</span></span><br><span class="line"><span class="keyword">const</span> NewArray = orgArray.concat()</span><br></pre></td></tr></table></figure>

<h4 id="arr-every-callback-element-index-array-thisArg"><a href="#arr-every-callback-element-index-array-thisArg" class="headerlink" title="arr.every(callback(element[, index[, array]])[, thisArg])"></a>arr.every(callback(element[, index[, array]])[, thisArg])</h4><ul>
<li><p>callback</p>
<p>  用来测试每个元素的函数，它可以接收三个参数：</p>
<ul>
<li><p>element</p>
<p>用于测试的当前值。</p>
</li>
<li><p>index可选</p>
<p>用于测试的当前值的索引。</p>
</li>
<li><p>array可选</p>
<p>调用 every 的当前数组。 </p>
</li>
</ul>
</li>
</ul>
<p>返回值: 如果回调函数的每一次返回都为 truthy 值，返回 true ，否则返回 false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="arr-some"><a href="#arr-some" class="headerlink" title="arr.some()"></a>arr.some()</h4><p>同every</p>
<p>返回值: 有一个通过就返回true</p>
<h4 id="arr-fill"><a href="#arr-fill" class="headerlink" title="arr.fill()"></a>arr.fill()</h4><p>参数: arr.fill(value[, start[, end]])</p>
<ul>
<li><p>value</p>
<p>用来填充数组元素的值。</p>
</li>
<li><p>start 可选</p>
<p>起始索引，默认值为0。</p>
</li>
<li><p>end 可选</p>
<p>终止索引，默认值为 this.length。</p>
</li>
</ul>
<p>返回值: 修改后的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可用于初始化数组</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">0</span>);   <span class="comment">// [0, 0, 0]</span></span><br></pre></td></tr></table></figure>

<h4 id="arr-filter-callback-element-index-array-thisArg"><a href="#arr-filter-callback-element-index-array-thisArg" class="headerlink" title="arr.filter(callback(element[, index[, array]])[, thisArg])"></a>arr.filter(callback(element[, index[, array]])[, thisArg])</h4><p>返回值: 一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">1</span>) <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">6</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<h4 id="arr-find-callback-thisArg"><a href="#arr-find-callback-thisArg" class="headerlink" title="arr.find(callback[, thisArg])"></a>arr.find(callback[, thisArg])</h4><p>返回值: 数组中<strong>第一个</strong>满足所提供测试函数的元素的值，否则返回 undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].find(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">6</span>) <span class="comment">//undefined</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].find(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">2</span>) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<h4 id="arr-findIndex"><a href="#arr-findIndex" class="headerlink" title="arr.findIndex()"></a>arr.findIndex()</h4><p>同find 区别在于返回值</p>
<p>数组中通过提供测试函数的<strong>第一个</strong>元素的索引。否则，返回-1。</p>
<h4 id="arr-flat-depth"><a href="#arr-flat-depth" class="headerlink" title="arr.flat([depth])"></a>arr.flat([depth])</h4><ul>
<li>depth: 深度 默认为1</li>
</ul>
<p>将数组扁平化</p>
<p>返回值: 一个新的数组实例。</p>
<h4 id="arr-flatMap"><a href="#arr-flatMap" class="headerlink" title="arr.flatMap()"></a>arr.flatMap()</h4><p>flatMap() = map() + flat(1)</p>
<h4 id="arr-forEach-callback-currentValue-index-array-thisArg"><a href="#arr-forEach-callback-currentValue-index-array-thisArg" class="headerlink" title="arr.forEach(callback(currentValue [, index [, array]])[, thisArg])"></a>arr.forEach(callback(currentValue [, index [, array]])[, thisArg])</h4><p>返回值: 没有返回值 undefined</p>
<h4 id="arr-map"><a href="#arr-map" class="headerlink" title="arr.map()"></a>arr.map()</h4><p>效果同forEach() 区别在于map()有返回值</p>
<p>返回值: 原数组每个元素执行回调函数的结果组成的新数组</p>
<h4 id="arr-includes"><a href="#arr-includes" class="headerlink" title="arr.includes()"></a>arr.includes()</h4><p>返回值: boolean</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>);     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>);     <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="arr-indexOf-searchElement-fromIndex"><a href="#arr-indexOf-searchElement-fromIndex" class="headerlink" title="arr.indexOf(searchElement[, fromIndex])"></a>arr.indexOf(searchElement[, fromIndex])</h4><ul>
<li><p>fromIndex(可选)</p>
<ul>
<li>指定开始查找的位置</li>
</ul>
</li>
</ul>
<p>返回值: 查找元素的索引下标 若找不到则为-1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>];</span><br><span class="line">array.indexOf(<span class="number">2</span>);     <span class="comment">// 0</span></span><br><span class="line">array.indexOf(<span class="number">7</span>);     <span class="comment">// -1</span></span><br><span class="line">array.indexOf(<span class="number">9</span>, <span class="number">2</span>);  <span class="comment">// 2</span></span><br><span class="line">array.indexOf(<span class="number">2</span>, -<span class="number">1</span>); <span class="comment">// -1</span></span><br><span class="line">array.indexOf(<span class="number">2</span>, -<span class="number">3</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h4 id="arr-join"><a href="#arr-join" class="headerlink" title="arr.join()"></a>arr.join()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;Wind&#x27;</span>, <span class="string">&#x27;Rain&#x27;</span>, <span class="string">&#x27;Fire&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> myVar1 = a.join();      <span class="comment">// myVar1的值变为&quot;Wind,Rain,Fire&quot;</span></span><br><span class="line"><span class="keyword">var</span> myVar2 = a.join(<span class="string">&#x27;, &#x27;</span>);  <span class="comment">// myVar2的值变为&quot;Wind, Rain, Fire&quot;</span></span><br><span class="line"><span class="keyword">var</span> myVar3 = a.join(<span class="string">&#x27; + &#x27;</span>); <span class="comment">// myVar3的值变为&quot;Wind + Rain + Fire&quot;</span></span><br><span class="line"><span class="keyword">var</span> myVar4 = a.join(<span class="string">&#x27;&#x27;</span>);    <span class="comment">// myVar4的值变为&quot;WindRainFire&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="arr-reduce-callback-accumulator-currentValue-index-array-initialValue"><a href="#arr-reduce-callback-accumulator-currentValue-index-array-initialValue" class="headerlink" title="arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])"></a>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</h4><ul>
<li><p>accumulator: 累加器 即函数上一次调用的返回值。</p>
<p>第一次的时候为 initialValue || arr[0]</p>
</li>
<li><p>currentValue: 数组中函数正在处理的的值。</p>
<p>第一次的时候 initialValue || arr[1]</p>
</li>
<li><p>currentIndex: (可选)数据中正在处理的元素索引</p>
<p>如果提供了 initialValue 从 0 开始 否则从 1 开始</p>
</li>
<li><p>array: (可选)调用 reduce 的数组</p>
</li>
<li><p>initialValue: (可选)累加器的初始值。没有时 累加器第一次的值为 currentValue</p>
<p>注意: 在对没有设置初始值的空数组调用 reduce 方法时会报错。</p>
</li>
</ul>
<p>返回值: 函数累计处理的结果</p>
<p>为了更直观的感受 我们来看一个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有初始值</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params">accumulator, currentValue, currentIndex, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue</span><br><span class="line">&#125;, <span class="number">10</span>) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>callback</th>
<th>accumulator</th>
<th>currentValue</th>
<th>currentIndex</th>
<th>array</th>
<th>return value</th>
</tr>
</thead>
<tbody><tr>
<td>first call</td>
<td>10(初始值)</td>
<td>1(数组第一个元素)</td>
<td>0(有初始值为 0)</td>
<td>[1, 2, 3, 4]</td>
<td>11</td>
</tr>
<tr>
<td>second call</td>
<td>11</td>
<td>2</td>
<td>1</td>
<td>[1, 2, 3, 4]</td>
<td>13</td>
</tr>
<tr>
<td>third call</td>
<td>13</td>
<td>3</td>
<td>2</td>
<td>[1, 2, 3, 4]</td>
<td>16</td>
</tr>
<tr>
<td>fourth call</td>
<td>16</td>
<td>4</td>
<td>3</td>
<td>[1, 2, 3, 4]</td>
<td>20</td>
</tr>
</tbody></table>
<h4 id="arr-reverse"><a href="#arr-reverse" class="headerlink" title="arr.reverse()"></a>arr.reverse()</h4><p>返回值: 颠倒后的数组(会直接修改原数组)</p>
<h4 id="arr-slice-begin-end"><a href="#arr-slice-begin-end" class="headerlink" title="arr.slice([begin[, end]])"></a>arr.slice([begin[, end]])</h4><p>若省略 则默认从0开始</p>
<p>返回值: 一个新的数组实例(不会修改原数组)</p>
<p>功能: 切割数组/浅拷贝/转化为真正的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure>

<h4 id="arr-sort-compareFunction"><a href="#arr-sort-compareFunction" class="headerlink" title="arr.sort([compareFunction])"></a>arr.sort([compareFunction])</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]; </span><br><span class="line">numbers.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 升序 </span></span><br><span class="line">numbers.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a); <span class="comment">// 降序 </span></span><br></pre></td></tr></table></figure>

<p>返回值: 排序后的数组(修改原数组)</p>
<h4 id="array-splice-start-deleteCount-item1-item2-…"><a href="#array-splice-start-deleteCount-item1-item2-…" class="headerlink" title="array.splice(start[, deleteCount[, item1[, item2[, …]]]])"></a>array.splice(start[, deleteCount[, item1[, item2[, …]]]])</h4><ul>
<li><p>deleteCount(可选)</p>
<p>整数，表示要移除的数组元素的个数。</p>
<ul>
<li><p><code>&gt;0 删除元素</code></p>
</li>
<li><p><code>&lt;0 添加元素</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="增加-删除"><a href="#增加-删除" class="headerlink" title="增加/删除"></a>增加/删除</h4><ul>
<li><p>pop() 删除最后一个元素 返回值为被删除元素</p>
</li>
<li><p>push() 在数组最后添加一个元素 返回值为新数组的长度</p>
</li>
<li><p>shift() 删除第一个元素 返回值为被删除的元素</p>
</li>
<li><p>unshift() 在数组开头添加一个元素 返回值为新数组的长度</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="https://gitee.com/LuckyChou/blog-images/raw/master/js/data-type/array.png" />

<h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 升序</span></span><br><span class="line">arr.sort(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x-y)</span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line">arr.sort(<span class="function">(<span class="params">x,y</span>) =&gt;</span> y-x)</span><br></pre></td></tr></table></figure>

<h2 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现一</span></span><br><span class="line">arr.reverse()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现二</span></span><br><span class="line">arr.reduce(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> &#123;</span><br><span class="line">    prev.unshift(curr);</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">  &#125;, [])</span><br></pre></td></tr></table></figure>

<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><h3 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h3><p>用 ES6 Set 的特性 没有重复的元素</p>
<h3 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h3><p>先将数组排序 然后比较相邻元素 如果相同 就移到下一个元素</p>
<h3 id="实现三"><a href="#实现三" class="headerlink" title="实现三"></a>实现三</h3><p>双重for循环 </p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>具体代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="number">10000</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; timer; i++) &#123;</span><br><span class="line">    arr[i] = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = []</span><br><span class="line"><span class="keyword">let</span> arr2 = []</span><br><span class="line"><span class="keyword">let</span> arr3 = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成了 3个 数组长度为timer的数组</span></span><br><span class="line">arr1 = getArr(arr1)</span><br><span class="line">arr2 = getArr(arr2)</span><br><span class="line">arr3 = getArr(arr3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// case 1</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;case1&#x27;</span>)</span><br><span class="line">arr = [...new <span class="built_in">Set</span>(arr1)]</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;case1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// case 2</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;case2&#x27;</span>)</span><br><span class="line">arr2 = arr2.sort(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x - y)</span><br><span class="line"><span class="keyword">const</span> res2 = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr2[i] !== arr2[i + <span class="number">1</span>]) &#123;</span><br><span class="line">    res2.push(arr2[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;case2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// case3</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;case3&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> res3 = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr3.length; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr3.length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr3[i] == arr3[j]) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == arr3.length - <span class="number">1</span>) &#123;</span><br><span class="line">      res3.push(arr3[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;case3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// case1: 0.467ms</span></span><br><span class="line"><span class="comment">// case2: 5.254ms</span></span><br><span class="line"><span class="comment">// case3: 11.034ms</span></span><br></pre></td></tr></table></figure>

<p>可见 利用ES6的Set是效率最高的一种方法</p>
<h2 id="数组乱序"><a href="#数组乱序" class="headerlink" title="数组乱序"></a>数组乱序</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>取两个数组长度范围内的下标  交换位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="number">1000</span></span><br><span class="line">  <span class="keyword">var</span> x, y, temp</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; timer; i++) &#123;</span><br><span class="line">    x = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length)</span><br><span class="line">    y = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length)</span><br><span class="line">    temp = arr[x]</span><br><span class="line">    arr[x] = arr[y]</span><br><span class="line">    arr[y] = temp</span><br><span class="line">    <span class="comment">// ES6 写法</span></span><br><span class="line">    <span class="comment">// ;[arr[x], arr[y]] = [arr[y], arr[x]]</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><h3 id="实现一-1"><a href="#实现一-1" class="headerlink" title="实现一"></a>实现一</h3><p>调用 <code>Array.prototype.flat</code></p>
<h3 id="实现二-1"><a href="#实现二-1" class="headerlink" title="实现二"></a>实现二</h3><p>如果都是数字 可以用 toString 方法 转化为字符串 再用 split 切割</p>
<h3 id="实现三-1"><a href="#实现三-1" class="headerlink" title="实现三"></a>实现三</h3><p>递归调用 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> res = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// case 1</span></span><br><span class="line">  <span class="comment">// return arr.flat()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// case 2</span></span><br><span class="line">  <span class="comment">// return arr</span></span><br><span class="line">  <span class="comment">//   .toString()</span></span><br><span class="line">  <span class="comment">//   .split(&#x27;,&#x27;)</span></span><br><span class="line">  <span class="comment">//   .map((item) =&gt; +item)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// case 3</span></span><br><span class="line">  <span class="comment">// for (var i = 0; i &lt; arr.length; i++) &#123;</span></span><br><span class="line">  <span class="comment">//   if (arr[i] instanceof Array) &#123;</span></span><br><span class="line">  <span class="comment">//     flat(arr[i])</span></span><br><span class="line">  <span class="comment">//   &#125; else &#123;</span></span><br><span class="line">  <span class="comment">//     res.push(arr[i])</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// return res</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 重学ES6</title>
    <url>/FE/JS/es6/</url>
    <content><![CDATA[<h2 id="let-const"><a href="#let-const" class="headerlink" title="let const"></a>let const</h2><h3 id="globalThis-顶级对象"><a href="#globalThis-顶级对象" class="headerlink" title="globalThis 顶级对象"></a>globalThis 顶级对象</h3><ul>
<li><p>浏览器里面，顶层对象是 window，但 Node 和 Web Worker 没有 window</p>
</li>
<li><p>浏览器和 Web Worker 里面，self 也指向顶层对象，但是 Node 没有 self</p>
</li>
<li><p>Node 里面，顶层对象是 global，但其他环境都不支持</p>
</li>
</ul>
<h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>按照对应位置，对变量赋值</p>
<h4 id="解构赋值允许默认值"><a href="#解构赋值允许默认值" class="headerlink" title="解构赋值允许默认值"></a>解构赋值允许默认值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>上面的代码不会执行函数 f 输出 aaa 因为该数组解构可以正常取到值 如果代码改为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [x = f()] = [];</span><br></pre></td></tr></table></figure>

<p>此时 会去执行 f 函数 进行默认赋值</p>
<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>变量必须与属性同名 进行解构</p>
<h4 id="解构嵌套的对象"><a href="#解构嵌套的对象" class="headerlink" title="解构嵌套的对象"></a>解构嵌套的对象</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  success: <span class="literal">true</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    username: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  code: <span class="number">200</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  data: &#123; username &#125;,</span><br><span class="line">&#125; = obj;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(username); <span class="comment">// chou</span></span><br></pre></td></tr></table></figure>

<p>但是如果你要输出 data 此时就会报错 data 变量未定义</p>
<p>因为此时 data 作为匹配的模式 如果需要将 data 赋值 那么可以写成如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  data,</span><br><span class="line">  data: &#123; username &#125;,</span><br><span class="line">&#125; = obj;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>个人建议使用对象解构的传参方式 例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">&#123; x, y &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add(&#123; x, y &#125;);</span><br></pre></td></tr></table></figure>

<p>这样就可以规避掉传参时 需要按顺序传参的麻烦 但是使用 TS 的话 就另说啦</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><h4 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>

<h4 id="遍历-Map-结构"><a href="#遍历-Map-结构" class="headerlink" title="遍历 Map 结构"></a>遍历 Map 结构</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&#x27; is &#x27;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><p>ES6 为字符串添加了遍历器接口 使得字符串可以被 for…of 循环遍历</p>
<p>如果需要引用模板字符串本身，在需要时执行，可以写成函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">func(<span class="string">&#x27;Jack&#x27;</span>); <span class="comment">// &quot;Hello Jack!&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。 这看上去很酷<del>~</del></p>
<h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><p>标签模板是一种特殊的函数调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`<span class="subst">$&#123;a - b&#125;</span> Hello <span class="subst">$&#123;a + b&#125;</span> world <span class="subst">$&#123;a * b&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>: [ <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27; Hello &#x27;</span>, <span class="string">&#x27; world &#x27;</span>, <span class="string">&#x27;&#x27;</span> ],</span><br><span class="line">  <span class="string">&#x27;1&#x27;</span>: -<span class="number">5</span>,</span><br><span class="line">  <span class="string">&#x27;2&#x27;</span>: <span class="number">15</span>,</span><br><span class="line">  <span class="string">&#x27;3&#x27;</span>: <span class="number">50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><h4 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>); <span class="comment">// &#x27;ababx&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>); <span class="comment">// &#x27;abax&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>); <span class="comment">// &#x27;xabab&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>); <span class="comment">// &#x27;xaba&#x27;</span></span><br></pre></td></tr></table></figure>

<p>例如 可以用于时间格式化 比如 时分秒如果需要两位 不足两位补 0</p>
<h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><h4 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h4><p>Math.trunc 方法用于去除一个数的小数部分，返回整数部分</p>
<h3 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h3><ul>
<li><p>BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示</p>
</li>
<li><p>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀 n</p>
</li>
<li><p>BigInt 与普通整数是两种值，它们之间并不相等</p>
</li>
<li><p>BigInt 可以使用负号（-），但是不能使用正号（+）</p>
</li>
<li><p>数学运算方面，BigInt 类型的+、-、*和**这四个二元运算符，与 Number 类型的行为一致。除法运算/会舍去小数部分，返回一个整数</p>
</li>
<li><p>BigInt 对应的布尔值，与 Number 类型一致，即 0n 会转为 false，其他值转为 true</p>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的属性"><a href="#函数的属性" class="headerlink" title="函数的属性"></a>函数的属性</h3><h4 id="length"><a href="#length" class="headerlink" title="length"></a>length</h4><p>函数的 length 属性将返回函数的参数个数 但是这个属性也不总是准确的 在函数参数指定默认值后 这个参数就不会被 length 考虑其中</p>
<h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>函数的 name 属性，返回该函数的函数名</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>如果箭头函数直接返回一个对象，必须在对象外面加上括号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getTempItem = <span class="function">(<span class="params">id</span>) =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&#x27;Temp&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。</p>
<p>（3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>（4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</p>
<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><h3 id="ES6-明确将空位转为-undefined"><a href="#ES6-明确将空位转为-undefined" class="headerlink" title="ES6 明确将空位转为 undefined"></a>ES6 明确将空位转为 undefined</h3><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h3><p>还可以接受第二个参数，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">(<span class="params">item, idx</span>) =&gt;</span> idx + <span class="number">1</span>); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>

<h3 id="改变数组自身的方法"><a href="#改变数组自身的方法" class="headerlink" title="改变数组自身的方法"></a>改变数组自身的方法</h3><img src="https://gitee.com/LuckyChou/blog-images/raw/master/js/data-type/array.png" />

<h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><h3 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h3><p>ES6 后 支持 属性名是一个表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="keyword">new</span> <span class="built_in">Date</span>()]: <span class="string">&#x27;welcome&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>Object.assign 同名属性会被后者覆盖而不是合并</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// [4, 5, 3]</span></span><br></pre></td></tr></table></figure>

<p>可以简化操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype, &#123;</span><br><span class="line"><span class="function"><span class="title">someMethod</span>(<span class="params">arg1, arg2</span>)</span> &#123;</span><br><span class="line">···</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">anotherMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等同于下面的写法</span></span><br><span class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span> (<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">···</span><br><span class="line">&#125;;</span><br><span class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h3><p>Object.fromEntries()方法是 Object.entries()的逆操作，用于将一个键值对数组转为对象。<br>该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol 无法被隐式的转换成字符串 如下代码会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> symbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">symbol + <span class="string">&#x27;world; // Uncaught TypeError: Cannot convert a Symbol value to a string</span></span><br></pre></td></tr></table></figure>

<p>但是可以显示的转换为 string 和 布尔值 无法转换成数字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">symbol.toString(); <span class="comment">// &quot;Symbol(hello)&quot;</span></span><br><span class="line">!!symbol; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h3><p>返回描述</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">sym.description; <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-for-Symbol-keyFor"><a href="#Symbol-for-Symbol-keyFor" class="headerlink" title="Symbol.for / Symbol.keyFor"></a>Symbol.for / Symbol.keyFor</h3><p>非常适合单例模式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个已登记的Symbol 如果没有登记就注册一个</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">s1 === s2; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个已登记 Symbol 的 key</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1); <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="消除魔法字符串"><a href="#消除魔法字符串" class="headerlink" title="消除魔法字符串"></a>消除魔法字符串</h3><h2 id="Set-Map"><a href="#Set-Map" class="headerlink" title="Set / Map"></a>Set / Map</h2><p>ES6 提供了新的数据结构 Set / Map 成员的值都是唯一的</p>
<p>内部使用精确相等 NaN 会等于自身 +0 和-0 都会变成 0</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul>
<li><p>size -&gt; 长度</p>
</li>
<li><p>add 添加 -&gt; Set / Map 链式调用</p>
</li>
<li><p>delete 删除 -&gt; boolean</p>
</li>
<li><p>clear 清空 -&gt; void</p>
</li>
<li><p>has -&gt; boolean</p>
</li>
</ul>
<h3 id="WeakSet-WeakMap"><a href="#WeakSet-WeakMap" class="headerlink" title="WeakSet / WeakMap"></a>WeakSet / WeakMap</h3><ul>
<li><p>成员 / 键名必须是对象</p>
</li>
<li><p>这些对象都是弱引用 如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内</p>
</li>
</ul>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写</p>
<p>Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">obj, prop, value</span>)</span> &#123;</span><br><span class="line">    obj[prop] = value;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;prop&#125;</span>属性的set方法执行了`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">obj, prop</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;prop&#125;</span>属性的get方法执行了`</span>);</span><br><span class="line">    <span class="keyword">return</span> obj[prop];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">obj, key</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;has方法执行了&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">obj.name = <span class="string">&#x27;chou&#x27;</span>;</span><br><span class="line">obj.age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> obj);</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// name属性的set方法执行了</span></span><br><span class="line"><span class="comment">// age属性的set方法执行了</span></span><br><span class="line"><span class="comment">// name属性的get方法执行了</span></span><br><span class="line"><span class="comment">// chou</span></span><br><span class="line"><span class="comment">// has方法执行了</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><h3 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys"></a>Reflect.ownKeys</h3><p>Reflect.ownKeys 方法用于返回对象的所有属性，基本等同于 Object.getOwnPropertyNames 与 Object.getOwnPropertySymbols 之和</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>在所有异步操作都执行完毕后 执行的回调</p>
<p>有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。</p>
<p>这时，Promise.allSettled()方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。Promise.all()方法无法做到这一点。</p>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hw.next()); <span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(hw.next()); <span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(hw.next()); <span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(hw.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Generator-与状态机-真的非常优雅"><a href="#Generator-与状态机-真的非常优雅" class="headerlink" title="Generator 与状态机 (真的非常优雅)"></a>Generator 与状态机 (真的非常优雅)</h3><p>传统的 Tick Tock 状态机 （会受到外部 ticking 状态的影响）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ticking = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> clock = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ticking) <span class="built_in">console</span>.log(<span class="string">&#x27;Tick!&#x27;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Tock!&#x27;</span>);</span><br><span class="line">  ticking = !ticking;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 generator 函数改造</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clock = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Tick!&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Tock!&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 事件</title>
    <url>/FE/JS/event/</url>
    <content><![CDATA[<h2 id="JS-事件的三个阶段"><a href="#JS-事件的三个阶段" class="headerlink" title="JS 事件的三个阶段"></a>JS 事件的三个阶段</h2><h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>event<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.father</span> &#123;</span></span><br><span class="line">      width: 500px;</span><br><span class="line">      height: 500px;</span><br><span class="line"><span class="css">      <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.son</span> &#123;</span></span><br><span class="line">      width: 200px;</span><br><span class="line">      height: 200px;</span><br><span class="line"><span class="css">      <span class="selector-tag">background</span>: <span class="selector-id">#888</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.father&#x27;</span>).onclick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;Father&quot;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.target)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.son&#x27;</span>).onclick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;Son&quot;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.target)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.onclick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;Body&quot;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.target)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.documentElement.onclick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;Html&quot;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.target)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述例子 我们创建了两个div 分别是 父盒子 和 子盒子</p>
<p>效果图如下</p>
<img src="https://gitee.com/LuckyChou/blog-images/raw/master/js/event.gif" alt="Event Table" style="zoom:80%;" />

<p>现在 我们要有一个清晰的层级关系</p>
<p>自底向上 分别为 son&gt;father&gt;body&gt;html</p>
<p>现在 我们点击子盒子 触发子盒子的点击事件</p>
<p>我们可以看到 点击事件 像气泡一样自底向上  传递到了顶部</p>
<p>这就是事件冒泡</p>
<p>同理 事件捕获 为自顶向下传递事件</p>
<hr />

<p>addEventListener(“click”,function,”true”)方法</p>
<p>若第三参数为true,则采用事件捕获。若为false，则采用事件冒泡。</p>
<p>IE浏览器不支持事件捕获 只支持事件冒泡</p>
<h2 id="阻止事件传播"><a href="#阻止事件传播" class="headerlink" title="阻止事件传播"></a>阻止事件传播</h2><h3 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h3><p>在W3C中，使用stopPropagation()方法</p>
<p>在IE下使用cancelBubble = true方法</p>
<h2 id="JS-事件代理"><a href="#JS-事件代理" class="headerlink" title="JS 事件代理"></a>JS 事件代理</h2><p>JS事件委托</p>
<p>利用事件冒泡  用父元素来触发每个子元素的事件</p>
<p>我们设想一个场景  有五个input输入框</p>
<p>现在的需求是  每当有一个输入框被输入了  我们要知道是哪个输入框</p>
<p>如果不用事件委托  我们也可以很轻松的解决问题   那就是为每个input绑定onchange事件</p>
<p>可是设想一下 如果我们有大量的输入框呢 手动绑定显然就变得不切实际了</p>
<p>这个时候  我们就可以用到事件委托了  给父元素绑定onchange事件</p>
<p>利用事件冒泡  让子元素的事件传递到父元素  最终在父元素触发事件</p>
<p>代码  和  效果图  如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;_ul&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;4&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;5&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;._ul&#x27;</span>).onchange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br />

<img src="https://gitee.com/LuckyChou/blog-images/raw/master/js/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98.gif" alt="Event Table" style="zoom:80%;" />]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 轮询机制</title>
    <url>/FE/JS/event-loop/</url>
    <content><![CDATA[<h2 id="JavaScript轮询机制"><a href="#JavaScript轮询机制" class="headerlink" title="JavaScript轮询机制"></a>JavaScript轮询机制</h2><p>首先，我们来分析一段代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;******************** start *******************&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise Success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;******************** end *******************&#x27;</span>)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>好了 上面程序的执行结果是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">******************** start *******************</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">******************** end *******************</span><br><span class="line"><span class="built_in">Promise</span> Success</span><br><span class="line"><span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure>



<p>而且不管定时器和promise语句的顺序如何 执行结果都不会发生变化</p>
<p>为什么会有这种现象呢</p>
<h3 id="引入："><a href="#引入：" class="headerlink" title="引入："></a>引入：</h3><ul>
<li><p>Event Loop</p>
</li>
<li><p>Task  /  MicroTask</p>
</li>
</ul>
<h4 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h4><p>Event Loop就是事件循环，我们都知道JavaScript是一门单线程语言，而例如Ajax请求都是耗时的操作，为了阻止页面冻结的情况，JavaScript有异步的解决方案，而Event Loop就是一种解决JavaScript单线程运行时不会阻塞的一种机制，也就是上面提到异步的原理。</p>
<h4 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h4><p>Task队列又称宏任务队列，宏任务队列可以有多个，所有的JavaScript主线程上的代码都在<strong>第一个</strong>宏任务队列上</p>
<p>宏任务队列主要是：整体代码<code>script</code>，<code>setTimeout</code>，<code>setInterval</code>、<code>I/O</code>、<code>UI render</code></p>
<h4 id="MicroTask"><a href="#MicroTask" class="headerlink" title="MicroTask"></a>MicroTask</h4><p>MicroTask队列又称微任务队列，注意，和宏任务队列不同的是，微任务队列只有一个。</p>
<p>微任务队列主要是：<code>Promise</code>、<code>Object.observe</code>、<code>MutationObserver</code></p>
<p>有了这些知识，接下来就可以正式讲讲JS轮询机制了</p>
<hr>
<h3 id="JS轮询机制"><a href="#JS轮询机制" class="headerlink" title="JS轮询机制"></a>JS轮询机制</h3><p>JS的执行机制(一)：</p>
<ol>
<li><p>首先判断JS是同步还是异步,同步就进入主进程,异步就进入event table</p>
</li>
<li><p>异步任务在event table中注册函数,当满足触发条件后,被推入event queue</p>
</li>
<li><p>同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主进程中（所以回调函数也被称为钩子函数）</p>
</li>
</ol>
<p>JS的执行机制(二)</p>
<ol>
<li>执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里</li>
<li>当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完</li>
</ol>
<img src="https://gitee.com/LuckyChou/blog-images/raw/master/js/event.png" alt="Event Table" style="zoom:80%;" />



<img src="https://gitee.com/LuckyChou/blog-images/raw/master/js/event%20table.png" style="zoom:80%;" />





<p>好了，最后我们再分析一下一开始的那段代码</p>
<p>第一个宏任务队列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;******************** start *******************&#39;)</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">console.log(&#39;******************** end *******************&#39;)</span><br></pre></td></tr></table></figure>



<p>第二个宏任务队列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;setTimeout&#39;)</span><br><span class="line">&#125;, 0)</span><br></pre></td></tr></table></figure>



<p>微任务队列（注：只有一个）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.then(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;Promise Success&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Function</title>
    <url>/FE/JS/function/</url>
    <content><![CDATA[<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><ul>
<li><p>函数是一等公民</p>
<ul>
<li>由于函数与其他数据类型地位平等，所以在 js 中又称函数为第一公民</li>
</ul>
</li>
<li><p>function 声明的函数存在变量提升</p>
<ul>
<li>function foo() {……}</li>
</ul>
</li>
<li><p>函数表达式不存在变量提升</p>
<ul>
<li>var foo = function() {……}</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h3 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h3><p>name 返回函数的名字</p>
<p>length 返回函数预计参数的个数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.name);  <span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.length); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>ES5 中 js 只有两种作用域</p>
<p>一种是全局作用域</p>
<p>一种是函数作用域 所以函数拥有自己的作用域</p>
<ul>
<li><p>函数内部的变量提升</p>
<ul>
<li><p>声明的变量会提升到所在作用域的最顶部</p>
</li>
<li><p>函数优先</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码块</span></span><br><span class="line">printf()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printf</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printf</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="literal">undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  a = <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line">printf()</span><br></pre></td></tr></table></figure>

<ul>
<li>函数外部无法访问函数内部的变量</li>
</ul>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><p>同名参数 则取后面那个 （ES6 不允许有同名参数）</p>
</li>
<li><p>arguments 对象</p>
<ul>
<li><p>包含函数运行时所有的参数</p>
</li>
<li><p>伪数组 不是真正的数组</p>
</li>
<li><p><code>arguments.length</code>可以获取参数的个数</p>
</li>
</ul>
</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包就是将函数内部和函数外部连接起来的一座桥梁</p>
<ul>
<li>可以延长变量的作用域</li>
</ul>
<h3 id="立即调用函数（IIFE）"><a href="#立即调用函数（IIFE）" class="headerlink" title="立即调用函数（IIFE）"></a>立即调用函数（IIFE）</h3><ul>
<li><p>函数是一个独立的作用域 可以解决多个 js 文件之间变量名冲突的问题</p>
<ul>
<li><p>注意</p>
<ul>
<li>结尾有；</li>
</ul>
</li>
</ul>
</li>
<li><p>形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形式一</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">//形式二</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)()</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Mock.js</title>
    <url>/FE/JS/mock/</url>
    <content><![CDATA[<h3 id="生成随机-json"><a href="#生成随机-json" class="headerlink" title="生成随机 json"></a>生成随机 json</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Mock <span class="keyword">from</span> <span class="string">&#x27;mockjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Mock.mock(&#123;</span><br><span class="line">  <span class="string">&#x27;string|1-10&#x27;</span>: <span class="string">&#x27;★&#x27;</span>, <span class="comment">//随机生成 1-10 个字符串&quot;★&quot;</span></span><br><span class="line">  <span class="string">&#x27;string2|3&#x27;</span>: <span class="string">&#x27;★&#x27;</span>, <span class="comment">//固定生成 3 个字符串&quot;★&quot;</span></span><br><span class="line">  <span class="string">&#x27;number|+1&#x27;</span>: <span class="number">202</span>, <span class="comment">//每次请求自增 1,初始值为 202</span></span><br><span class="line">  <span class="string">&#x27;number2|1-100.1-10&#x27;</span>: <span class="number">1</span>, <span class="comment">//生成一个浮点数，整数部分1-100，小数部分保留1-10 位。。</span></span><br><span class="line">  <span class="string">&#x27;boolean|1-2&#x27;</span>: <span class="literal">true</span>, <span class="comment">//值为 true 的概率是 1/(1+2)，值为 false 的概率同样是 2/3。</span></span><br><span class="line">  regexp: <span class="regexp">/[a-z][A-Z][0-9]/</span>, <span class="comment">//随机生成满足正则的字符串</span></span><br><span class="line">  <span class="string">&#x27;object|2&#x27;</span>: &#123;</span><br><span class="line">    <span class="number">310000</span>: <span class="string">&#x27;上海市&#x27;</span>,</span><br><span class="line">    <span class="number">320000</span>: <span class="string">&#x27;江苏省&#x27;</span>,</span><br><span class="line">    <span class="number">440000</span>: <span class="string">&#x27;广东省&#x27;</span>,</span><br><span class="line">  &#125;, <span class="comment">//对象中随机选取 2 个属性，生成对象</span></span><br><span class="line">  <span class="string">&#x27;array|1&#x27;</span>: [<span class="string">&#x27;AMD&#x27;</span>, <span class="string">&#x27;CMD&#x27;</span>], <span class="comment">//数组中随机选取 1 个元素，最终生成值</span></span><br><span class="line">  <span class="string">&#x27;arrayRepeat|3&#x27;</span>: [<span class="string">&#x27;AMD&#x27;</span>, <span class="string">&#x27;CMD&#x27;</span>], <span class="comment">//重复数组元素 3 次，最终生成数组</span></span><br><span class="line">  date: <span class="string">&#x27;@date&#x27;</span>, <span class="comment">//生成随机日期</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="拦截请求-（不会真的发送请求）"><a href="#拦截请求-（不会真的发送请求）" class="headerlink" title="拦截请求 （不会真的发送请求）"></a>拦截请求 （不会真的发送请求）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Mock <span class="keyword">from</span> <span class="string">&#x27;mockjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Mock.mock(<span class="string">&#x27;/api&#x27;</span>, &#123;</span><br><span class="line">  <span class="string">&#x27;string|4&#x27;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&#x27;name1|2-9&#x27;</span>: <span class="string">&#x27;哈&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;name2|5&#x27;</span>: <span class="string">&#x27;哈&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&#x27;number|4&#x27;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&#x27;id|+1&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">&#x27;num1|2-9&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">&#x27;num2|1-100.1-10&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&#x27;boolean|4&#x27;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&#x27;success1|1&#x27;</span>: [<span class="string">&#x27;true&#x27;</span>, <span class="string">&#x27;false&#x27;</span>],</span><br><span class="line">      <span class="string">&#x27;success2|1&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&#x27;obj|2&#x27;</span>: &#123;</span><br><span class="line">    name: <span class="string">&#x27;@cname&#x27;</span>,</span><br><span class="line">    region: <span class="string">&#x27;@region&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;Mock.Random|4&#x27;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      boo1: <span class="string">&#x27;@boolean&#x27;</span>,</span><br><span class="line">      img: <span class="string">&#x27;@image&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;@name&#x27;</span>,</span><br><span class="line">      color: <span class="string">&#x27;@color&#x27;</span>,</span><br><span class="line">      title: <span class="string">&#x27;@title&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 模块化</title>
    <url>/FE/JS/modular/</url>
    <content><![CDATA[<h2 id="commonjs"><a href="#commonjs" class="headerlink" title="commonjs"></a>commonjs</h2><p>require / exports</p>
<a id="more"></a>

<h3 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Tool = &#123;</span><br><span class="line">  agent: &#123;</span><br><span class="line">    getActivityList: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;activityList...&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    updateActivityList: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;updateActivityList...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  serve: &#123;</span><br><span class="line">    sendMeg: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.Tool = Tool</span><br></pre></td></tr></table></figure>

<h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Tool &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./commonjs exports&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Tool.serve.sendMeg(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Tool.agent.getActivityList)</span><br></pre></td></tr></table></figure>

<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Tool = &#123;</span><br><span class="line">  agent: &#123;</span><br><span class="line">    getActivityList: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;activityList...&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    updateActivityList: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;updateActivityList...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  serve: &#123;</span><br><span class="line">    sendMeg: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Tool</span><br></pre></td></tr></table></figure>

<h3 id="require-1"><a href="#require-1" class="headerlink" title="require"></a>require</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>ES6 Module<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Tool <span class="keyword">from</span> <span class="string">&#x27;./ES6 export.js&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(Tool)</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器还未很好的支持ES6 Module</p>
<p>script标签默认type属性为javascript</p>
<p>在引入module时 需要告知浏览器这是module</p>
]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 数据类型</title>
    <url>/FE/JS/data-type/</url>
    <content><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量</p>
</li>
<li><p>引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念</p>
</li>
</ul>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li><p>数值（number）</p>
</li>
<li><p>字符串（string）</p>
</li>
<li><p>布尔值（boolean）</p>
</li>
<li><p>undefined</p>
</li>
<li><p>null</p>
</li>
<li><p>symbol</p>
</li>
<li><p>bigInt</p>
</li>
</ul>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><ul>
<li><p>对象（Object）</p>
<ul>
<li><p>正则（RegExp）</p>
</li>
<li><p>数组（Array）</p>
</li>
<li><p>函数（Function）</p>
</li>
<li><p>日期（Date）</p>
</li>
<li><p>数学工具库（Math）</p>
</li>
</ul>
</li>
</ul>
<a id="more"></a>

<p>首先明确一个点 原始类型中存储的都是对应的数值 是没有方法可以调用的 比如 undefined.toString()</p>
<p>但是你顺着这个思路 如果去调用 ‘1’.toString() 你会发现调用成功了</p>
<p>因为这种情况下 ‘1’已经被强转成了 String 类型 所以可以调用 toString 方法</p>
<h2 id="number"><a href="#number" class="headerlink" title="number"></a>number</h2><ul>
<li>js 内部，所有数字都是以 64 位浮点数形式储存，所以 1 === 1.0 为 true 即 1 和 1.0 是同一个数</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><p>parseInt</p>
</li>
<li><p>parseFloat</p>
</li>
<li><p>isNaN</p>
</li>
<li><p>isFinite</p>
</li>
<li><p>isInteger</p>
</li>
</ul>
<h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><ul>
<li>EPSILON</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">0.4</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">const</span> c = <span class="number">0.3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a - b === c); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs(a - b - c) &lt; <span class="built_in">Number</span>.EPSILON); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h3><ul>
<li><p>NaN （not a number）</p>
</li>
<li><p>+0 / -0</p>
</li>
<li><p>Infinite</p>
</li>
</ul>
<p>本质上还是 number</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul>
<li>无法改变字符串之中的单个字符</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> username = chou;</span><br><span class="line">username[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//username还是chou</span></span><br></pre></td></tr></table></figure>

<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><p>charAt</p>
<ul>
<li><p>返回指定索引的字符</p>
</li>
<li><p>如果指定的 index 值超出了该范围，则返回一个空字符串</p>
</li>
</ul>
</li>
<li><p>slice</p>
</li>
<li><p>split</p>
</li>
<li><p>trim / trimStart / trimEnd</p>
<ul>
<li>删除字符串<strong>两侧</strong>的空白 多用于 input 去除用户输入的空格</li>
</ul>
</li>
<li><p>includes</p>
</li>
<li><p>endsWith / startsWith</p>
</li>
<li><p>concat</p>
</li>
<li><p>indexOf</p>
<ul>
<li>返回第一次出现的索引值 未找到返回-1</li>
</ul>
</li>
<li><p>padStart / pafEnd</p>
<ul>
<li>填充字符串达到指定长度</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;123&#x27;</span>.padEnd(<span class="string">&#x27;5&#x27;</span>, <span class="number">0</span>); <span class="comment">//12300</span></span><br><span class="line"><span class="string">&#x27;123&#x27;</span>.padStart(<span class="string">&#x27;5&#x27;</span>, <span class="number">0</span>); <span class="comment">//00123</span></span><br></pre></td></tr></table></figure>

<ul>
<li>repeat</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span>.repeat(<span class="number">5</span>); <span class="comment">//11111</span></span><br></pre></td></tr></table></figure>

<ul>
<li>toLowerCase / toUpperCase</li>
</ul>
<h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><table>
<thead>
<tr>
<th>原始值</th>
<th>转换目标</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>number</td>
<td>boolean</td>
<td>除了 -0 +0 NaN 都是 true</td>
</tr>
<tr>
<td>string</td>
<td>boolean</td>
<td>除了 空串 都是 true</td>
</tr>
<tr>
<td>undefined / null</td>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>引用类型</td>
<td>boolean</td>
<td>true</td>
</tr>
</tbody></table>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><ul>
<li><p>对象就是一组键值对（key - value）的集合</p>
</li>
<li><p>对象的键会转换为 string 类型</p>
</li>
<li><p>对象是引用类型</p>
</li>
</ul>
<p>具体可以参考 <a href="https://luckychou.gitee.io/FE/JS/object/">https://luckychou.gitee.io/FE/JS/object/</a></p>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><ul>
<li><p>函数是一等公民</p>
<ul>
<li>由于函数与其他数据类型地位平等，所以在 js 中又称函数为第一公民</li>
</ul>
</li>
</ul>
<p>具体可以参考 <a href="https://luckychou.gitee.io/FE/JS/function/">https://luckychou.gitee.io/FE/JS/function/</a></p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><ul>
<li>数组是一种特殊的对象</li>
</ul>
<p>具体可以参考 <a href="https://luckychou.gitee.io/FE/JS/array/">https://luckychou.gitee.io/FE/JS/array/</a></p>
<h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><ul>
<li><p>对象没有这个属性名，属性值默认就是 undefined</p>
</li>
<li><p>函数定义形参不传值，默认就是 undefined</p>
</li>
<li><p>在数组的 find 方法中，没有找到的情况下是 undefined</p>
</li>
<li><p>函数定义没有返回值（return 或者 return 后面什么也不带），默认的返回值就是 undefined</p>
</li>
<li><p>在变量提升（预解析）阶段，只声明未定义，默认值就是 undefined</p>
</li>
<li><p>在 JS 的严格模式下（”use strict”），没有明确的主体，this 指的就是 undefined</p>
</li>
</ul>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<h2 id="确定数据类型"><a href="#确定数据类型" class="headerlink" title="确定数据类型"></a>确定数据类型</h2><ul>
<li><p>typeof</p>
</li>
<li><p>instanceof</p>
</li>
<li><p>Object.prototype.toString</p>
</li>
</ul>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><ul>
<li><p>作用于基础数据类型时 除了 null 会返回 object 其他都返回正确的数据类型</p>
</li>
<li><p>作用于引用数据类型时 除了 function 会返回正确的数据类型时 其他都返回 object</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _undefined = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> _null = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> _number = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> _string = <span class="string">&#x27;chou&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> _boolean = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> _bigint = <span class="number">1n</span>;</span><br><span class="line"><span class="keyword">const</span> _symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> _regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;/w/g&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> _date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> _function = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> _array = [];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> _undefined);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> _null); <span class="comment">// 返回object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> _number);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> _string);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> _boolean);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> _bigint);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> _symbol);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> _regexp);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> _date);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> _function); <span class="comment">// 返回function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> _array);</span><br></pre></td></tr></table></figure>

<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><ul>
<li>通过 instanceof 我们能判断这个对象是否是之前那个构造函数生成的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;/w/g&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> _date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> _function = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> _array = [];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_regexp <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(_date <span class="keyword">instanceof</span> <span class="built_in">Date</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(_function <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(_array <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>此外 number/boolean/string 也可以用它们的构造函数来创建</p>
<h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h3><p>可见 上述两种方法都无法准确判断出每一种数据类型 那么有没有一种方法可以判断出所有的数据类型呢</p>
<p>答案就是<code>Object.prototype.toString</code></p>
<p>例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>)); <span class="comment">// [object,Undefined]</span></span><br></pre></td></tr></table></figure>

<p>我们可以得到一个[object,xxx]的字符串 []中的后者就是我们想要的每一种数据类型</p>
<p>我们稍微包装一下方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDataType</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(type).slice(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特殊类型比较"><a href="#特殊类型比较" class="headerlink" title="特殊类型比较"></a>特殊类型比较</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str1 == str2); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str1 === str2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/a/</span> == <span class="regexp">/a/</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/a/</span> === <span class="regexp">/a/</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; == &#123;&#125;); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; === &#123;&#125;); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([] == []); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log([] === []); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol 是一种原始数据类型 表示独一无二的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> symbol1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> symbol2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(symbol1 === symbol2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><p>BigInt 可以表示任意大的整数</p>
<p>BigInt 和 Number 不能混合运算</p>
<h2 id="四组运算"><a href="#四组运算" class="headerlink" title="四组运算"></a>四组运算</h2><p>在进行四则运算的时候 都会转成基础数据类型再进行运算</p>
<h3 id="加法运算符"><a href="#加法运算符" class="headerlink" title="加法运算符"></a>加法运算符</h3><p>运算中其中一方为字符串，那么就会把另一方也转换为字符串</p>
<p>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;1&#x27;</span>; <span class="comment">// &#x27;11&#x27;</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="number">4</span> + [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// &quot;41,2,3&quot;</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> + +<span class="string">&#x27;b&#x27;</span>; <span class="comment">//  &quot;aNaN&quot;</span></span><br></pre></td></tr></table></figure>

<p>除了加法运算符 只要其中一方是数字，那么另一方就会被转为数字</p>
]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Object</title>
    <url>/FE/JS/object/</url>
    <content><![CDATA[<p>JS 中除了基础类型 就是 Object 类型 近期也打算再学习一下 Vue 的响应式原理</p>
<p>无论是 Vue2 的 defineProperty 还是 Vue3 的 Proxy 都是建立在 Object 的 api 上的</p>
<p>所以本篇主要是盘点一下 Object 的 api 更详细的文档请移步<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object">MDN</a></p>
<a id="more"></a>

<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li>对象字面量</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;chou&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Object.create()</li>
</ul>
<p>使用现有的对象来提供新创建的对象的<strong>proto</strong></p>
<ul>
<li>new Object()</li>
</ul>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h4><p>返回一个包含所有给定对象自身可枚举属性名称的数组</p>
<h4 id="Object-entries-obj"><a href="#Object-entries-obj" class="headerlink" title="Object.entries(obj)"></a>Object.entries(obj)</h4><p>返回给定对象自身可枚举属性的 [key, value] 数组</p>
<h4 id="Object-values-obj"><a href="#Object-values-obj" class="headerlink" title="Object.values(obj)"></a>Object.values(obj)</h4><p>返回给定对象自身可枚举值的数组</p>
<h4 id="Object-getOwnPropertyDescriptor-obj"><a href="#Object-getOwnPropertyDescriptor-obj" class="headerlink" title="Object.getOwnPropertyDescriptor(obj)"></a>Object.getOwnPropertyDescriptor(obj)</h4><p>获取一个属性的 descriptor （在 defineProperty 中声明的 未声明的不会返回）</p>
<h4 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h4><p>返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组</p>
<h4 id="Object-getOwnPropertySymbols-obj"><a href="#Object-getOwnPropertySymbols-obj" class="headerlink" title="Object.getOwnPropertySymbols(obj)"></a>Object.getOwnPropertySymbols(obj)</h4><p>返回一个给定对象自身的所有 Symbol 属性的数组</p>
<h4 id="Object-getPrototypeOf-obj"><a href="#Object-getPrototypeOf-obj" class="headerlink" title="Object.getPrototypeOf(obj)"></a>Object.getPrototypeOf(obj)</h4><p>返回指定对象的原型</p>
<h4 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h4><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li>delete(obj.props)</li>
</ul>
<h3 id="扩充"><a href="#扩充" class="headerlink" title="扩充"></a>扩充</h3><h4 id="Object-defineProperty-obj"><a href="#Object-defineProperty-obj" class="headerlink" title="Object.defineProperty(obj)"></a>Object.defineProperty(obj)</h4><h4 id="Object-defineProperties-obj"><a href="#Object-defineProperties-obj" class="headerlink" title="Object.defineProperties(obj)"></a>Object.defineProperties(obj)</h4><ul>
<li><p>obj: 要在其上定义属性的对象。</p>
</li>
<li><p>prop: 要定义或修改的属性的名称。</p>
</li>
<li><p>descriptor: 将被定义或修改的属性的描述符。</p>
<ul>
<li><p>value: 直接给这个属性赋值</p>
</li>
<li><p>writable: 是否可修改 默认 false</p>
</li>
<li><p>enumerable: 是否可枚举(遍历拿值) 默认 false</p>
</li>
<li><p>configurable: 是否可删除 默认 false</p>
</li>
<li><p>set</p>
</li>
<li><p>get</p>
</li>
</ul>
</li>
</ul>
<h4 id="Object-preventExtensions-obj"><a href="#Object-preventExtensions-obj" class="headerlink" title="Object.preventExtensions(obj)"></a>Object.preventExtensions(obj)</h4><p>让一个对象变的不可扩展，也就是永远不能再添加新的属性</p>
<h4 id="Object-isExtensible-obj"><a href="#Object-isExtensible-obj" class="headerlink" title="Object.isExtensible(obj)"></a>Object.isExtensible(obj)</h4><p>判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）</p>
<h4 id="Object-freeze-obj"><a href="#Object-freeze-obj" class="headerlink" title="Object.freeze(obj)"></a>Object.freeze(obj)</h4><p>冻结一个对象 被冻结后不能进行任何操作</p>
<p>不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。</p>
<p>此外，冻结一个对象后该对象的原型也不能被修改。</p>
<h4 id="Object-isFrozen-obj"><a href="#Object-isFrozen-obj" class="headerlink" title="Object.isFrozen(obj)"></a>Object.isFrozen(obj)</h4><p>判断一个对象是否被冻结</p>
<h4 id="Object-seal-obj"><a href="#Object-seal-obj" class="headerlink" title="Object.seal(obj)"></a>Object.seal(obj)</h4><p>封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置</p>
<h4 id="Object-isSealed-obj"><a href="#Object-isSealed-obj" class="headerlink" title="Object.isSealed(obj)"></a>Object.isSealed(obj)</h4><p>判断一个对象是否被密封</p>
<h4 id="Object-setPrototypeOf-obj-prototype"><a href="#Object-setPrototypeOf-obj-prototype" class="headerlink" title="Object.setPrototypeOf(obj, prototype)"></a>Object.setPrototypeOf(obj, prototype)</h4><p>设置一个指定的对象的原型</p>
<blockquote>
<p>警告: 由于现代 JavaScript 引擎优化属性访问所带来的特性的关系，更改对象的 [[Prototype]]在各个浏览器和 JavaScript 引擎上都是一个很慢的操作。其在更改继承的性能上的影响是微妙而又广泛的，这不仅仅限于 obj.<strong>proto</strong> = … 语句上的时间花费，而且可能会延伸到任何代码，那些可以访问任何[[Prototype]]已被更改的对象的代码。如果你关心性能，你应该避免设置一个对象的 [[Prototype]]。相反，你应该使用 Object.create()来创建带有你想要的[[Prototype]]的新对象。</p>
</blockquote>
<h4 id="Object-getPrototypeOf-obj-1"><a href="#Object-getPrototypeOf-obj-1" class="headerlink" title="Object.getPrototypeOf(obj)"></a>Object.getPrototypeOf(obj)</h4><p>获取一个指定的对象的原型</p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><h4 id="Object-assign-target-…sources"><a href="#Object-assign-target-…sources" class="headerlink" title="Object.assign(target, …sources)"></a>Object.assign(target, …sources)</h4><p>将所有<strong>可枚举属性</strong>的值从一个或多个源对象分配到目标对象。它将返回目标对象。</p>
<p><strong>只进行第一层的深拷贝</strong></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="Object-is-val1-val2"><a href="#Object-is-val1-val2" class="headerlink" title="Object.is(val1, val2)"></a>Object.is(val1, val2)</h4><p>与 === 运算符基本一致</p>
<p>区别在于 === 将 -0 和 +0 当作一样 而将 NaN 和 NaN 当作不一样</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 原型</title>
    <url>/FE/JS/prototype/</url>
    <content><![CDATA[<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>在ES2019中 对于prototype的定义为</p>
<blockquote>
<p>给其它对象提供共享属性的对象</p>
</blockquote>
<p>看完后 突然想到了一句话 Vue中一切组件继承自Vue的原型 </p>
<p>这也解释了为什么在每个组件中都可以直接使用Vue的一些方法 因为这些方法被写在了Vue的原型上</p>
<img src="https://gitee.com/LuckyChou/blog-images/raw/master/js/prototypeChain.png" />

<a id="more"></a>

<p>原型对象被创建时，会自动生成一个 <code>constructor</code> 属性，指向创建它的构造函数</p>
<p>构造函数的<code>prototype</code>指向原型对象</p>
<p>实例对象的<code>__proto__</code>指向原型对象</p>
<p>（注）如果在MDN上查阅<code>__proto__</code>这一属性 你可以看到</p>
<blockquote>
<p>已废弃<br>该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。</p>
</blockquote>
<blockquote>
<p>警告: 通过现代浏览器的操作属性的便利性，可以改变一个对象的 [[Prototype]] 属性, 这种行为在每一个JavaScript引擎和浏览器中都是一个非常慢且影响性能的操作，使用这种方式来改变和继承属性是对性能影响非常严重的，并且性能消耗的时间也不是简单的花费在 obj.<strong>proto</strong> = … 语句上, 它还会影响到所有继承来自该 [[Prototype]] 的对象，如果你关心性能，你就不应该在一个对象中修改它的 [[Prototype]]。相反, 创建一个新的且可以继承 [[Prototype]] 的对象，推荐使用 Object.create()。</p>
</blockquote>
<blockquote>
<p>警告: 当Object.prototype.<strong>proto</strong> 已被大多数浏览器厂商所支持的今天，其存在和确切行为仅在ECMAScript 2015规范中被标准化为传统功能，以确保Web浏览器的兼容性。为了更好的支持，建议只使用 Object.getPrototypeOf()。</p>
</blockquote>
<p>官网说的很明白 如果还不理解 看完下面原型链的作用 你应该就明白了</p>
<p>这一部分 看着比较绕 但是理解后 对我们还是很有帮助的 比如原型链的作用</p>
<p><strong>原型链的作用：</strong> 原型链如此的重要的原因就在于它决定了 <code>JavaScript</code> 中继承的实现方式。</p>
<p>当我们访问一个属性时，查找机制如下：</p>
<ul>
<li><p>访问对象实例属性，有则返回，没有就通过 <code>__proto__</code> 去它的原型对象查找。</p>
</li>
<li><p>原型对象上找到即返回，找不到，继续通过原型对象的 <code>__proto__</code> 查找。</p>
</li>
<li><p>一层一层一直找到 <code>Object.prototype</code> ，如果找到目标属性即返回，</p>
<p>找不到就返回 <code>undefined</code>，不会再往下找，因为在往下找 <code>__proto__</code> 就是 <code>null</code> 了。</p>
</li>
</ul>
<p>所以 如果我们用<code>Object.prototype</code>去操作了Object的原型对象 那么所有的对象都会受到影响 因为Object是对象的顶级父类 所有的对象都继承自它们的顶级父类Object</p>
]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 可选链操作符&amp;&amp;空值合并操作符</title>
    <url>/FE/JS/operator-chaining&amp;nullish-coalescing-operator/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近 开始接触到一些ES6以后的新特性 使用起来确实方便了不少</p>
<p>尤其是最近有一个项目 在方法中需要传入index 但是在做非空验证的时候 如果传入的index是0 也会被判断为false 这就十分头疼了 </p>
<p>冗余的判断不仅使代码的可读性变差 而且会使代码变得不简洁</p>
<p>但是在接触到可选链操作符后 emmmmm 这也太香了 避免了 &amp;&amp; 和 多余的非空校验</p>
<p>所以决定以此为开始  陆续的写一些ES6 ES7…之后的新特性</p>
<a id="more"></a>

<h2 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符"></a>可选链操作符</h2><h3 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h3><p>这里我引用一段MDN上的解释</p>
<blockquote>
<p>可选链操作符( ?. )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。?. 操作符的功能类似于 . 链式操作符，不同之处在于，在引用为空(nullish ) (null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值是 undefined。与函数调用一起使用时，如果给定的函数不存在，则返回 undefined。</p>
</blockquote>
<p>或许 你还是?????</p>
<p>不要急  我们来看一道例题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> adventurer = &#123;</span><br><span class="line">  name: <span class="string">&#x27;林克&#x27;</span>,</span><br><span class="line">  weapon: &#123;</span><br><span class="line">    name: <span class="string">&#x27;大师剑&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> weaponName = adventurer.weapon?.name;</span><br><span class="line"><span class="built_in">console</span>.log(weaponName);</span><br><span class="line"><span class="comment">// expected output: 大师剑</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(adventurer.savePrincess?.());</span><br><span class="line"><span class="comment">// expected output: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shieldName = adventurer.shield?.name;</span><br><span class="line"><span class="built_in">console</span>.log(shieldName);</span><br><span class="line"><span class="comment">// expected output: undefined</span></span><br></pre></td></tr></table></figure>

<p>上述例子<code>adventurer.weapon?.name</code></p>
<p>我们试图去寻找adventurer对象下的weapon属性下的name属性</p>
<p>adventurer对象有weapon属性 所以返回我们可以取出我们的大师剑</p>
<p>然后是<code>adventurer.savePrincess?.()</code></p>
<p>显然adventurer下没有savePrincess这个方法 所以救公主？？？ 不存在的 直接返回undefined</p>
<p>最后是<code>adventurer.shield?.name</code></p>
<p>同样的 我们发现 adventurer对象下也没有shield属性 所以直接返回undefined</p>
<p>好啦 至此 我们大概理解了可选链是怎么一回事</p>
<p>接下来 我们来看看 可选链有什么需要注意的地方</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><h4 id="可选链不能用于赋值"><a href="#可选链不能用于赋值" class="headerlink" title="可选链不能用于赋值"></a>可选链不能用于赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> object = &#123;&#125;;</span><br><span class="line">object?.property = <span class="number">1</span>; <span class="comment">// Uncaught SyntaxError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>

<h4 id="短路计算"><a href="#短路计算" class="headerlink" title="短路计算"></a>短路计算</h4><p>当在表达式中使用可选链时，如果左操作数是 null 或 undefined，表达式将不会被计算，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> potentiallyNullObj = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> prop = potentiallyNullObj?.[x++];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// x 将不会被递增，依旧输出 0</span></span><br></pre></td></tr></table></figure>

<p>最后再举一个自己在实际开发中的例子</p>
<p>假如有一个方法<code>setStudentResult(action)</code> 它接收一个对象action</p>
<p>为了让我们的代码健壮 我们必须在方法内部做出参数的非空校验 显然下面这样是不行的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> list = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">action</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setStudent</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">  list[action.index] = action.student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们直接调用<code>setStudent()</code> 显然整个程序都会崩溃</p>
<p>所以在以前 我们可以将方法体改成这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同时包含函数接收了action参数 并且参数中有我们需要的内容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setStudent</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (action) &#123;</span><br><span class="line">    <span class="keyword">if</span> (action.index &amp;&amp; action.student) &#123;</span><br><span class="line">      list[action.index] = action.student;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 如果使用可选链操作符 我们就可以将方法定义成如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setStudent</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (action?.index &amp;&amp; action?.student) &#123;</span><br><span class="line">    list[action.index] = action.student;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 无论是可读性 还是简洁程度 可选链操作符都更胜一筹</p>
<h2 id="空值合并操作符"><a href="#空值合并操作符" class="headerlink" title="空值合并操作符"></a>空值合并操作符</h2><p>还是引用一段MDN上解释</p>
<blockquote>
<p>空值合并操作符（??）是一个逻辑操作符，当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。</p>
</blockquote>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比 ||"></a>对比 ||</h3><p>我们知道 || 逻辑或运算符 也具有相似的功能</p>
<p>也就是在 || 左侧操作数为假值时 会返回右侧 操作数</p>
<p>JS中的假值有</p>
<ul>
<li><p>0</p>
</li>
<li><p>‘’</p>
</li>
<li><p>NaN</p>
</li>
<li><p>null</p>
</li>
<li><p>undefined</p>
</li>
</ul>
<p>所以设想一个场景 我们对一个function中的参数使用 || 运算符 来判断用户是否输入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNum</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = a || <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> b = b || <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> a + b </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码我们用 || 运算符来判断用户 用户输入的合法性 </p>
<p>但是这样我们就无法排除 0 这种情况</p>
<p>如果用户就是输入了0 但是0依旧是一个假值 所以还是会返回 || 操作符右侧是操作数</p>
<p>这就与我们的预期不一致了</p>
<p>而 ?? 空值合并操作符就只是检验了 null 和 undefined</p>
<h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><h4 id="短路计算-1"><a href="#短路计算-1" class="headerlink" title="短路计算"></a>短路计算</h4><p>与 OR 和 AND 逻辑操作符相似，当左表达式不为 null 或 undefined 时，不会对右表达式进行求值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="literal">undefined</span> ?? a++;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="literal">true</span> ?? b++;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="不能与-AND-或-OR-操作符共用"><a href="#不能与-AND-或-OR-操作符共用" class="headerlink" title="不能与 AND 或 OR 操作符共用"></a>不能与 AND 或 OR 操作符共用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> || <span class="literal">undefined</span> ?? <span class="string">&quot;foo&quot;</span>; <span class="comment">// 抛出 SyntaxError</span></span><br><span class="line"><span class="literal">true</span> || <span class="literal">undefined</span> ?? <span class="string">&quot;foo&quot;</span>; <span class="comment">// 抛出 SyntaxError</span></span><br></pre></td></tr></table></figure>

<h4 id="与可选链操作符连用"><a href="#与可选链操作符连用" class="headerlink" title="与可选链操作符连用"></a>与可选链操作符连用</h4><p>两个操作符都是针对 undefined 和 null 两个值</p>
<p>所以我们可以结合这两个操作符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> customer = &#123;</span><br><span class="line">  name: <span class="string">&quot;chou&quot;</span>,</span><br><span class="line">  details: &#123; <span class="attr">age</span>: <span class="number">100</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> customerCity = customer?.city ?? <span class="string">&quot;荒野之息&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(customerCity); <span class="comment">// 荒野之息</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 防盗链</title>
    <url>/FE/JS/referer/</url>
    <content><![CDATA[<blockquote>
<p>HTTP Referer是header的一部分，<br>  当浏览器向web服务器发送请求的时候，一般会带上Referer，<br>  告诉服务器我是从哪个页面链接过来的，服务器藉此可以获得一些信息用于处理。<br>  通过该头域的值，我们可以检测到访问目标资源的源地址</p>
</blockquote>
<a id="more"></a>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前段日子 在自学做项目的时候发现 明明在项目中引用了线上存在的图片 但是在自己的项目中却怎么也显示出来 </p>
<p>查阅资料后发现是这些第三方网站设置了<strong>防盗链</strong></p>
<h2 id="破解防盗链"><a href="#破解防盗链" class="headerlink" title="破解防盗链"></a>破解防盗链</h2><p>先说说防盗链的原理，http 协议中，如果从一个网页跳到另一个网页，http 头字段里面会带个 Referer。</p>
<p>这里的Referer是由于历史原因导致了拼写错误 后来也就一直沿用。</p>
<p>图片服务器通过检测 Referer 是否来自规定域名，来进行防盗链。</p>
<p>如果盗用网站是 https 的 protocol，而图片链接是 http 的话，</p>
<p>则从 https 向 http 发起的请求会因为安全性的规定，而不带 referer，从而实现防盗链的绕过。</p>
<p>官方输出图片的时候，判断了来源(Referer)，就是从哪个网站访问这个图片，</p>
<p>如果是你的网站去加载这个图片，那么Referer就是：你的网站地址；</p>
<p>你网站地址，肯定没在官方的白名单内，所以就看不到图片了。</p>
<p>因此，若不发送Referer，也就是没有来源。那么官方那边，就认为是从浏览器直接访问的，所以就能加载正常的图片了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;referrer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;never&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>比如在掘金上 查看我的一篇文章中一张图片的Request Headers 就可以看到Referer</p>
<img src="https://gitee.com/LuckyChou/blog-images/raw/master/js/referer.png" alt="referer" />


]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Array.prototype.reduce</title>
    <url>/FE/JS/reduce/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前只知道 reduce 可以拿来做数组求和</p>
<p>但其实 reduce 的功能远不于此  所以在此做个总结</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue)；</p>
<a id="more"></a>

<ul>
<li><p>accumulator: 累加器 即函数上一次调用的返回值。</p>
<p>第一次的时候为 initialValue || arr[0]</p>
</li>
<li><p>currentValue: 数组中函数正在处理的的值。</p>
<p>第一次的时候 initialValue || arr[1]</p>
</li>
<li><p>currentIndex: (可选)数据中正在处理的元素索引</p>
<p>如果提供了 initialValue 从 0 开始 否则从 1 开始</p>
</li>
<li><p>array: (可选)调用 reduce 的数组</p>
</li>
<li><p>initialValue: (可选)累加器的初始值。没有时 累加器第一次的值为 currentValue</p>
<p>注意: 在对没有设置初始值的空数组调用 reduce 方法时会报错。</p>
</li>
</ul>
<p>为了更直观的感受 我们来看一个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有初始值</span></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params">accumulator, currentValue, currentIndex, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue</span><br><span class="line">&#125;, <span class="number">10</span>) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>callback</th>
<th>accumulator</th>
<th>currentValue</th>
<th>currentIndex</th>
<th>array</th>
<th>return value</th>
</tr>
</thead>
<tbody><tr>
<td>first call</td>
<td>10(初始值)</td>
<td>1(数组第一个元素)</td>
<td>0(有初始值为 0)</td>
<td>[1, 2, 3, 4]</td>
<td>11</td>
</tr>
<tr>
<td>second call</td>
<td>11</td>
<td>2</td>
<td>1</td>
<td>[1, 2, 3, 4]</td>
<td>13</td>
</tr>
<tr>
<td>third call</td>
<td>13</td>
<td>3</td>
<td>2</td>
<td>[1, 2, 3, 4]</td>
<td>16</td>
</tr>
<tr>
<td>fourth call</td>
<td>16</td>
<td>4</td>
<td>3</td>
<td>[1, 2, 3, 4]</td>
<td>20</td>
</tr>
</tbody></table>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h3><p>可以做一个简单的数组求和</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h3 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h3><p>可以将二维数组扁平化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">].reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.concat(b), []) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h3 id="case3"><a href="#case3" class="headerlink" title="case3"></a>case3</h3><p>可以计算数组中每个元素出现的次数</p>
<p>思路: 初始值设置为{} 用作我们放结果的容器 然后如果容器中有这个元素 就value+1 没有就初始化key</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function">(<span class="params">items, item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item <span class="keyword">in</span> items) &#123;</span><br><span class="line">    items[item]++</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    items[item] = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> items</span><br><span class="line">&#125;, &#123;&#125;) <span class="comment">// &#123;1: 2, 2: 2, 3: 2, 4: 1&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="case4"><a href="#case4" class="headerlink" title="case4"></a>case4</h3><p>数组去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">].reduce(<span class="function">(<span class="params">init, current</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 第一次的时候 init为空 将第一个元素push进init </span></span><br><span class="line">  <span class="comment">// 然后以后每次的current都在init中找是否已经存在相同的元素</span></span><br><span class="line">  <span class="comment">// 没找到就继续push</span></span><br><span class="line">  <span class="keyword">if</span> (init.length === <span class="number">0</span> || init.indexOf(current) === -<span class="number">1</span>) &#123;</span><br><span class="line">    init.push(current)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> init</span><br><span class="line">&#125;, []) <span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>].sort().reduce(<span class="function">(<span class="params">init, current</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 先将数组进行排序</span></span><br><span class="line">  <span class="comment">// 将第一个元素push 进 init</span></span><br><span class="line">  <span class="comment">// 判断以后的每一个元素是否和init中最后一个元素相同</span></span><br><span class="line">  <span class="comment">// 如同不同就继续push</span></span><br><span class="line">  <span class="keyword">if</span> (init.length === <span class="number">0</span> || init[init.length - <span class="number">1</span>] !== current) &#123;</span><br><span class="line">    init.push(current)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> init</span><br><span class="line">&#125;, []) <span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript this</title>
    <url>/FE/JS/this/</url>
    <content><![CDATA[<blockquote>
<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODU4MzQ1MA==&mid=2247484019&idx=1&sn=3f6d9e748ac218b5034c04dce0f25891&chksm=eb558386dc220a901ca63d526cc553c570d736948ed77493465b2836b6a02fc2b181acbe31e0&sessionid=0&scene=126&clicktime=1590037450&enterid=1590037450&ascene=3&devicetype=android-29&version=27000e37&nettype=cmnet&abtest_cookie=AAACAA%3D%3D&lang=en&exportkey=AcdbQZbZYKbgZjM7wKvVQrc%3D&pass_ticket=e%2FyqnqqHU1eUmuswJPT7GF7T%2FJt3o7TJrRQj5vH7ccCzfKKMKCaPKxAZ7Sj26Vr6&wx_header=1">
40道题搞定 JavaScript 的 this
</a>
</blockquote>
<h2 id="this的五种绑定方式"><a href="#this的五种绑定方式" class="headerlink" title="this的五种绑定方式"></a>this的五种绑定方式</h2><ul>
<li><p>默认绑定(非严格模式下this指向全局对象, 严格模式下this会绑定到undefined)</p>
</li>
<li><p>隐式绑定(当函数引用有上下文对象时, 如 obj.foo()的调用方式, foo内的this指向obj)</p>
</li>
<li><p>显示绑定(通过call()或者apply()方法直接指定this的绑定对象, 如foo.call(obj))</p>
</li>
<li><p>new绑定</p>
</li>
<li><p>箭头函数绑定(this的指向由外层作用域决定的)</p>
</li>
</ul>
<a id="more"></a>

<h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><p>非严格模式下 var声明的变量会变成window的属性 function会变成window的方法<br>所以function内部的this指向window</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">//10</span></span><br><span class="line"><span class="built_in">window</span>.foo <span class="comment">// foo()&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>但是严格模式下 全局的this会指向undefined</p>
<h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>this 永远指向最后调用它的那个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  a : <span class="number">1</span>,</span><br><span class="line">  foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.foo(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;chou&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person1.name) <span class="comment">// chou</span></span><br></pre></td></tr></table></figure>

<h2 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h2><p>注意apply和call会执行方法 但是bind不会</p>
<p><strong>总结一下这部分的知识点好了：</strong></p>
<ul>
<li><p><code>this</code> 永远指向最后调用它的那个对象</p>
</li>
<li><p>匿名函数的<code>this</code>永远指向<code>window</code></p>
</li>
<li><p>使用<code>.call()</code>或者<code>.apply()</code>的函数是会直接执行的</p>
</li>
<li><p><code>bind()</code>是创建一个新的函数，需要手动调用才会执行</p>
</li>
<li><p>如果<code>call、apply、bind</code>接收到的第一个参数是空或者<code>null、undefined</code>的话，则会忽略这个参数</p>
</li>
<li><p><code>forEach、map、filter</code>函数的第二个参数也是能显式绑定<code>this</code>的</p>
</li>
</ul>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul>
<li><p>箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined</p>
</li>
<li><p>不受apply等方法修改</p>
</li>
</ul>
<p>箭头函数的<code>this</code>无法通过<code>bind、call、apply</code>来<strong>直接</strong>修改，</p>
<p>但是可以通过改变作用域中<code>this</code>的指向来间接修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;obj1&#x27;</span>,</span><br><span class="line">  foo1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    <span class="keyword">return</span><span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  foo2: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;obj2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj1.foo1.call(obj2)()</span><br><span class="line">obj1.foo1().call(obj2)</span><br><span class="line">obj1.foo2.call(obj2)()</span><br><span class="line">obj1.foo2().call(obj2)</span><br></pre></td></tr></table></figure>



<ul>
<li><p>obj1.foo1.call(obj2)()第一层为普通函数，并且通过.call改变了this指向为obj2，所以会打印出obj2，第二层为箭头函数，它的this和外层作用域中的this相同，因此也是obj2。</p>
</li>
<li><p>obj1.foo().call(obj2)第一层打印出obj1，第二层为箭头函数，使用了.call想要修改this的指向，但是并不能成功，因此.call(obj2)对箭头函数无效，还是打印出obj1。</p>
</li>
<li><p>obj1.foo2.call(obj2)()第一层为箭头函数，并且想要通过.call(obj2)改变this指向，但是无效，且它的外层作用域是window，所以会打印出window，第二层为普通函数，this是最后调用者window，所以也会打印出window。</p>
</li>
<li><p>obj1.foo2().call(obj2)第一层为箭头函数，外层作用域是window，打印出window，第二层为普通函数，且使用了.call(obj2)来改变this指向，所以打印出了obj2。</p>
</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><p><strong>普通或匿名函数内的this，就是调用函数的那个对象</strong>，且绝大多数匿名函数均被实现为this指向window。</p>
</li>
<li><p><strong>箭头函数内的this，就是箭头函数被定义时所在作用域的this</strong></p>
</li>
<li><p>js的this只会在<strong>函数作用域</strong>或<strong>全局作用域</strong>，不要与块级作用域混淆</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 方法库</title>
    <url>/FE/JS/tools/</url>
    <content><![CDATA[<h3 id="cookie-转-JSON"><a href="#cookie-转-JSON" class="headerlink" title="cookie 转 JSON"></a>cookie 转 JSON</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cookieToJson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cookieArr = <span class="built_in">document</span>.cookie.split(<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  cookieArr.forEach(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = i.split(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    obj[arr[<span class="number">0</span>].trim()] = arr[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 第二个key开始 key前面有一个空格 要去掉</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="保存cookie内容"><a href="#保存cookie内容" class="headerlink" title="保存cookie内容"></a>保存cookie内容</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SetCookie</span>(<span class="params">name,value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Days = <span class="number">1</span>;   <span class="comment">//cookie 将被保存一天</span></span><br><span class="line">    <span class="keyword">var</span> exp  = <span class="keyword">new</span> <span class="built_in">Date</span>();  <span class="comment">//获得当前时间</span></span><br><span class="line">    exp.setTime(exp.getTime() + Days*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>);  <span class="comment">//换成毫秒</span></span><br><span class="line">    <span class="built_in">document</span>.cookie = name + <span class="string">&quot;=&quot;</span>+ <span class="built_in">escape</span> (value) + <span class="string">&quot;;expires=&quot;</span> + exp.toGMTString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取cookie内容"><a href="#读取cookie内容" class="headerlink" title="读取cookie内容"></a>读取cookie内容</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr,</span><br><span class="line">    reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;(^| )&#x27;</span> + name + <span class="string">&#x27;=([^;]*)(;|$)&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> ((arr = <span class="built_in">document</span>.cookie.match(reg))) <span class="keyword">return</span> <span class="built_in">unescape</span>(arr[<span class="number">2</span>])</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="判断是否为微信浏览器"><a href="#判断是否为微信浏览器" class="headerlink" title="判断是否为微信浏览器"></a>判断是否为微信浏览器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_weixn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ua = navigator.userAgent.toLowerCase()</span><br><span class="line">  <span class="keyword">if</span> (ua.match(<span class="regexp">/MicroMessenger/i</span>) == <span class="string">&#x27;micromessenger&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断是否为移动端浏览器"><a href="#判断是否为移动端浏览器" class="headerlink" title="判断是否为移动端浏览器"></a>判断是否为移动端浏览器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMobile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="built_in">window</span>.navigator.userAgent.match(</span><br><span class="line">      /(phone|pad|pod|iPhone|iPodios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUCFennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span><br><span class="line">    )</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 移动端</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// PC端</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> chunk = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i += chunk) &#123;</span><br><span class="line">  result.push(data.slice(i, i + chunk))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ], [ 10 ] ]</span></span><br></pre></td></tr></table></figure>


<h3 id="获取url参数"><a href="#获取url参数" class="headerlink" title="获取url参数"></a>获取url参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQuery</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;(^|&amp;)&#x27;</span> + name + <span class="string">&#x27;=([^&amp;]*)(&amp;|$)&#x27;</span>, <span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> r = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).match(reg)</span><br><span class="line">  <span class="keyword">if</span> (r != <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">decodeURI</span>(r[<span class="number">2</span>])</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="url-search-转-object"><a href="#url-search-转-object" class="headerlink" title="url search 转 object"></a>url search 转 object</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getUrlSearchMap = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> search;</span><br><span class="line">    <span class="keyword">if</span> (url !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> hashIndex = url.lastIndexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> searchIndex = url.lastIndexOf(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (searchIndex !== -<span class="number">1</span>) &#123;</span><br><span class="line">            search = hashIndex === -<span class="number">1</span> ?</span><br><span class="line">                url.substr(searchIndex + <span class="number">1</span>)</span><br><span class="line">                :</span><br><span class="line">                url.substring(searchIndex, hashIndex);</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hashIndex !== -<span class="number">1</span>) &#123;</span><br><span class="line">            search = url.substr(hashIndex + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        search = <span class="built_in">window</span>.location.search;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!search) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> hashArr = search.replace(<span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> hashMap = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hashArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tempArr = hashArr[i].split(<span class="string">&#x27;=&#x27;</span>),</span><br><span class="line">            k = tempArr[<span class="number">0</span>],</span><br><span class="line">            v = tempArr[<span class="number">1</span>] || <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (hashMap[k]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(hashMap[k])) &#123;</span><br><span class="line">                hashMap[k].push(v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hashMap[k] = [hashMap[k], v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hashMap[k] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="获取页面滚动元素"><a href="#获取页面滚动元素" class="headerlink" title="获取页面滚动元素"></a>获取页面滚动元素</h3><p>把下面的代码粘贴到调试工具中运行一下，然后滚动页面，就可以看到是哪个元素产生的滚动了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findScroller</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    element.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(element) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Array</span>.from(element.children).forEach(findScroller)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findScroller(<span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML 从URL地址到页面渲染</title>
    <url>/FE/HTML/url/</url>
    <content><![CDATA[<h2 id="从一个url地址到最终页面渲染完成，发生了什么"><a href="#从一个url地址到最终页面渲染完成，发生了什么" class="headerlink" title="从一个url地址到最终页面渲染完成，发生了什么"></a>从一个url地址到最终页面渲染完成，发生了什么</h2><ol>
<li><p>DNS解析：将域名地址解析成IP地址</p>
<p>  – 读取浏览器DNS缓存</p>
<p>  – 读取系统DNS缓存</p>
<p>  – 读取路由器DNS缓存</p>
<p>  – 读取网络运营商DNS缓存</p>
<p>  – 递归搜索：blog.baidu.com</p>
<p>​        – .com 域名下查找DNS解析</p>
<p>​        –  .baidu 域名下查找DNS解析</p>
<p>​        –   blog 域名下查找DNS解析</p>
<p>​        –   出错了</p>
</li>
</ol>
<a id="more"></a>

<ol start="2">
<li><p>TCP连接：TCP三次握手</p>
<ol>
<li><p>第一次握手，由浏览器发起，告诉服务器我要发送请求了</p>
</li>
<li><p>第二次握手，由服务器发起，告诉浏览器我准备好了，你可以发送了</p>
</li>
<li><p>第三次握手，由浏览器发起，告诉服务器，我马上要发送了，准备接受吧</p>
</li>
</ol>
</li>
<li><p>发送请求</p>
<ol>
<li>请求报文：HTTP协议的通信内容</li>
</ol>
</li>
<li><p>接受响应</p>
<ol>
<li>响应报文</li>
</ol>
</li>
<li><p>渲染页面</p>
<ol>
<li><p>遇见HTML标记，浏览器调用HTML解析器构成dom树</p>
</li>
<li><p>遇见style/link，浏览器调用css解析器构成cssom树</p>
</li>
<li><p>遇见script标签，浏览器调用script解析器，处理script代码（绑定事件，修改dom树，cssom树）</p>
</li>
<li><p>将dom树和cssom树合并成一个渲染树</p>
</li>
<li><p>根据渲染树来进行布局</p>
</li>
<li><p>将各个节点绘制到屏幕上（渲染）</p>
</li>
</ol>
</li>
<li><p>断开连接：TCP四次挥手</p>
<ol>
<li><p>第一次挥手：浏览器发起，我东西发完了（请求报文），你准备关闭吧</p>
</li>
<li><p>第二次挥手：服务器发起，我东西接受完了（请求报文），我准备关闭了</p>
</li>
<li><p>第三次挥手：服务器发起，我东西发完了（响应报文），你准备关闭吧</p>
</li>
<li><p>第四次挥手：浏览器发起，我东西接受完了（响应报文），我准备关闭了</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML Iconfont的解决方案</title>
    <url>/FE/HTML/iconfont/</url>
    <content><![CDATA[<h2 id="iconfont"><a href="#iconfont" class="headerlink" title="iconfont"></a>iconfont</h2><p>这里推荐两个 iconfont 的网站</p>
<ul>
<li><p><a href="https://icomoon.io/">https://icomoon.io/</a></p>
</li>
<li><p><a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p>
</li>
</ul>
<p>在网站内选好想要的 icon 后 点击下载 就可以得到如下文件</p>
<ul>
<li><p>iconfont.css</p>
</li>
<li><p>iconfont.svg</p>
</li>
<li><p>iconfont.eot</p>
</li>
<li><p>iconfont.woff</p>
</li>
<li><p>iconfont.ttf</p>
</li>
</ul>
<p>进入 <a href="https://caniuse.com/">can i use</a> 可以查看这些字体的浏览器兼容情况</p>
<a id="more"></a>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>将下载的文件引入到项目中 然后可以在入口文件引入 iconfont.css</p>
<p>然后在需要到地方使用 i 标签即可</p>
<p>例如 iconfont.css 中有如下 icon</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.icon-test</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;\e62a&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>&lt;i class=&quot;icon-test&quot; /&gt;</code>就可以使用这个 icon 了</p>
<p>然后我们可以用 font 的 css 来控制这个 icon</p>
<h2 id="实现一个-Iconfont-组件-（基于-React）"><a href="#实现一个-Iconfont-组件-（基于-React）" class="headerlink" title="实现一个 Iconfont 组件 （基于 React）"></a>实现一个 Iconfont 组件 （基于 React）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./iconfont.css&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> Iconfont = <span class="function">(<span class="params">&#123; iconId, onClick &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">icon-</span>$&#123;<span class="attr">iconId</span>&#125;`&#125; <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Iconfont;</span><br></pre></td></tr></table></figure>

<h2 id="扩充原项目的-iconfont"><a href="#扩充原项目的-iconfont" class="headerlink" title="扩充原项目的 iconfont"></a>扩充原项目的 iconfont</h2><p>如果原有项目中有 iconfont 的相关文件 为了扩充新字体图标 我们可以登录 <a href="https://icomoon.io/">https://icomoon.io/</a></p>
<p>点击 Import Icons 选中 iconfont.svg 再重新下载即可</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML video标签</title>
    <url>/FE/HTML/video/</url>
    <content><![CDATA[<h2 id="video"><a href="#video" class="headerlink" title="video"></a>video</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;cn/video/A.mp4&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">muted</span></span></span><br><span class="line"><span class="tag">  <span class="attr">autoplay</span></span></span><br><span class="line"><span class="tag">  <span class="attr">controls</span></span></span><br><span class="line"><span class="tag">  <span class="attr">poster</span>=<span class="string">&quot;poster.png&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">loop</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a>attribute</h3><ul>
<li>muted 静音</li>
<li>autoplay 自动播放</li>
<li>controls 控制条</li>
<li>poster=”poster.png” 第一次没有播放时的封面</li>
<li>loop 循环播放</li>
</ul>
<a id="more"></a>

<h3 id="实现视频的自动播放"><a href="#实现视频的自动播放" class="headerlink" title="实现视频的自动播放"></a>实现视频的自动播放</h3><p>由于浏览器层面的一些限制</p>
<p>自动播放 会影响用户体验 所以浏览器已经做出限制</p>
<p>所以这里存在误区：</p>
<ul>
<li><p>autoplay 属性能实现自动播放</p>
</li>
<li><p>通过 video api 中的 play 来控制视频的自动播放</p>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p>和 autoplay 属性一起加上静音标签 muted 因为静音下视频可以自动播放</p>
</li>
<li><p>静音播放后 如需播放声音 需要加上交互 在用户交互后 自行解除静音</p>
</li>
</ul>
<h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h3><p>使用过的一个还不错的 video 插件</p>
<p><a href="https://www.npmjs.com/package/plyr">https://www.npmjs.com/package/plyr</a></p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
</search>
